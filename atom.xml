<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HuanBlog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://musiczh.github.io/"/>
  <updated>2020-06-26T10:25:49.614Z</updated>
  <id>https://musiczh.github.io/</id>
  
  <author>
    <name>zhegnhuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kotlin/协程的结构化管理</title>
    <link href="https://musiczh.github.io/2020/06/26/kotlin/%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%BB%93%E6%9E%84%E5%8C%96%E7%AE%A1%E7%90%86/"/>
    <id>https://musiczh.github.io/2020/06/26/kotlin/%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%BB%93%E6%9E%84%E5%8C%96%E7%AE%A1%E7%90%86/</id>
    <published>2020-06-26T10:25:49.614Z</published>
    <updated>2020-06-26T10:25:49.614Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>kotlin/kotlin协程的具体使用</title>
    <link href="https://musiczh.github.io/2020/06/26/kotlin/kotlin%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8/"/>
    <id>https://musiczh.github.io/2020/06/26/kotlin/kotlin%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8/</id>
    <published>2020-06-26T10:01:15.805Z</published>
    <updated>2020-06-26T10:02:11.964Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>kotlin/和线程的那些事</title>
    <link href="https://musiczh.github.io/2020/06/26/kotlin/%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>https://musiczh.github.io/2020/06/26/kotlin/%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</id>
    <published>2020-06-26T10:01:15.805Z</published>
    <updated>2020-06-26T10:01:15.805Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>kotlin/kotlin协程到底有多方便</title>
    <link href="https://musiczh.github.io/2020/06/26/kotlin/kotlin%E5%8D%8F%E7%A8%8B%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E6%96%B9%E4%BE%BF/"/>
    <id>https://musiczh.github.io/2020/06/26/kotlin/kotlin%E5%8D%8F%E7%A8%8B%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E6%96%B9%E4%BE%BF/</id>
    <published>2020-06-26T10:01:15.805Z</published>
    <updated>2020-06-26T10:08:06.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="『彻底弄懂kotlin协程系列』–kotlin协程到底有多方便？"><a href="#『彻底弄懂kotlin协程系列』–kotlin协程到底有多方便？" class="headerlink" title="『彻底弄懂kotlin协程系列』–kotlin协程到底有多方便？"></a>『彻底弄懂kotlin协程系列』–kotlin协程到底有多方便？</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;『彻底弄懂kotlin协程系列』–kotlin协程到底有多方便？&quot;&gt;&lt;a href=&quot;#『彻底弄懂kotlin协程系列』–kotlin协程到底有多方便？&quot; class=&quot;headerlink&quot; title=&quot;『彻底弄懂kotlin协程系列』–kotlin协程到底有
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>kotlin/和线程那些事</title>
    <link href="https://musiczh.github.io/2020/06/26/kotlin/%E5%92%8C%E7%BA%BF%E7%A8%8B%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>https://musiczh.github.io/2020/06/26/kotlin/%E5%92%8C%E7%BA%BF%E7%A8%8B%E9%82%A3%E4%BA%9B%E4%BA%8B/</id>
    <published>2020-06-26T09:54:35.699Z</published>
    <updated>2020-06-26T10:01:25.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="『彻底弄懂kotlin协程系列』–关于挂起与恢复的认识"><a href="#『彻底弄懂kotlin协程系列』–关于挂起与恢复的认识" class="headerlink" title="『彻底弄懂kotlin协程系列』–关于挂起与恢复的认识"></a>『彻底弄懂kotlin协程系列』–关于挂起与恢复的认识</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>阅读之前建议去看一下我的上一篇文章关于什么是kotlin协程的讲解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;『彻底弄懂kotlin协程系列』–关于挂起与恢复的认识&quot;&gt;&lt;a href=&quot;#『彻底弄懂kotlin协程系列』–关于挂起与恢复的认识&quot; class=&quot;headerlink&quot; title=&quot;『彻底弄懂kotlin协程系列』–关于挂起与恢复的认识&quot;&gt;&lt;/a&gt;『彻底弄懂
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>kotlin/什么是kotlin协程</title>
    <link href="https://musiczh.github.io/2020/06/24/kotlin/%E4%BB%80%E4%B9%88%E6%98%AFkotlin%E5%8D%8F%E7%A8%8B/"/>
    <id>https://musiczh.github.io/2020/06/24/kotlin/%E4%BB%80%E4%B9%88%E6%98%AFkotlin%E5%8D%8F%E7%A8%8B/</id>
    <published>2020-06-23T16:15:57.301Z</published>
    <updated>2020-06-26T10:07:10.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="『彻底弄懂kotlin协程系列』–什么是kotlin协程？"><a href="#『彻底弄懂kotlin协程系列』–什么是kotlin协程？" class="headerlink" title="『彻底弄懂kotlin协程系列』–什么是kotlin协程？"></a>『彻底弄懂kotlin协程系列』–什么是kotlin协程？</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>kotlin是一门比较新的语言了，自动被谷歌设为android开发的官方语言后，他的趋势大好，使用的人也越来越多。在kotlin中，有很多新的特性，有好用的，也有不太习惯的，但，协程绝对是让我们又爱又恨的。会用的程序员说他很好用，但是入门的学习门槛又好像挺高的，一不小心还绊倒了。</p><p>我使用了kotlin一阵子之后，对协程也有了一定的了解，写下这一系列的文章来介绍一下协程，当是分享也是给我自己加深印象。我不是业界仅仅只是一个爱编程的程序猿，有不同的见解，还请评论区一起交流或者私信。</p><p>因为kotlin我目前是应用在android开发，所以这一系列的文章也是以android开发为主。。那话不多说，直接开始把</p><h3 id="协程是什么？"><a href="#协程是什么？" class="headerlink" title="协程是什么？"></a>协程是什么？</h3><p>要了解kotlin的协程，可以先来看一下广义中协程的特点是怎么样的。线程和进程我们都很清楚是什么，协程在网上的很多资料也讲了很多。用户态、非阻塞、高性能等等。但是，协程到底是什么？协程是一种对于并发的处理方案。这里要区分一下并行和并发。</p><ul><li>并行：两个任务同时执行，多线程就是这个道理。</li><li>并发：多端同时请求同个对象。例如消费者和生产者模型，同时都要拿到那个容器来进行操作</li></ul><blockquote><p>生产者消费者模型：这个模型是非常经典的。简单点来说就是：现在有一个篮子，A往里面放苹果，B从篮子里取苹果吃，当篮子满了，A会等着，篮子空了，B会等着。这样就是这个模型的大致。但是有几个问题</p><ul><li>如果A和B同时对篮子进行操作，那么篮子里面的苹果会处于不正常的状态。例如当B拿到篮子的副本取出一个苹果，同时A也拿到篮子，存了一个进去，B吃完更新了篮子的状态，然后A再更新状态回去，这个时候篮子中被B 吃掉的苹果就会回来了。出现了错误。</li><li>如果对篮子进行加锁，那么假如篮子是空的，B拿到篮子后，就会等着，而A因为拿不到锁，就会一直等着锁，造成了死锁问题</li></ul></blockquote><p>所以从上面的例子可以看到并发产生的问题，是非常多的，上面只是冰山一角。那协程如何处理这个问题呢？</p><p>协程，顾明思义，协作线程，协程是在线程下粒度更小的程序。他可以在程序运行到某个时刻，先挂起，执行别的程序，然后等到合适的情况再回来继续执行。例如上面的生产者消费者，因为生产和消费处于不同的线程，所以，会导致并发问题。而协程处于单线程，所以没有了并发，那单线程如何并行执行任务呢？</p><p>我们可以先运行B ，去拿到篮子进行取苹果，然后取一半停下来，先去A 那里生产苹果，A生产了，再回来继续执行B的取苹果，吃完苹果取下一个的时候停下来，再重复同样的操作，通过不断地跳跃代码执行的顺序，实现了代码的“并行”，但不是真正的并行，因为是单线程的，所以不存在并行，只是看起来是“并行的”。</p><p>举个栗子，下面是伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">coroutine1：</span><br><span class="line">while(true)&#123;</span><br><span class="line">apple &#x3D; yield &#x2F;&#x2F;1</span><br><span class="line">eat(apple)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">coroutine2：</span><br><span class="line">while(true)&#123;</span><br><span class="line">apple.send(new apple) &#x2F;&#x2F;2</span><br><span class="line">product</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是运行在同个线程的，同运行到1的时候，这个代码所在的协程被挂起，然后执行下面的协程，然后到了2的时候，就返回到协程1，吃完苹果循环又回到了协程2继续执行代码，就这样不断在两个协程之间切换代码执行顺序。实现了看似并并的情况。</p><p>所以我们可以看到协程他是：</p><ul><li>单线程的</li><li>通过控制代码的执行顺序实现“并行”但不是真正的并行</li><li>解决了并发问题，因为单线程不会出现并发</li><li>比线程性能更高，因为他只是通过程序控制了代码的执行顺序，并没有通过操作系统去切换线程，也就是他是“用户态”的</li></ul><p>但是：</p><ul><li>当协程被阻塞的时候，整个线程都会被阻塞</li><li>协程不能处理耗时任务，不然会阻塞线程</li></ul><p>到此我们对协程是什么已经有了一个大概的认识。笔者对于协程的认识只是冰山一角，上述解释有误，还请指出。</p><h3 id="那kotlin中的协程又是什么？"><a href="#那kotlin中的协程又是什么？" class="headerlink" title="那kotlin中的协程又是什么？"></a>那kotlin中的协程又是什么？</h3><p>我们前面讲过，kotlin是基于jvm’的语言，但jvm我们知道，java是不支持协程的啊，也就是.class文件是没有协程的支持的，而kotlin最终是要编译成.class，那kotlin自然是不支持协程，可是kotlin协程，为什么还存在呢？他到底是什么？</p><p>对，kotlin是不支持我上面讲的广义中的协程的本质的，因为jvm是不支持的。但是kotlin的协程，本质上是<strong>一种线程框架</strong>。kotlin通过自动切换线程，来实现协程的优良特性。</p><p>举个栗子，（kotlin代码，不要纠结具体语法细节）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个线程，执行两个方法</span></span><br><span class="line">GlobalScope.launch&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">getApples() </span><br><span class="line">eatApples()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取苹果的方法</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getApples</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//切换到IO线程</span></span><br><span class="line">    withContext(IO线程)&#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>)</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//吃苹果的方法</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eatApples</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面我在kotlin的一个协程内实现了一个循环：先取苹果，再吃苹果。</p><p>我们会发现我们是直接线性写下来的，按照我们的常规思路，这两个方法都不能是耗时的，如果是耗时的那么需要进行别的线程运行逻辑然后回调对吧，但是我们发现，获取苹果的方法是耗时（Thread.sleep(3000)）的，那这样写不就会阻塞线程吗？这才是kotlin协程的巧妙之处。</p><p>前面我讲过了，kotlin协程是一个线程框架，他会自动切换线程。我们看到获取苹果的方法里面，我们手动切换到了IO线程执行耗时逻辑，但是居然不用回调吃苹果的方法，这样不就会让吃苹果的方法先执行了吗？不会的，kotlin协程，会在获取苹果的那个地方先挂起，然后等到获取完苹果，<strong>再回到协程所在的线程</strong>，注意这里吃苹果方法的线程是切回来了，继续执行吃苹果方法，而且不会阻塞线程，因为是在别的线程执行耗时逻辑。</p></blockquote><p>通过上面的一个例子，我们应该可以大概理解了，原来kotlin的协程就是，会自动跳转线程，然后完事还会回到现在的线程，消灭了回调，我们可以用非阻塞的写法来实现阻塞逻辑。是的，如果能了解到这个点，那么我的文章也是有所作用了。</p><h3 id="再了解kotlin协程"><a href="#再了解kotlin协程" class="headerlink" title="再了解kotlin协程"></a>再了解kotlin协程</h3><p>我们可以发现kotlin的协程和广义的协程在使用上是很像的，都是实现了代码的挂起和恢复。只是他们的本质是不同的。kotin的协程把代码挂起不阻塞线程，然后跑去别的线程执行逻辑，然后搞定了再回来继续执行剩下的逻辑，当然，剩下的逻辑也可以进行挂起。而广义的协程是在单线程内进行代码挂起，可以随意调整代码的执行顺序，而kotlin协程，是没有办法做到这一点的，在jvm上无法随意调整代码的执行顺序。</p><p>我们可能有疑问：这样切换线程，是不是开销很大？答案是肯定的，但也不是非常大。这里涉及到源码设计问题，我也不是很理解我就简单说一下我所认识的内容。kotlin内部是维护一个线程池来实现线程切换的，所以他的成本会低了很多。而在线程切换上，底层还是使用Handle来进行切换线程。我前面讲到，kotlin协程他是线程框架，所以他也只是把线程池和handle封装了起来。</p><p>那是不是协程就没啥卵用了？不不不，一个框架最重要的是什么？方便！kotlin协程的方便，超乎你想像。这一个文章就不介绍太多已经两千多字了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这篇文章我们了解了两个点：什么是广义的协程，什么是kotlin的协程。广义的协程是指在代码中调整代码的执行顺序，在单线程解决并发问题，但是不能解决阻塞问题。kotlin的协程由于jvm的限制，他封装线程来实现代码的挂起，用非阻塞的写法来实现阻塞逻辑，但是由于是用到切换线程，所以性能上会比较差。</p><p>如果通过这篇文章你对协程有了新的认识，那么我就满足了。另外，协程他到底有多方便？协程要怎么用？协程他怎么指定线程？协程他怎么知道哪个方法是需要挂起的？上面你写的suspend关键字到底是啥？（没看见suspend，回去看一下例子代码）等等。我都会在我的系列文章更新。欢迎交流。</p><p>文章到此就结束了，有帮助还请点个赞，评个论，收个藏，转个发，谢谢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;『彻底弄懂kotlin协程系列』–什么是kotlin协程？&quot;&gt;&lt;a href=&quot;#『彻底弄懂kotlin协程系列』–什么是kotlin协程？&quot; class=&quot;headerlink&quot; title=&quot;『彻底弄懂kotlin协程系列』–什么是kotlin协程？&quot;&gt;&lt;/a
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>算法：判断链表是否有环</title>
    <link href="https://musiczh.github.io/2020/06/13/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/"/>
    <id>https://musiczh.github.io/2020/06/13/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/</id>
    <published>2020-06-13T09:30:00.000Z</published>
    <updated>2020-06-13T09:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：判断链表是否有环"><a href="#题目：判断链表是否有环" class="headerlink" title="题目：判断链表是否有环"></a>题目：判断链表是否有环</h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>说明：不允许修改给定的链表。</p><p>示例 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：tail connects to node index 1</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle-ii</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>经典问题，这就不考虑哈希表直接用快慢指针了。因为他们的之间并没有一个思维的转换过程而是属于两种思维。</p><p>快慢指针，就是追及问题。我们假设快指针一次走两步，慢指针一次走一步，如下图（图片来自<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii" target="_blank" rel="noopener">leetcode</a>）</p><p><img src="https://img2020.cnblogs.com/blog/1961534/202006/1961534-20200613174021128-445007250.png" alt=""></p><p>在最右边的点第一次相遇。我们运用等式关系可得： 2(F+a) = F+a+k(a+b)</p><p>这里的K是表示在相遇前，快指针走了几次环，k&gt;=1。然后进行化简就可以得到 F = n(a+b)-a  。那也就是F的长度是整数倍（a+b）然后再减去a。这样的话，设置两个指针，一个从原点开始，一个从第一次相遇的点开始，一次递增，最终就会在入口处相遇。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (fast.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;<span class="keyword">while</span> (slow != fast);</span><br><span class="line"></span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span> (slow!=fast)&#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>假设链表的长度是n</p><ol><li>时间复杂度：一共需要2F+a，最坏的情况是入口在末端，需要遍历两次链表</li></ol><blockquote><p>时间复杂度：O(n）</p></blockquote><ol start="2"><li>空间复杂度：只需要指针常量空间</li></ol><blockquote><p>空间复杂度：O（1)</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：判断链表是否有环&quot;&gt;&lt;a href=&quot;#题目：判断链表是否有环&quot; class=&quot;headerlink&quot; title=&quot;题目：判断链表是否有环&quot;&gt;&lt;/a&gt;题目：判断链表是否有环&lt;/h3&gt;&lt;p&gt;给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 
      
    
    </summary>
    
    
      <category term="算法" scheme="https://musiczh.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://musiczh.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="https://musiczh.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>算法：每日温度</title>
    <link href="https://musiczh.github.io/2020/06/12/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/"/>
    <id>https://musiczh.github.io/2020/06/12/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</id>
    <published>2020-06-12T15:30:00.000Z</published>
    <updated>2020-06-12T15:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：每日温度"><a href="#题目：每日温度" class="headerlink" title="题目：每日温度"></a>题目：每日温度</h3><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/daily-temperatures" target="_blank" rel="noopener">https://leetcode-cn.com/problems/daily-temperatures</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>很经典的单调栈题目。思路很简单。还是老方法，算法题，首先从暴力算法开始。</p><p>暴力法：我们遍历数组，然后例如 [73, 74, 75, 71, 69, 72, 76, 73]，首先到73，然后就要找到比他大的第一个数，找到74，然后下标相减，得到1；继续遍历下去就可以。但是这样的话复杂度肯定是太高了。</p><p>仔细观察会发现，暴力法之所以太复杂，是因为没有记录每一次的遍历结果。例如在75的时候，当一直往下遍历到72的时候，其实71和69已经确定了；当到76的时候，72也确定了，最后才确定75，先进后出，这不就是栈吗？</p><p>依次遍历数组，如果栈顶元素的数比当前大，则入栈，如果小，则依次出栈，直到栈空。要注意的是，最后要把栈中的元素全部出栈。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">        <span class="keyword">if</span> (T.length==<span class="number">0</span>) <span class="keyword">return</span> array;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;T.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> top ;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; T[stack.peek()]&lt;T[i])&#123;</span><br><span class="line">                top = stack.pop();</span><br><span class="line">                array[top] = i - top;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            array[stack.pop()] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>假设数组的长度是n</p><ol><li>时间复杂度：遍历一次数组</li></ol><blockquote><p>时间复杂度：O(n）</p></blockquote><ol start="2"><li>空间复杂度：栈的深度和新建数组的大小都是T的长度</li></ol><blockquote><p>空间复杂度：O（n)</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：每日温度&quot;&gt;&lt;a href=&quot;#题目：每日温度&quot; class=&quot;headerlink&quot; title=&quot;题目：每日温度&quot;&gt;&lt;/a&gt;题目：每日温度&lt;/h3&gt;&lt;p&gt;请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数
      
    
    </summary>
    
    
      <category term="算法" scheme="https://musiczh.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://musiczh.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="单调栈" scheme="https://musiczh.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>算法：把数字翻译成字符串</title>
    <link href="https://musiczh.github.io/2020/06/09/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://musiczh.github.io/2020/06/09/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-06-09T14:30:00.000Z</published>
    <updated>2020-06-09T14:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：把数字翻译成字符串"><a href="#题目：把数字翻译成字符串" class="headerlink" title="题目：把数字翻译成字符串"></a>题目：把数字翻译成字符串</h3><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p>示例 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这道题其实思路不难了。经典的动态规划题目。这道题的另一个出题的方向就是算能转换成最多的字符个数。道理是一样的。</p><p>动态规划最核心是什么？动态转换方程。对，<strong>一定要完全理解好这个方程，否则就会一直出错</strong>。这道题中每一个数，如果和他上一个数合起来成为两位数，如果这个两位数在10-25之间，那么这个位置所能表示的最多翻译方法是上一个位置的数目+上上一个位置的数目。我们来看看为什么。</p><p>例如有12258</p><ul><li>首先得到1，那么只有一种可能。</li><li>得到2，那么有两种可能：一种是2保持本身得到一个字符，那么这种情况下的个数就是和前一个位置一样；第二种情况是和1合并成为12，所以一共有1+1=2种可能。</li><li>再次得到2 ，和上面的步骤二相同，1+2=3种</li><li>得到5,2+3=5</li><li>得到8，这里就不一样了，因为58不能表示为字符，所以只能8单独作为一个字符，所以和上个位置一样：5.</li></ul><p>所以整个转态转换可以理解了吧。判断两位是否可以成为一个字符，然后再代入转态转换方程即可。</p><p>这个思想有两种实现方式：迭代和递归。两种方式都很好理解，思想是一样的，看下面代码就可以理解了。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="方法一：迭代"><a href="#方法一：迭代" class="headerlink" title="方法一：迭代"></a>方法一：迭代</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (num&lt;<span class="number">10</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        String s = String.valueOf(num);</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">        array[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        array[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i-<span class="number">2</span>)&gt;<span class="string">'2'</span>||s.charAt(i-<span class="number">2</span>)&lt;<span class="string">'1'</span>) array[i] = array[i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i-<span class="number">2</span>)==<span class="string">'2'</span>&amp;&amp;s.charAt(i-<span class="number">1</span>)&gt;<span class="string">'5'</span>) array[i] = array[i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span>  array[i] = array[i-<span class="number">1</span>]+array[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> array[array.length-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num&gt;<span class="number">9</span>&amp;&amp;num&lt;<span class="number">26</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (num&lt;<span class="number">100</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (num%<span class="number">100</span>&lt;<span class="number">26</span>&amp;&amp;num%<span class="number">100</span>&gt;<span class="number">9</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> translateNum(num/<span class="number">10</span>)+translateNum(num/<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> translateNum(num/<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>假设num的大小是n</p><ol><li>时间复杂度：我们需要遍历数字num的长度</li></ol><blockquote><p>时间复杂度：O(logn）</p></blockquote><ol start="2"><li>空间复杂度：栈的深度和新建数组字符串的大小都是num的长度</li></ol><blockquote><p>空间复杂度：O(logn)</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：把数字翻译成字符串&quot;&gt;&lt;a href=&quot;#题目：把数字翻译成字符串&quot; class=&quot;headerlink&quot; title=&quot;题目：把数字翻译成字符串&quot;&gt;&lt;/a&gt;题目：把数字翻译成字符串&lt;/h3&gt;&lt;p&gt;给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 
      
    
    </summary>
    
    
      <category term="算法" scheme="https://musiczh.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://musiczh.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://musiczh.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>算法：最长连续序列</title>
    <link href="https://musiczh.github.io/2020/06/09/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/"/>
    <id>https://musiczh.github.io/2020/06/09/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</id>
    <published>2020-06-09T14:30:00.000Z</published>
    <updated>2020-06-09T14:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：最长连续序列"><a href="#题目：最长连续序列" class="headerlink" title="题目：最长连续序列"></a>题目：最长连续序列</h3><p>给定一个未排序的整数数组，找出最长连续序列的长度。</p><p>要求算法的时间复杂度为 O(n)。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [100, 4, 200, 1, 3, 2]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-consecutive-sequence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-consecutive-sequence</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>找到一组数的集合，我们想一下可能有的方法，动态规划？貌似没有状态转移方程可以写；滑动窗口？他不是连续的子数组。</p><p>首先依然是暴力：遍历每个数，找到每个数的时候，再遍历数组看看有没有下个数，然后再遍历，再看看有没有下个数，三次循环就可以得到以每个数为起点的最长字段。ok我们发现，复杂度是O(n^3)。这是不可接受的。然后我们来进行优化。</p><p>我们在查找每个数的下继，例如得到2 ，那我们就要看看有没有3。这种情况能不能进行优化？答案是可以的，用哈希表。我们把每个数当成key值放进哈希表，然后只要直接查询该数是否存在即可。哈希表的查询复杂度是O(1)所以这里就降低成为了O(n^2)。显然还不够，我们继续优化。</p><p>我们会发现，如果存在2,3,4,5这个集合，那么我们会轮流都去以2,3,4,5为最小值去寻找最长字符串。例如一个数组是[2,3,4,5]。第一次在下标0得到2，然后继续寻找直到得到2,3,4,5.然后第二次来到下标1得到3，我们会继续去寻找得到3,4,5，但其实，我们前面的2,3,4,5已经包含了他，所以我们不用再去寻找一遍了。所以问题来到，我们如何去记录已经得到的遍历结果？显然记录的话会有额外的空间成本，这是必然的，否则就是进行状态转换，但是显然不太行（或者你有思路可以留言分享一下）。我们会发现3,4,5之所以不行是因为前面还有一个2对不对？那么我们在遍历的时候，只需要找还有没有前继，如果没有就进行寻找最长字符串，如果有，就跳过。这样下来每个字符在形成最长连续序列中只会遍历一次，所以也就压缩了时间复杂度成为O（n）</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">     Set&lt;Integer&gt; num_set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">         num_set.add(num);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> longestStreak = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> num : num_set) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!num_set.contains(num - <span class="number">1</span>)) &#123;</span><br><span class="line">             <span class="keyword">int</span> currentNum = num;</span><br><span class="line">             <span class="keyword">int</span> currentStreak = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">while</span> (num_set.contains(currentNum + <span class="number">1</span>)) &#123;</span><br><span class="line">                 currentNum += <span class="number">1</span>;</span><br><span class="line">                 currentStreak += <span class="number">1</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             longestStreak = Math.max(longestStreak, currentStreak);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> longestStreak;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ol><li>时间复杂度：我们需要遍历数组，在形成最长连续序列中每个数都要遍历一次</li></ol><blockquote><p>时间复杂度：O(n）</p></blockquote><ol start="2"><li>空间复杂度：只需要一个哈希表</li></ol><blockquote><p>空间复杂度：O(n)</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：最长连续序列&quot;&gt;&lt;a href=&quot;#题目：最长连续序列&quot; class=&quot;headerlink&quot; title=&quot;题目：最长连续序列&quot;&gt;&lt;/a&gt;题目：最长连续序列&lt;/h3&gt;&lt;p&gt;给定一个未排序的整数数组，找出最长连续序列的长度。&lt;/p&gt;
&lt;p&gt;要求算法的时间复杂
      
    
    </summary>
    
    
      <category term="算法" scheme="https://musiczh.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://musiczh.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法：合并两个有序链表</title>
    <link href="https://musiczh.github.io/2020/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <id>https://musiczh.github.io/2020/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E8%BF%90%E8%BE%93%E5%B1%82/</id>
    <published>2020-06-04T16:30:00.000Z</published>
    <updated>2020-06-04T16:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-–-运输层"><a href="#计算机网络-–-运输层" class="headerlink" title="计算机网络 – 运输层"></a>计算机网络 – 运输层</h1><h2 id="运输层协议概述"><a href="#运输层协议概述" class="headerlink" title="运输层协议概述"></a>运输层协议概述</h2><h3 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信"></a>进程之间的通信</h3><ol><li><p>什么是运输层？</p><p>网络层是解决主机与主机之间的通信，例如我的手机和你的手机之间的数据连通。但是手机中有微信，qq，王者荣耀，你一边更新王者荣耀一遍发微信，你的手机同时接收的数据包，怎么知道这些包是微信的还是王者的呢？这就是运输层做的事情：提供进程之间的通信。</p></li><li><p>和网络层以及应用层的关系？</p><p>运输层是提供一条进程之间的逻辑线路，让进程之间去通信，是比网络层更上层的协议。在路由转发中只涉及到网络层。同时运输层也是用户感知的最底层，他是直接和应用层进行连接。</p></li></ol><h3 id="运输层两个重要协议"><a href="#运输层两个重要协议" class="headerlink" title="运输层两个重要协议"></a>运输层两个重要协议</h3><ol><li><p>概述</p><p>两个比较重要的协议。但是要注意和网络层的协议区分开。这里的协议指的是端对端的，是应用和主机端口之间的通信协议，而不是在路由转发中的协议。</p></li><li><p>UDP</p><p>用户数据报协议。无连接而且不可靠，因为受到数据报不需要回复。但是优点是开销小。</p></li><li><p>TCP</p><p>传输控制协议。面向连接且可靠的，但是缺点是开销比较大。而且连接的特性决定了不能进行广播和多播。</p></li></ol><h3 id="运输层的端口"><a href="#运输层的端口" class="headerlink" title="运输层的端口"></a>运输层的端口</h3><ol><li><p>什么是端口？</p><p>这个其实很好理解。因为运输层是应用程序和主机之间的逻辑通信，所以每个应用程序应该有一个标识，就像IP地址一样，不然怎么知道数据报给哪个应用呢。所以主机拿到数据报，解析一下端口号，例如80，然后就把数据给80这个端口，然后使用这个端口的应用程序就可以拿到数据了。但是有一个点是要注意的：端口是固定的但是应用程序是动态的，所以也就保证了应用程序不断切换，例如后台杀死重建啊什么的，但是依然可以接收到数据。只要使用同一个端口即可。</p></li><li><p>运输层端口和链路层的端口有什么区别？</p><p>运输层的端口是只有本都意义的，在互联网上没有任何意义。而链路层的路由器上面的端口是硬件端口，是不同设备之间的连接。而运输层的端口只是为了标识应用程序。</p></li><li><p>两大类端口</p><ul><li>服务端使用的端口：服务端嘛，就是要稳定，不然一直换端口别人就受不了了。所以服务端的端口特点就是稳定，数值也比较少。</li><li>客户端的端口：数值比较大，但是不稳定，所以数量多。</li></ul></li></ol><h2 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol><li><p>UDP有什么作用：</p><p>UDP十分简单。我们知道，应用程序把数据报给到传输层，而UDP只是吧应用程序给的数据报加个头部就给网络层去转发了。头部主要是标记源端口和目的端口，以及检验正确性。</p></li><li><p>UDP的特点：</p><ul><li>他是不可靠的。因为只是把数据加个头就发过去，也没有错误重发什么的。所以只是尽量交付，而不是可靠交付。</li><li>UDP是无连接的。这个从他的工作原理可以看出来。</li><li>UDP是面向报文的。UDP主要就是处理报文然后给网络层去转发。</li><li>UDP没有拥塞控制。因为没有重发，也就不需要拥塞控制了。</li></ul><p>但是</p><ul><li>UDP开销比较小。因为没有花里胡哨的工作。</li><li>UDP的速度比较快，不用去创建连接直接就可以用了。</li><li>UDP支持一对多或者多对多。</li></ul></li></ol><h3 id="UDP头部"><a href="#UDP头部" class="headerlink" title="UDP头部"></a>UDP头部</h3><ol><li>组成：三部分：源端口目的端口，长度和校验码</li><li>伪头部：用于创建检验码用的，伪头部主要是源IP地址，目的IP地址，协议字段值以及UDP的长度。</li></ol><h2 id="传输控制协议TCP概述"><a href="#传输控制协议TCP概述" class="headerlink" title="传输控制协议TCP概述"></a>传输控制协议TCP概述</h2><h3 id="什么是TCP"><a href="#什么是TCP" class="headerlink" title="什么是TCP"></a>什么是TCP</h3><p>这里只简单讲一下关于TCP的一些特点，具体的实现原理后面还有好多好多节去学习。简单来说，TCP是一个运输层的协议，他是<strong>面向连接</strong>的，和UDP不一样。TCP是建立一个连接，然后源源不断地发送数据过去。要注意的是这个连接是虚拟的，不是真实的物理连接。</p><h3 id="TCP的特点"><a href="#TCP的特点" class="headerlink" title="TCP的特点"></a>TCP的特点</h3><ol><li>他是面向连接的</li><li>他是点对点的，不能一对多或者多对多等</li><li>他可以提供可靠交付</li><li>提供全双工通信（两边都可以互发信息）</li><li>面向字节流</li></ol><h3 id="什么是面向字节流"><a href="#什么是面向字节流" class="headerlink" title="什么是面向字节流"></a>什么是面向字节流</h3><p>这个是TCP工作原理的重点，虽然不难，但是一定要懂。</p><p>TCP不是像UDP那样从用户那里拿数据报然后一个个发送，TCP是把这些数据看成流，在缓冲区合成一整块，然后根据网络状况，分割后加上TCP头部发送。所以说TCP是面向字节流的，因为他没有数据包的概念，用户的数据都看成流。这样的好处是TCP可以根据网络情况进行恰当地切割，防止拥塞。</p><h3 id="TCP的连接"><a href="#TCP的连接" class="headerlink" title="TCP的连接"></a>TCP的连接</h3><ol><li>TCP不是和UDP一样用端口作为点对象，而是使用socket也就是套接字为端点。套接字是什么？这个也很好理解，就是 IP+端口号。这个就可以唯一标识一个TCP连接了。</li><li>TCP的连接是由软件所提供的一种抽象，不是真正真正真正的连接。</li></ol><h2 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h2><h3 id="怎样才是可靠的？"><a href="#怎样才是可靠的？" class="headerlink" title="怎样才是可靠的？"></a>怎样才是可靠的？</h3><p>前面讲到TCP是可靠的，但是为什么TCP是可靠的？原理是什么？这一小节就比较详细地展开。这里要讲一个点，都说可靠可靠，那到底满足什么样的条件才是可靠的？</p><ol><li>在网络传输的过程中不会出现数据的损坏或者丢失。</li><li>无论发送方用怎么样的速率去传输，接收方始终可以一直接受。</li></ol><p>满足上述两个条件就可以实现可靠运输了。但是这两个条件和让你拿着一把刀去抢劫银行一样，看似好像很微妙，事实上就是吃太多作业太少成天幻想。所以我们要做的就是如何用协议去实现这样的特性，把不可靠的网络环境，实现可靠的数据传输。</p><h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><h4 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h4><ol><li>TCP对应用程序来的数据缓存后进行切割后，分成一个个数据报进行转发，每一个数据报转发给对方后就停下来，对方收到后就发送ACK告诉自己收到了，这个时候就可以发送第二个了。</li><li>如果发送的数据损坏了，或者数据在传输的时候人间蒸发了，这个时候对方什么也不做。自己就会等，等到一点时间没回复再继续发送一次，这就是超时重传。</li><li>如果对方给自己的确认ACK丢失或者迟到了了怎么办？自己还是按照超时重传再发一份，如果收到重复的数据就丢弃就行。对方收到重复的数据包也是直接丢弃。</li><li>当网络情况不好的时候，那么就会一直重发，达到一定的次数就说明当前网络不可用，停止发送。</li></ol><p>自动重传请求：上述步骤自动完成就是ARQ自动重传请求。ARQ实现了在不可靠的网络上进行可靠的数据传输。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>信道利用率很低。每次都要等，特别是网络状况不好的时候，效率会变得极低。</p><h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><h4 id="为什么有这个协议？"><a href="#为什么有这个协议？" class="headerlink" title="为什么有这个协议？"></a>为什么有这个协议？</h4><p>我们可以发现就是前面的停止等待协议效率太慢了，傻傻的。一个发送出去了，没收到回复就是什么都不做，干等，所以我们可以改善这个情况。这里就要引入一个概念：流水线传输。不断地一个个发送，不用去等待回复后才可以继续发送。</p><h4 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h4><ol><li>在上文的停止等待协议的基础上，不进行等待，不断地进行发送，用一个滑动窗口来记录。当收到对方的ACK的时候就把窗口往前移动一点。例如有123456789 共九个包，现在发送了1234，这个时候窗口就是1234，这个时候收到了数据包1 的ACK，那么窗口就变成234，以此类推。</li><li>接收方主要是采用累积确认的方式，只发送按序的最后一个确认。例如现在发了12345共五个包过去，然后第4个炸了，那么接受方只返回到第三的ACK，而45就会进行超时重传。好处是不用一直发送确认ACK，缺点是没办法实时监控每个包的发送情况。</li><li>如果发生错误，上文讲到会回退到45重传，这就是G-back-N。接收方只返回按序正确的最后一个ACK，剩下的就等待超时重传。缺点是当网络不好的时候就是一个灾难，会一直回退，导致效率极低。</li></ol><h3 id="TCP可靠传输小结"><a href="#TCP可靠传输小结" class="headerlink" title="TCP可靠传输小结"></a>TCP可靠传输小结</h3><p>现在我们来小结一下如何实现可靠传输。</p><ol><li>TCP协议通过把用户要传输的数据当成流输入在缓存区后，按照窗口以及网络情况等适当切割并标上序号，分别发送。</li><li>接收端也有一个缓存区，把接收到的包都放在缓存区中，进行校对。</li><li>发送采用连续ARQ协议，不断发送，接受方只返回到损坏包前的序号的ACK，发送端要重传该序号后的所有包。</li><li>发送端和接收端都有类似的窗口来记录传输结果，保证所有包都完整送达。按照序号来保证传输的可靠传输而不是字节。所以TCP都是基于序号而不是字节。</li><li>因为网络情况的复杂性，所以超时重传的时间要估算比较合理。</li></ol><p>TCP靠着连接，然后把数据分包不断重传直到全部完整发送完毕，实现了在不可靠的网络环境中，进行可靠的数据传输。</p><h2 id="TCP-报文段的首部格式"><a href="#TCP-报文段的首部格式" class="headerlink" title="TCP 报文段的首部格式"></a>TCP 报文段的首部格式</h2><h3 id="头部各字段的含义"><a href="#头部各字段的含义" class="headerlink" title="头部各字段的含义"></a>头部各字段的含义</h3><p>这一小节的内容比较枯燥，而且涉及的概念比较多。有了解过http报文的可能知道头部有很多的参数，每个参数都有独特的意义，所以还是要过一遍。然后难懂一点的字段的解释我会分开讲一下。</p><p>先上一个图：</p><p><img src="https://img-blog.csdnimg.cn/2020060219590141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc2Njc1Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><table><thead><tr><th>头部参数</th><th>字节数</th><th>作用</th></tr></thead><tbody><tr><td>源端口和目的端口字段</td><td>各占两字节</td><td>端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。</td></tr><tr><td>序号字段</td><td>4 字节</td><td>TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。</td></tr><tr><td>确认号字段</td><td>4字节</td><td>是期望收到对方的下一个报文段的数据的第一个字节的序号。</td></tr><tr><td>数据偏移（即首部长度）</td><td>4位</td><td>指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）</td></tr><tr><td>保留字段</td><td>6位</td><td>保留为今后使用，但目前应置为 0</td></tr><tr><td>紧急 URG</td><td>1位</td><td>当 URG =1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)</td></tr><tr><td>确认 ACK</td><td>1位</td><td>只有当 ACK=1 时确认号字段才有效。当 ACK = 0 时，确认号无效</td></tr><tr><td>推送 PSH (PuSH</td><td>1位</td><td>接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。</td></tr><tr><td>复位 RST (ReSeT)</td><td>1位</td><td>当 RST =1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。</td></tr><tr><td>同步 SYN</td><td>1位</td><td>同步 SYN = 1 表示这是一个连接请求或连接接受报文。</td></tr><tr><td>终止 FIN (FINish)</td><td>1位</td><td>用来释放一个连接。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接</td></tr><tr><td>窗口字段</td><td>2字节</td><td>用来让对方设置发送窗口的依据，单位为字节。</td></tr><tr><td>检验和</td><td>2字节</td><td>检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</td></tr><tr><td>紧急指针字段</td><td>2字节</td><td>指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）</td></tr><tr><td>选项字段</td><td>长度不定</td><td>TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。”（这里他的概念是不正确的，MSS说是最大报文段长度，但实际上指的是数据段而不是整个报文段）</td></tr><tr><td>填充字段</td><td>不定</td><td>这是为了使整个首部长度是 4 字节的整数倍。</td></tr></tbody></table><p>选项字段中包含以下其他选项：</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>窗口扩大选项</td><td>占 3 字节，其中有一个字节表示移位值 S。新的窗口值等于 TCP 首部中的窗口位数增大到 (16 + S)，相当于把窗口值向左移动 S 位后获得实际的窗口大小</td></tr><tr><td>时间戳选项</td><td>占 10 字节，其中最主要的字段时间戳值字段（4 字节）和时间戳回送回答字段（4 字节）</td></tr><tr><td>选择确认选项</td><td>接收方收到了和前面的字节流不连续的两个字节块。</td></tr><tr><td>如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据</td><td></td></tr></tbody></table><h3 id="重点难懂字段的解析"><a href="#重点难懂字段的解析" class="headerlink" title="重点难懂字段的解析"></a>重点难懂字段的解析</h3><h4 id="序号，确认号，窗口值"><a href="#序号，确认号，窗口值" class="headerlink" title="序号，确认号，窗口值"></a>序号，确认号，窗口值</h4><p>这几个是关系比较大的。首先我们知道tcp报是有序号的，第一个序号是指发送端发送的报文是从哪个开始，确认号是接受端返回给发送端告诉他下一个应该从哪开始。例如发送了1234，那么序号就是1，确认号就是5。窗口值指的是接收端缓冲区的大小。告诉对方我这里剩下多少缓冲内存了，你不要发太多我缓冲不下来。<strong>这里序号的单位是字节。每一个字节遍一个序号</strong></p><h4 id="选项字段"><a href="#选项字段" class="headerlink" title="选项字段"></a>选项字段</h4><p>选项字段的长度是不定的，看要发送什么数据。根据需要改变长度。</p><h2 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h2><p>上面我们已经讲到他的原理，这里更加详细地陈述如何实现可靠传输。</p><h3 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h3><p>经过上面原理的讲述已经可以大概了解这个窗口的实现。可以先跳到前面看一下。这里说一些重点。</p><h4 id="缓存区"><a href="#缓存区" class="headerlink" title="缓存区"></a>缓存区</h4><ul><li><p>发送缓存用来暂时存放：<br>发送应用程序传送给发送方 TCP 准备发送的数据；<br>TCP 已发送出但尚未收到确认的数据。</p></li><li><p>接收缓存用来暂时存放：<br>按序到达的、但尚未被接收应用程序读取的数据；<br>不按序到达的数据。</p></li></ul><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><h5 id="发送端的构造窗口"><a href="#发送端的构造窗口" class="headerlink" title="发送端的构造窗口"></a>发送端的构造窗口</h5><ul><li><p>根据 B 给出的窗口值，A 构造出自己的发送窗口。</p></li><li><p>发送窗口表示：在没有收到 B 的确认的情况下，A 可以连续把窗口内的数据都发送出去。 </p></li><li><p>发送窗口里面的序号表示允许发送的序号。</p></li><li><p>显然，窗口越大，发送方就可以在收到对方确认之前连续发送更多的数据，因而可能获得更高的传输效率。</p></li></ul><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>发送端</p><ul><li><p>应用程序把需要发送的数据放到tcp发送缓存区中</p></li><li><p>发送端会根据接收端的窗口大小不断发送包</p></li><li><p>已经确认收到的，窗口后沿会往前走，没有收到确认就会一直等待，超时重传，直到收到确认。</p></li><li><p>后沿往前走，窗口前沿也会往前走直到全部发送完成</p></li></ul><p>接收端</p><ul><li>接收端接收到数据就会放到缓存区中</li><li>序号连续的表示数据完好，然后窗口后沿往前走，等待数据被应用程序读取。</li><li>遇到丢失的数据包，会发送确认让发送端重新发送。</li><li>窗口中包含未发送确认但是已经收到的包（也包含尚未接受到的包）</li></ul><p>下面看个图片方便理解</p><p><img src="https://img-blog.csdnimg.cn/20200602220922374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc2Njc1Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h4><ul><li>第一，A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）。</li><li>第二，TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。</li><li>第三，TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。</li><li>接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。<br>但请注意两点：<ul><li>第一，接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，这反而浪费了网络的资源。。 </li><li>第二，捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。</li></ul></li></ul><h3 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h3><h4 id="为什么很重要"><a href="#为什么很重要" class="headerlink" title="为什么很重要"></a>为什么很重要</h4><p>这个点是前面我们没有讲的但是非常重要的点。因为这个时间要把握好。如果把握不好会有什么问题：</p><ul><li>时间太长：空闲时间太长，效率差</li><li>时间太短：频繁重发，浪费资源。</li></ul><h4 id="受什么因素影响"><a href="#受什么因素影响" class="headerlink" title="受什么因素影响"></a>受什么因素影响</h4><p>网络的情况是十分复杂的，所以导致网络传输的情况变得十分复杂，所以这个时间也很难去确定，所以必须采用合适的算法来确定这个时间。</p><h4 id="算法：加权平均往返时间"><a href="#算法：加权平均往返时间" class="headerlink" title="算法：加权平均往返时间"></a>算法：加权平均往返时间</h4><p><code>加权平均往返时间RTTs = （1-a）*旧的往返时间+a*新的往返时间</code></p><p>这里一开始RTT采用第一次测得的往返时间，并以此为基础进行计算。这里的a是一个系数，RFC规定是 0.125.</p><p>这样就可以不断地更新往返时间，得到网络的情况，可以更好地确定超时重传时间。</p><h4 id="超时重传时间RTO算法"><a href="#超时重传时间RTO算法" class="headerlink" title="超时重传时间RTO算法"></a>超时重传时间RTO算法</h4><p><code>RTO = RTTs+4*RTTd</code></p><p><code>RTTd = (1-b)*旧的RTTd+b*|RTTs-新的样本RTT|</code></p><ul><li>RTTd是RTT 的偏差的加权平均值，一般来说第一次取RTT的一半</li><li>b的推荐值是0.25</li><li>这个算法是根据网络波动来确定重传的时间的，如果网络稳定，则重传时间就接近往返时间，网络波动越大，则超时重传的时间约大</li></ul><h4 id="Karn算法"><a href="#Karn算法" class="headerlink" title="Karn算法"></a>Karn算法</h4><p>这里还有一个问题就是：如果重传了，然后接收到一个ack，那么这个ack是重传前的那个包的，还是重传后这个包的？很难确定对吧。所以这里就诞生了这个算法。</p><p>最初这个算法是直接丢弃重传包样本，但是这样肯定不行的，会让算法不准确。所以修正后是<code>RTO = y*旧的RTO</code>。这里的y一般是2.这样当发生重传的时候，就会把该样本的信息记录下来了。</p><h3 id="选择确认SACK"><a href="#选择确认SACK" class="headerlink" title="选择确认SACK"></a>选择确认SACK</h3><p>前面我们讲到累积确认的时候讲到：当收到错误或者漏包的时候，只会发送这个错误的包前的确认完好的ack，剩下的都要重传。例如收到12678。那么会发送确认号为3的ack，这样的话，678也要重传一次，就浪费资源了。所以我们可以告诉发送端说我已经收到了什么，只需要把缺的发送给我就行。这个时候就可以用到选择确认SACK。</p><p>上文讲头部字段的时候讲到这个选项，他的<strong>最大值是40字节</strong>。每一个确认的字段，例如上面的12678例子。12段需要一个左边界1和右边界2,678需要左边界6，右边界8.所以每个要告诉发送端的已经完好的字段都需要两个边界：<strong>左边界和右边界</strong>。一个边界需要4个字节，所以<strong>最多只能告诉接收端4个完好的字段</strong>。</p><h3 id="TCP可靠传输小结-1"><a href="#TCP可靠传输小结-1" class="headerlink" title="TCP可靠传输小结"></a>TCP可靠传输小结</h3><p>TCP通过滑动窗口以及超时重传算法来使得发送的数据变得非常可靠，效率也比较高。另外再通过选择确认SACK进一步加强了性能。这三个是需要掌握的点，特别是超时重传时间的算法和滑动窗口的原理。</p><h2 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h2><h3 id="什么是流量控制？为什么要进行流量控制？"><a href="#什么是流量控制？为什么要进行流量控制？" class="headerlink" title="什么是流量控制？为什么要进行流量控制？"></a>什么是流量控制？为什么要进行流量控制？</h3><p>流量控制这个很好理解，就是控制管道中传输的数据量。控制流量是为了不让管道发生拥塞，从而来提高效率。另一方面，如果发送端的速度太快，接收端可能会来不及接受就会导致数据的丢失。</p><h3 id="利用滑动窗口来提高效率"><a href="#利用滑动窗口来提高效率" class="headerlink" title="利用滑动窗口来提高效率"></a>利用滑动窗口来提高效率</h3><p>前面我们讲到tcp头部有一个窗口值，可以用来记录接收方还有多少的缓存。tcp主要就是利用这一点来保证有足够的缓存，而不会无法接收。当接收方的的缓存满了之后，ack’中的窗口值就是0。当接收方中的缓存多了之后，就会发送一个数据报告知发送端我有内存了，可以发送数据过来了。</p><p>这里有一个问题：如果接收端告知可以发送数据的tcp报丢失了怎么办？持续计时器。</p><p>当发送端收到窗口值为0的tcp报的时候，就会开始计时器，计时器时间到了就会发送一个试探报，数据只有一个字节。如果还是缓存满，就重新开始计算计时器。</p><h3 id="提高传输效率"><a href="#提高传输效率" class="headerlink" title="提高传输效率"></a>提高传输效率</h3><h4 id="相关机制"><a href="#相关机制" class="headerlink" title="相关机制"></a>相关机制</h4><ul><li>发送的数据长度不能太短也不能太长，参考MSS。</li><li>按照接收端的要求发送push报文</li><li>持续计时器到了，就要发送数据报，不能干等待</li></ul><h4 id="糊涂窗口综合症和Nagle算法"><a href="#糊涂窗口综合症和Nagle算法" class="headerlink" title="糊涂窗口综合症和Nagle算法"></a>糊涂窗口综合症和Nagle算法</h4><p>听起来好高大上，其实很简单。当缓存区还没有数据的时候，这个时候收到一个字节是不是就会马上发出去了？这样就不符合上面说的效率限制了。然后接收端，如果是满的，然后应用程序读取了一个字节，是不是马上就通知发送端可以发送一个字节的数据了。这样都是会让网络效率降低。所以正确的方法就是：等。等到一定长度后，再进行发送。这也就是Nagle算法。</p><h2 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h2><h4 id="拥塞原理"><a href="#拥塞原理" class="headerlink" title="拥塞原理"></a>拥塞原理</h4><h5 id="什么是拥塞？"><a href="#什么是拥塞？" class="headerlink" title="什么是拥塞？"></a>什么是拥塞？</h5><p>什么是拥塞？为什么会发生拥塞？拥塞顾名思义就是像塞车那样发生了堵塞。通道的能力是一定的，当网球传输的压力逐渐增大的时候，那么就会发生了堵塞，甚至路由器的缓冲队列满了，直接把数据报丢掉。所以这里会有一个问题：数据传输慢了好多，甚至被丢包。然后会发生什么？超时重传。然后数据报一直发送不过去，这边一直重传，就形成了恶循环。导致整个网络瘫痪。所以一定要控制好流量。</p><p>这里的流量控制和上文讲滑动窗口的时候那个流量控制有什么区别？上文讲的流量控制是为了避免数据太快以致于接收端无法及时接受数据。这里是为了避免发生拥塞而导致网络瘫痪。但是都是同样的手段：流量控制。</p><h5 id="导致拥塞的原因有什么？可以直接提高带宽解决吗？"><a href="#导致拥塞的原因有什么？可以直接提高带宽解决吗？" class="headerlink" title="导致拥塞的原因有什么？可以直接提高带宽解决吗？"></a>导致拥塞的原因有什么？可以直接提高带宽解决吗？</h5><p>拥塞控制不只是用到流量控制，导致拥塞的原因有：带宽，路由缓存，处理机处理速度等等非常多的因素。提高某个因素的能力会把瓶颈转移到其他的地方，所以能做的最重要一个就是控制流量。</p><h5 id="拥塞的指标是什么？怎么判断发生了拥塞？"><a href="#拥塞的指标是什么？怎么判断发生了拥塞？" class="headerlink" title="拥塞的指标是什么？怎么判断发生了拥塞？"></a>拥塞的指标是什么？怎么判断发生了拥塞？</h5><p>由于缺少缓存空间而被丢弃的分组的百分数；<br>平均队列长度；<br>超时重传的分组数；<br>平均分组时延；<br>分组时延的标准差，等等</p><ul><li>开环控制：在网络执行前进行预估尽量避免</li><li>闭环控制：实时监控控制</li></ul><p>减少拥塞有两种方案：一种是硬件的能力，这个只能尽量，但是提升空间小，瓶颈大，第二种就是通过算法来减少，也就是tcp要做的。</p><h4 id="tcp的拥塞控制方法"><a href="#tcp的拥塞控制方法" class="headerlink" title="tcp的拥塞控制方法"></a>tcp的拥塞控制方法</h4><p>首先来看一张图，这张图就讲了整个tcp控制拥塞的算法：</p><p><img src="https://img2020.cnblogs.com/blog/1961534/202006/1961534-20200604230417771-1636180342.png" alt=""></p><p>一共有4个点：慢开始，拥塞避免，快重传，快恢复。</p><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><p>tcp控制拥塞的算法核心就是动态窗口。上面我们讲到，发送端可以发送的最多数据报是根据接收端的缓冲区以及自身的缓冲区大小决定，但是我们不能任他无限大发送。如果每个链接都发送50g的数据岂不是得炸掉。所以这里增加了一个拥塞窗口，控制可以发送的数据数量，控制流量。</p><p>因为动态窗口需要根据情况实时调整，所以，必须得到及时的反馈，所以接收端收到数据报的时候，需要迅速把确认发送给发送端。</p><h5 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h5><p>这个算法要求当接收端发现缺少包的时候要及时反映给发送端。例如发送了1，2但是3丢了，此时继续发送4，5，6，那么接收端就要返回三个重复确认，3还没来就发4,5,6肯定是你的3丢了，赶紧重发。然后接受端收到三个重复的，就赶紧补发3过去。</p><h5 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h5><p>这里的慢开始就是一开始的窗口值要小，不能太大，然后去试探拥塞的底线。这里一般的起点是一般是发送端一个数据报可以发送的最大长度的1~2倍。然后每一个轮次，也就一个往返，就把窗口值加倍。这里的往返要注意一下，是要整个窗口中的数据全部往返一次，才算是一个轮次。例如窗口的大小是8，那么需要8的数据报都收到ack才算是一个轮次结束。</p><h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h5><p>这里有一个界限，如果一直增大下去那岂不是就指数爆炸了。所以到了一个界限：ssthresh，这个值是自己设定的。之后就是以线性慢慢增长。然后就会出现两种情况：</p><ol><li>发生超时重传</li><li>得到三个重复的ack</li></ol><p>首先看第一种情况，如果发生了超时重传，则说明很可能是发生了拥塞，那么这个时候就要迅速慢开始，把ssthresh设置当前窗口大小的1/2，然后把窗口压缩到最初的状态。重头开始。第二种情况就是快恢复了。</p><h5 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h5><p>当收到三个重复的ack的时候，只是有可能但是可能性比较小出现了拥塞，所以就把ssthresh设置为当前窗口的1/2，同时把当前窗口值设置为何ssthresh一样大。不用慢开始直接拥塞避免阶段。</p><h5 id="窗口值上限"><a href="#窗口值上限" class="headerlink" title="窗口值上限"></a>窗口值上限</h5><p>这个上限就是前面讲到的根据两端缓存区的大小来确定了。</p><h4 id="主动队列管理AQM"><a href="#主动队列管理AQM" class="headerlink" title="主动队列管理AQM"></a>主动队列管理AQM</h4><p>如果发生拥塞，那么会瞬间让整个网络的效率降低到很小的一个值，所以要尽量避免，多一点快恢复。</p><p>我们知道路由器的缓冲队列长度是有限的，当满了之后接下来的分组都会被丢弃那么，我们可以在快满的时候就通知慢点发送，快拥塞了。管理好这个队列，而不能等到发生事故了在进行处理。这就是主动队列管理。</p><h2 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h2><p>tcp是面向连接的，所以就涉及到连接的建立释放。那么连接就有状态，就涉及到有限状态机。也就是以下三个：</p><h4 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h4><img src="https://img2020.cnblogs.com/blog/1961534/202006/1961534-20200605000952368-1256869162.png" width="400"><p>这个有个很重要的概念：三次握手。</p><p>他们建立的过程类似这样：</p><ul><li>client：我要和你连接</li><li>service：好的，你真的要连接吗</li><li>client：对，我真的要</li></ul><p>然后就连接了。这个过程需要发送三个报文，也称为三报文握手。然后互相交换各自的信息例如窗口值 RTT等。相亲的互问根底不过是为了婚姻更幸福的生活不是吗（此处手动滑稽）</p><h4 id="连接释放"><a href="#连接释放" class="headerlink" title="连接释放"></a>连接释放</h4><img src="https://img2020.cnblogs.com/blog/1961534/202006/1961534-20200605000948327-1061875421.png" width="400"><p>释放的话会比较麻烦一点，毕竟闪婚容易，离婚就可能和庆兄或者祥哥一样可爱了。（哦祥哥貌似当时还没结婚）释放连接要进行4次握手：</p><ul><li>client：我不要你了我要释放连接</li><li>service：你真的不要我了吗，哼，不要就滚</li><li>service：我决定了。释放连接</li><li>client：好，拜拜。</li><li>client：等待2msl时间后完全释放连接</li></ul><p>最后一个是一个等待时间，避免受到无效的请求。因为进行了四次握手也成为四报文握手。（也有叫挥手的，挥手比较好点）这样就直接释放连接了。这里有几个点要注意：</p><ol><li>客户端请求释放，受到服务端的确认后并没有完全释放连接，而是会等待服务端的下一个回复才真正断开。但是，还不是完全断开，要再等两个最大报文生存时间，网络中完全不存在无效报文了再彻底断开。</li><li>另外等待时间也是为了最后一个报文能到达服务端，万一服务端反悔了就可以收到对吧，如果没有等待2msl，就可能下一个tcp连接收到了无效的请求。</li></ol><h4 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h4><p>通过上面的讲述可以发现tcp连接存在很多的状态。所以也就有了这个状态机。给个图你们感受一下：</p><img src="https://img2020.cnblogs.com/blog/1961534/202006/1961534-20200605000955584-1738895006.png" width="500"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章从什么是运输层，运输层的协议，到重点介绍tcp的工作原理，如何可靠传输，tcp报的格式，到更加深入的拥塞原理，流量控制提高传输效率，最后讲了tcp的连接管理。</p><p>tcp是运输层一个非常重要的协议，除了少部分使用udp，其他基本都是使用tcp，所以要对tcp的原理模清楚。另外要懂得tcp的效率问题以及出错的拥塞问题连接问题。</p><p>运输层是直接和我们应用层打交道的，所以了解清楚运输层是有必要的。当我们需要建立一些socket连接的时候，就必须对运输层有一定的了解。</p><p>好了关于运输层就大概讲这么多，希望可以给你们有一些帮助。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机网络-–-运输层&quot;&gt;&lt;a href=&quot;#计算机网络-–-运输层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络 – 运输层&quot;&gt;&lt;/a&gt;计算机网络 – 运输层&lt;/h1&gt;&lt;h2 id=&quot;运输层协议概述&quot;&gt;&lt;a href=&quot;#运输层协议概述&quot; c
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://musiczh.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://musiczh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="运输层" scheme="https://musiczh.github.io/tags/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>算法：新21点</title>
    <link href="https://musiczh.github.io/2020/06/03/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%96%B021%E7%82%B9/"/>
    <id>https://musiczh.github.io/2020/06/03/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%96%B021%E7%82%B9/</id>
    <published>2020-06-03T06:30:00.000Z</published>
    <updated>2020-06-03T06:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：新21点"><a href="#题目：新21点" class="headerlink" title="题目：新21点"></a>题目：新21点</h3><p>爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：</p><p>爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。</p><p>当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：N &#x3D; 10, K &#x3D; 1, W &#x3D; 10</span><br><span class="line">输出：1.00000</span><br><span class="line">说明：爱丽丝得到一张卡，然后停止。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：N &#x3D; 6, K &#x3D; 1, W &#x3D; 10</span><br><span class="line">输出：0.60000</span><br><span class="line">说明：爱丽丝得到一张卡，然后停止。</span><br><span class="line">在 W &#x3D; 10 的 6 种可能下，她的得分不超过 N &#x3D; 6 分。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：N &#x3D; 21, K &#x3D; 17, W &#x3D; 10</span><br><span class="line">输出：0.73278</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;&#x3D; K &lt;&#x3D; N &lt;&#x3D; 10000</span><br><span class="line">1 &lt;&#x3D; W &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure><p>如果答案与正确答案的误差不超过 10^-5，则该答案将被视为正确答案通过。<br>此问题的判断限制时间已经减少。</p><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/new-21-game" target="_blank" rel="noopener">https://leetcode-cn.com/problems/new-21-game</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>详细题解可前往上述力扣官网查看。此处我讲解我做题的思路和一些个人总结等</p></blockquote><p>首先要做的就是理解题意，知道难点在哪。我当时做这道题，就是因为不理解题意。我们可以使用暴力推算来一步步看具体计算逻辑，再进行化简。<strong>暴力算法不是没用，他是一切优化算法的基石</strong>。</p><p>拿一个例子：k=5，n=7，w=,4。</p><ol><li>首先要理解这个游戏是怎么玩的，我们可以一直抽牌，牌的大小在[1,w]，如果手上的点数不超过k，那么必须继续抽，如果超过了，就停下来。然后看看手上的点数此时是否超过了n。（默认每次抽到任何点数的概率相同）</li><li>算概率，我们先算样本空间。最大值是k-1+w。因为k的话已经满足了，那么当手上的点数是k-1且抽到最大点数的牌w，那么就是<code>k-1+w</code>。最小值毋庸置疑就是<code>k</code>了。</li><li>这样基本上我们就了解整个题意了。然后看看怎么暴力解决它。大于k的时候已经没办法抽了，所以我们考虑小于k的情况。当手上的点数是k-1时，那么可能的结果就是[k,k-1+w]，且每个结果概率相等。然后求小于n的概率，那是不是很容易就可以求出来了。古典概率模型嘛。例如上面的例子，当手上的点数是4的时候，那么小于等于8就只有5,6,7；剩下的8，就不行了，所以概率是0.75.来我们继续。也就是从4出发的话，概率是0.75.那我们看看从3出发，概率是多少。</li><li>从3出发可能的范围是[4,8]，然后4的概率我们已经知道了是0.75，然后5,6,7,8都是小于n的，那么3出发的概率就是0.75<em>0.25+0.75。是不是已经发现什么了？只要这样一直往前推，推导第一位那答案不是就出来了？而且每一个答案都和前面的答案有关？是不是闻到了一股熟悉的味道？对就是*</em>动态规划**</li><li>按照上面的思路我们只需要一步步往前推。接下来是我们要确定状态转移方程。从上面我们可以发现 P(3) = 1/4 * P(4) + 3/4 * [P(4)-P(3+4)] 。然后把里面一些数字用循环的i变量和参数代替就可以了。</li></ol><p>个人思考：一定要先理解题意然后用暴力解法思考一下，不要一开始就想着套用什么模板。暴力解法之后才知道题目的本质是什么，然后用什么方法可以简化。然后再运用动态规划，滑动窗口等等方法去解决。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">new21Game</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (K == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span>[] dp = <span class="keyword">new</span> <span class="keyword">double</span>[K + W];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = K; i &lt;= N &amp;&amp; i &lt; K + W; i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[K - <span class="number">1</span>] = <span class="number">1.0</span> * Math.min(N - K + <span class="number">1</span>, W) / W;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = K - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp[i] = dp[i + <span class="number">1</span>] - (dp[i + W + <span class="number">1</span>] - dp[i + <span class="number">1</span>]) / W;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ol><li>时间复杂度：只需要遍历数组。长度是k+w，当时当n小于k+w的时候只需要遍历到n就行，剩下都是0.</li></ol><blockquote><p>时间复杂度：O(min（n，k+w)）</p></blockquote><ol start="2"><li>空间复杂度：只需要一个数组</li></ol><blockquote><p>空间复杂度：O(k+w)</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：新21点&quot;&gt;&lt;a href=&quot;#题目：新21点&quot; class=&quot;headerlink&quot; title=&quot;题目：新21点&quot;&gt;&lt;/a&gt;题目：新21点&lt;/h3&gt;&lt;p&gt;爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：&lt;/p&gt;
&lt;p&gt;爱丽丝以 0 分开
      
    
    </summary>
    
    
      <category term="算法" scheme="https://musiczh.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://musiczh.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://musiczh.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>算法：求1+2+..+n</title>
    <link href="https://musiczh.github.io/2020/06/02/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%B1%821+2+..+n/"/>
    <id>https://musiczh.github.io/2020/06/02/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%B1%821+2+..+n/</id>
    <published>2020-06-02T06:30:00.000Z</published>
    <updated>2020-06-02T06:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：求1-2-n"><a href="#题目：求1-2-n" class="headerlink" title="题目：求1+2+..+n"></a>题目：求1+2+..+n</h3><p>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: n &#x3D; 3</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">限制：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/qiu-12n-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/qiu-12n-lcof</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这道题如果你有什么大胆的想法，直接做就是了（手动滑稽）。</p><p>先来分析一下，首先拿到这道题，第一反应就是我们熟悉的数学公式 <code>(n+1)n/2</code>。但是这里需要用到乘法和除法，不满足题干。那么接下来分析一下我们还有什么运算符可以用：</p><p>加减法，赋值，位运算，逻辑运算。</p><p>看到位运算是不是眼前一亮。运算可以取代加减乘除，本质上加减乘除也是用位运算来实现的。所以，怎么用位运算实现乘法和除法？</p><p>除法是二的指数就很简单了，直接移位就行了。非二的倍数就比较复杂，这里先不讨论。</p><p>乘法的话，看乘数化为二进制的每一位是不是1.如果是1则被乘数向左移动该位的位置数（第一位默认是0）。例如：2*3: = 010 * 011：</p><ol><li>3的第一位是1，那么结果加上010向左移动0位，即010</li><li>3的第二位是1，那么结果加上010向左移动1位，即010+100=110</li><li>3的第三位是0，结果保持不变，最终是110 即6.</li></ol><p>这样就可以得到答案了。</p><p>但是我们给出的n的大小不确定，又不能用循环判断，那怎么去不断累加呢？</p><p>注意限制条件：1&lt;=n&lt;=10000 。n不会超过·10000，也就是n的二进制位数不会超过14，所以弄14层代替循环即可。没错就是这么暴力。</p><blockquote><p>这道不同编程语言的逻辑运算可参与的数据类型不同。c/c++中可以用整数来进行逻辑运算，但是java等面向对象的语言是不可以的。要注意这点。</p></blockquote><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, A = n, B = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ol><li>时间复杂度：只需要遍历n的二进制位数</li></ol><blockquote><p>时间复杂度：O(logn)</p></blockquote><ol start="2"><li>空间复杂度：只需要额外的常量空间</li></ol><blockquote><p>空间复杂度：O(1)</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：求1-2-n&quot;&gt;&lt;a href=&quot;#题目：求1-2-n&quot; class=&quot;headerlink&quot; title=&quot;题目：求1+2+..+n&quot;&gt;&lt;/a&gt;题目：求1+2+..+n&lt;/h3&gt;&lt;p&gt;求 1+2+…+n ，要求不能使用乘除法、for、while、if、el
      
    
    </summary>
    
    
      <category term="算法" scheme="https://musiczh.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://musiczh.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="位运算" scheme="https://musiczh.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>算法：拥有最多糖果的孩子</title>
    <link href="https://musiczh.github.io/2020/06/01/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90/"/>
    <id>https://musiczh.github.io/2020/06/01/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90/</id>
    <published>2020-06-01T06:30:00.000Z</published>
    <updated>2020-06-01T06:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：拥有最多糖果的孩子"><a href="#题目：拥有最多糖果的孩子" class="headerlink" title="题目：拥有最多糖果的孩子"></a>题目：拥有最多糖果的孩子</h3><p>给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。</p><p>对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 ：</span><br><span class="line"></span><br><span class="line">输入：candies &#x3D; [2,3,5,1,3], extraCandies &#x3D; 3</span><br><span class="line">输出：[true,true,true,false,true] </span><br><span class="line">解释：</span><br><span class="line">孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。</span><br><span class="line">孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。</span><br><span class="line">孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。</span><br><span class="line">孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。</span><br><span class="line">孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。</span><br></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>六一儿童节快乐呀。今天做的算法题也轻松一下。思路很简单，找到糖果最多的那个小朋友，然后再依次把多余的糖果分配给每一个小朋友，看他们的手上的糖果是否大于等于最大的那个。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Boolean&gt; <span class="title">kidsWithCandies</span><span class="params">(<span class="keyword">int</span>[] candies, <span class="keyword">int</span> extraCandies)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = candies.length;</span><br><span class="line">       <span class="keyword">int</span> maxCandies = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">           maxCandies = Math.max(maxCandies, candies[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;Boolean&gt; ret = <span class="keyword">new</span> ArrayList&lt;Boolean&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">           ret.add(candies[i] + extraCandies &gt;= maxCandies);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>假设一共有n个孩子</p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><ol><li>时间复杂度：遍历两次数组</li></ol><blockquote><p>时间复杂度：O(n)</p></blockquote><ol start="2"><li>空间复杂度：只需要额外的常量空间</li></ol><blockquote><p>空间复杂度：O(1)</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：拥有最多糖果的孩子&quot;&gt;&lt;a href=&quot;#题目：拥有最多糖果的孩子&quot; class=&quot;headerlink&quot; title=&quot;题目：拥有最多糖果的孩子&quot;&gt;&lt;/a&gt;题目：拥有最多糖果的孩子&lt;/h3&gt;&lt;p&gt;给你一个数组 candies 和一个整数 extraCand
      
    
    </summary>
    
    
      <category term="算法" scheme="https://musiczh.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://musiczh.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法：判断对称二叉树</title>
    <link href="https://musiczh.github.io/2020/05/31/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%A4%E6%96%AD%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://musiczh.github.io/2020/05/31/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%A4%E6%96%AD%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-05-31T06:30:00.000Z</published>
    <updated>2020-05-31T06:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：判断对称二叉树"><a href="#题目：判断对称二叉树" class="headerlink" title="题目：判断对称二叉树"></a>题目：判断对称二叉树</h3><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [2,1,5,6,2,3]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/symmetric-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/symmetric-tree</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>说实话这道题我想了挺久的，可能太久没接触过二叉树了。</p><p>比较容易得到的思路是是递归。根节点下的左右两棵树在一个方法内分别 进行先序递归遍历，但是不同的是，一个是从左边开始的先序遍历，一个是从右边开始的先序遍历。然后依次判断元素是否相同即可。</p><p>另外也可以使用迭代的方式，因为是先序遍历，先遍历到先判断，所以这里可以使用一个特点相同的队列数据结构来辅助迭代。每次取出来两个元素，然后按照一左一右把元素放进去即可。（参考代码即可理解）</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">     TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> getBoolean(root.left,root.right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(TreeNode nodeL, TreeNode nodeR)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nodeL == <span class="keyword">null</span> &amp;&amp; nodeR == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (nodeL == <span class="keyword">null</span> || nodeR == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (nodeL.val != nodeR.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> getBoolean(nodeL.left,nodeR.right) &amp;&amp; getBoolean(nodeL.right,nodeR.left);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> check(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode u, TreeNode v)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        q.offer(u);</span><br><span class="line">        q.offer(v);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            u = q.poll();</span><br><span class="line">            v = q.poll();</span><br><span class="line">            <span class="keyword">if</span> (u == <span class="keyword">null</span> &amp;&amp; v == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((u == <span class="keyword">null</span> || v == <span class="keyword">null</span>) || (u.val != v.val)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            q.offer(u.left);</span><br><span class="line">            q.offer(v.right);</span><br><span class="line"></span><br><span class="line">            q.offer(u.right);</span><br><span class="line">            q.offer(v.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>假设二叉树的元素个数为n</p><h4 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h4><ol><li>时间复杂度：每个元素都需要遍历一次</li></ol><blockquote><p>时间复杂度：O(n)</p></blockquote><ol start="2"><li>空间复杂度：栈的个数不会超过元素个数</li></ol><blockquote><p>空间复杂度：O(n)</p></blockquote><h4 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h4><ol><li>时间复杂度：每个元素都需要遍历一次</li></ol><blockquote><p>时间复杂度：O(n)</p></blockquote><ol start="2"><li>空间复杂度：队列的长度不会超过n</li></ol><blockquote><p>空间复杂度：O(n)</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：判断对称二叉树&quot;&gt;&lt;a href=&quot;#题目：判断对称二叉树&quot; class=&quot;headerlink&quot; title=&quot;题目：判断对称二叉树&quot;&gt;&lt;/a&gt;题目：判断对称二叉树&lt;/h3&gt;&lt;p&gt;给定一个二叉树，检查它是否是镜像对称的。&lt;/p&gt;
&lt;p&gt;例如，二叉树 [1,
      
    
    </summary>
    
    
      <category term="算法" scheme="https://musiczh.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://musiczh.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://musiczh.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>算法：柱状图中最大的矩形</title>
    <link href="https://musiczh.github.io/2020/05/29/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
    <id>https://musiczh.github.io/2020/05/29/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</id>
    <published>2020-05-29T09:30:00.000Z</published>
    <updated>2020-05-29T09:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：柱状图中最大的矩形"><a href="#题目：柱状图中最大的矩形" class="headerlink" title="题目：柱状图中最大的矩形"></a>题目：柱状图中最大的矩形</h3><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="https://img2020.cnblogs.com/blog/1961534/202005/1961534-20200530184957296-77413922.png" alt=""></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p><p><img src="https://img2020.cnblogs.com/blog/1961534/202005/1961534-20200530184958716-2094348161.png" alt=""></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [2,1,5,6,2,3]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram" target="_blank" rel="noopener">https://leetcode-cn.com/problems/largest-rectangle-in-histogram</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>拿到这道题，先不要想其他的方法，看看暴力解法能不能算出来。我们会发现暴力算法有两个方案：一个是变化矩形的范围，然后求出范围中的最低柱子，就可以得到面积了。第二个是每个柱子分别向前后扩散，遇到比自己低的就停下来，那么这个范围的宽度乘上自身的高度，就是该位置的柱子可以达到的最大面积。（第二种我当时没想出来==）</p><p>然后我们从暴力算法中，看看有没有可以进行优化的地方。首先两种思路，第一种的话因为已经固定了两层嵌套循环，要去优化的话显然有点困难。第二种的思路只有一个外层循环，所以优化的空间可能会比较大，我们从第二种入手。</p><p>首先我们知道，第二种思路最费时间的点就是每次都要前后去寻找，那我们这里可以去想一下怎么把前面遍历的情况记录下来，节省时间。所以难点就是在确定边界。</p><p>重要特点：这里我们分析边界的特点。如果i &lt; j ,且heights[i] &gt; heights[j] ,这样的话，对于任何 j &lt; k,第K个元素的左边界不可能是i。因为被 j 挡住了。这个应该很好理解吧。可以的话我们继续。</p><p>首先我们进行遍历数组，看什么时候可以确定边界。假设现在有[2,4,1,5,7,3]。（大家可以自行画图体验，我这里就不画图了，懒癌犯了）</p><ol><li>遍历到2的时候，已经确定好左边界，但是还没有确定右边界；</li><li>遍历4，同二。</li><li>遍历1，这个时候我们会发现，第二个元素4，已经确定好边界了，可以得出面积4.</li><li>然后可以发现第一个元素2，也得到他的边界了。</li><li>然后我们会发现，位置1 比前面的任何元素都要小，那么后面的元素，不可能以2,4为左边界。原因看上面。</li><li>然后同理继续遍历5，和7.然后遍历到3的时候，元素 7 也确定边界了。元素5也确定边界了。</li><li>后面已经没有元素了，所以3也可以确定边界。最后再确定1的边界。</li></ol><p>观察上面的流程，有没有一丝丝什么的味道？栈的味道。遍历可以看做是入栈，确定边界的时候，可以看成出栈。先进后出。那么可不可以用一个辅助栈来完成这个流程呢？答案是肯定的。</p><p>思路和上面一模一样，重点是入栈和出栈。从上面的重要特点可以知道，当遇到比较小的元素的时候，那么前面的元素就可以确定边界了，进行出栈操作。所以栈底，永远是前面的最小元素。</p><ol><li>当遍历到的元素比栈顶要小的时候，那么就可以对栈顶元素进行出栈</li><li>这个矩形的高度是栈顶元素的高度，宽度是当前遍历到的元素的 下标 i - 栈顶元素的下一个元素的下标 j + 1.为什么是这样？大家可以画个图模拟一下，就留给大家思考了。</li><li>遍历完成后，再对栈里的元素进行出栈操作。</li><li>过程中记录最大的矩形面积。</li></ol><p>这里建议大家画图去模拟这个过程，会很好去理解，特别是关于矩形的边界的确定，如果没有画图，很容易就漏掉一些细节的考虑。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (heights.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;heights.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (heights[i]&gt;=heights[stack.peek()]) stack.push(i);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[i]&lt;heights[stack.peek()] )&#123;</span><br><span class="line">                <span class="keyword">int</span> index = stack.pop();</span><br><span class="line">                <span class="keyword">int</span> area;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty())&#123;</span><br><span class="line">                    area = i*heights[index];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    area = (i-stack.peek()-<span class="number">1</span>)*heights[index];</span><br><span class="line">                &#125;</span><br><span class="line">                maxArea = Math.max(maxArea, area);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> index = stack.pop();</span><br><span class="line">        <span class="keyword">int</span> area;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty())&#123;</span><br><span class="line">            area = heights.length*heights[index];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            area = (heights.length-stack.peek()-<span class="number">1</span>)*heights[index];</span><br><span class="line">        &#125;</span><br><span class="line">        maxArea = Math.max(area,maxArea);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>假设数组的长度为n</p><ol><li>时间复杂度：首先需要遍历一次数组，每个元素至多进行一次出栈和入栈操作。</li></ol><blockquote><p>时间复杂度：O(n)</p></blockquote><ol start="2"><li>空间复杂度：这里所需要的空间是栈。最多是数组的长度。</li></ol><blockquote><p>空间复杂度：O(n)</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：柱状图中最大的矩形&quot;&gt;&lt;a href=&quot;#题目：柱状图中最大的矩形&quot; class=&quot;headerlink&quot; title=&quot;题目：柱状图中最大的矩形&quot;&gt;&lt;/a&gt;题目：柱状图中最大的矩形&lt;/h3&gt;&lt;p&gt;给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱
      
    
    </summary>
    
    
      <category term="算法" scheme="https://musiczh.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://musiczh.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="辅助栈" scheme="https://musiczh.github.io/tags/%E8%BE%85%E5%8A%A9%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>算法：字符串解码</title>
    <link href="https://musiczh.github.io/2020/05/29/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"/>
    <id>https://musiczh.github.io/2020/05/29/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</id>
    <published>2020-05-29T09:30:00.000Z</published>
    <updated>2020-05-29T09:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：字符串解码"><a href="#题目：字符串解码" class="headerlink" title="题目：字符串解码"></a>题目：字符串解码</h3><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">s &#x3D; &quot;3[a]2[bc]&quot;, 返回 &quot;aaabcbc&quot;.</span><br><span class="line">s &#x3D; &quot;3[a2[c]]&quot;, 返回 &quot;accaccacc&quot;.</span><br><span class="line">s &#x3D; &quot;2[abc]3[cd]ef&quot;, 返回 &quot;abcabccdcdcdef&quot;.</span><br></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/decode-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/decode-string</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>首先讲一下我拿到这道题的思路：递归。每一歌中括号可以是一层，然后递归返回中括号中的字符串，和外层的数字进行循环重复后继续下一个中括号。例如：<code>2[4[ab]]3[b]</code></p><ol><li>先得到2，然后递归进入第一个中括号</li><li>得到4，递归进入</li><li>得到ab，遇到<code>]</code>返回上一层</li><li>ab进行4次重复，遇到<code>]</code>返回上一层</li><li>把得到的字符串进行2次重复。然后继续下一组。</li></ol><p>思路应该是挺清晰的。但是这里有几个问题：在第五步的时候怎么确定下一组开始的位置？每一步递归，怎么确认开始的位置？我当时就卡在第一个问题，不知道如何解决。</p><p>对于第二个问题，很简单，重新写一个方法来递归，然后加入position参数即可。第一个问题有两个思路：</p><ol><li>全局变量</li><li>在返回参数中加入</li></ol><p>我比较喜欢第二种。因为全局变量就破坏了封装，我觉得不可取。但是返回参数，不是字符串吗，怎么附带位置信息？这里有个很好的解决方案：字符串数组。返回的字符串数组中一个保存得到的字符串，一个是数字字符串，再进行转换就可以得到位置信息了。思路到此应该就差不多了。另外的实现细节可以自己补充。</p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>有递归，那么和递归一样思路的是什么？没错就是栈，那么我们可以使用一个辅助栈解决这个问题。思路和递归是差不多的：</p><ol><li>遍历字符串数组并把字符放进栈。</li><li>当遍历到<code>]</code>时进行回溯，把中距离栈顶第一个<code>[</code>前的字符串拿出来</li><li>然后再遍历数字，遇到栈底或者<code>]</code>停止</li><li>然后进行循环运算后把字符串放进栈中</li><li>最后返回栈中的字符串</li></ol><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">decodeString</span><span class="params">(s: <span class="type">String</span>)</span></span>: String&#123;</span><br><span class="line">    <span class="keyword">return</span> getStrings(s,<span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStrings</span><span class="params">(s:<span class="type">String</span>,i:<span class="type">Int</span>)</span></span>:StringArray&#123;</span><br><span class="line">    <span class="keyword">val</span> stringBuilder = StringBuilder()</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> position = i</span><br><span class="line">    <span class="keyword">while</span> (position&lt;s.length)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s[position] <span class="keyword">in</span> <span class="string">'a'</span>..<span class="string">'z'</span> || s[position] <span class="keyword">in</span> <span class="string">'A'</span>..<span class="string">'Z'</span>)&#123;</span><br><span class="line">            stringBuilder.append(s[position])</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s[position] <span class="keyword">in</span> <span class="string">'0'</span>..<span class="string">'9'</span>)&#123;</span><br><span class="line">            num = num*<span class="number">10</span> + s[position].toInt()-<span class="number">48</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s[position]==<span class="string">'['</span>)&#123;</span><br><span class="line">            <span class="keyword">val</span> stringArray = getStrings(s,position+<span class="number">1</span>)</span><br><span class="line">            position = stringArray[<span class="number">1</span>].toInt()</span><br><span class="line">            <span class="keyword">while</span> (num!=<span class="number">0</span>)&#123;</span><br><span class="line">                stringBuilder.append(stringArray[<span class="number">0</span>])</span><br><span class="line">                num--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s[position]==<span class="string">']'</span>)&#123;</span><br><span class="line">            <span class="keyword">val</span> stringArray = StringArray()</span><br><span class="line">            stringArray.add(stringBuilder.toString())</span><br><span class="line">            stringArray.add(position.toString())</span><br><span class="line">            <span class="keyword">return</span> stringArray</span><br><span class="line">        &#125;</span><br><span class="line">        position++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> stringArray = StringArray()</span><br><span class="line">    stringArray.add(stringBuilder.toString())</span><br><span class="line">    stringArray.add(position.toString())</span><br><span class="line">    <span class="keyword">return</span> stringArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">decodeString</span><span class="params">(s: <span class="type">String</span>)</span></span>: String&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.isEmpty()) <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    <span class="keyword">val</span> stack = Stack&lt;<span class="built_in">Char</span>&gt;()</span><br><span class="line">    <span class="keyword">for</span> (c <span class="keyword">in</span> s)&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">']'</span>)&#123;</span><br><span class="line">            <span class="keyword">val</span> stringBuilder = StringBuilder()</span><br><span class="line">            <span class="keyword">while</span> (stack.peek()!=<span class="string">'['</span>)&#123;</span><br><span class="line">                stringBuilder.append(stack.pop())</span><br><span class="line">            &#125;</span><br><span class="line">            stack.pop()</span><br><span class="line">            <span class="keyword">val</span> string = stringBuilder.reverse().toString()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (stack.isNotEmpty() &amp;&amp; stack.peek()&gt;=<span class="string">'0'</span> &amp;&amp; stack.peek()&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                <span class="keyword">val</span> topNum = stack.pop().toInt()-<span class="number">48</span></span><br><span class="line">                <span class="keyword">val</span> p = <span class="number">10</span>.toDouble().pow(i)</span><br><span class="line">                num += topNum*p.toInt()</span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span>..num)&#123;</span><br><span class="line">                stack.addAll(string.toList())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> stack.add(c)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line">    <span class="keyword">while</span> (stack.isNotEmpty())&#123;</span><br><span class="line">        sb.append(stack.pop())</span><br><span class="line">    &#125;</span><br><span class="line">    sb.reverse()</span><br><span class="line">    <span class="keyword">return</span> sb.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>假如最终的字符串长度为n，原字符串的长度为k</p><h4 id="方法一-2"><a href="#方法一-2" class="headerlink" title="方法一"></a>方法一</h4><ol><li>时间复杂度：遍历原字符串，还需要把新字符一个个拼进来。</li></ol><blockquote><p>时间复杂度：O(n+k)</p></blockquote><ol start="2"><li>空间复杂度：这里所需要的空间是递归栈的深度，最坏情况下为k</li></ol><blockquote><p>空间复杂度：O(k)</p></blockquote><h4 id="方法二-2"><a href="#方法二-2" class="headerlink" title="方法二"></a>方法二</h4><ol><li>时间复杂度：除了遍历一次原字符串，还要把每个字符都放进栈中所以是</li></ol><blockquote><p>时间复杂度：O(n+k)</p></blockquote><ol start="2"><li>空间复杂度：需要一个栈来保存数据，栈的长度为字符串的长度</li></ol><blockquote><p>空间复杂度：O(n)</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：字符串解码&quot;&gt;&lt;a href=&quot;#题目：字符串解码&quot; class=&quot;headerlink&quot; title=&quot;题目：字符串解码&quot;&gt;&lt;/a&gt;题目：字符串解码&lt;/h3&gt;&lt;p&gt;给定一个经过编码的字符串，返回它解码后的字符串。&lt;/p&gt;
&lt;p&gt;编码规则为: k[encod
      
    
    </summary>
    
    
      <category term="算法" scheme="https://musiczh.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://musiczh.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法：和可被k整除的子数组数目</title>
    <link href="https://musiczh.github.io/2020/05/27/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%92%8C%E4%B8%BAK%E7%9A%84%E6%A8%A1%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/"/>
    <id>https://musiczh.github.io/2020/05/27/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%92%8C%E4%B8%BAK%E7%9A%84%E6%A8%A1%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/</id>
    <published>2020-05-27T09:30:00.000Z</published>
    <updated>2020-05-27T09:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：和可被k整除的子数组数目"><a href="#题目：和可被k整除的子数组数目" class="headerlink" title="题目：和可被k整除的子数组数目"></a>题目：和可被k整除的子数组数目</h3><p>给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; [4,5,0,-2,-3,1], K &#x3D; 5</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">有 7 个子数组满足其元素之和可被 K &#x3D; 5 整除：</span><br><span class="line">[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; A.length &lt;&#x3D; 30000</span><br><span class="line">-10000 &lt;&#x3D; A[i] &lt;&#x3D; 10000</span><br><span class="line">2 &lt;&#x3D; K &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/subarray-sums-divisible-by-k" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subarray-sums-divisible-by-k</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这道题的思路重点在前缀和+同余定理。</p><p>拿到这道题的时候我一直在想着一个子数组如果符合条件的话，怎样推出他周边的子数组是否符合条件？想了半天还是只有O（N^2）的思路。这里就要用到这个同余定理。</p><p>同余定理：当一个数组，当从0到x-1位置所有数加起来取K的模，和0到Y位置所有数加起来取K的模相等，那么X到Y所有数加起来满足被K整除。这个定理很好证明，这里就不证明了。</p><p>所以我们就顺然想到了前缀和。我们可以统计该数组中所有的前缀和，那么就可以得到满足的子数组数目了。</p><p>这里的实现思路是在遍历的时候维护一个hashMap，记录每种余数的前缀和有多少个。然后当遍历到i位置的时候，假如当前位置的前缀和取K的模是 M，那么查询hashMap，M对应的数目有多少个，那么就有多少个符合条件的数组了。</p><p>注意：这里因为和可能为负数，取模后可能出现负数，所以要进行矫正。不是简单的取绝对值，因为假如模是6,-2实际上等于4而不是2。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">subarraysDivByK</span><span class="params">(A: <span class="type">IntArray</span>?, K: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> hashMap = HashMap&lt;<span class="built_in">Int</span>,<span class="built_in">Int</span>&gt;()</span><br><span class="line">    hashMap[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (elem <span class="keyword">in</span> A!!)&#123;</span><br><span class="line">        sum += elem</span><br><span class="line">        <span class="keyword">val</span> remainder = (sum % K+K)%K</span><br><span class="line">        println(remainder)</span><br><span class="line">        <span class="keyword">val</span> indexNum = hashMap.getOrDefault(remainder,<span class="number">0</span>)</span><br><span class="line">        num += indexNum</span><br><span class="line">        hashMap[remainder] = indexNum+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>遍历一次数组</p><ul><li>时间复杂度：O(n)</li></ul><h5 id="空件复杂度"><a href="#空件复杂度" class="headerlink" title="空件复杂度"></a>空件复杂度</h5><p>维护一个哈希表。长度是Max（K，A.size）</p><ul><li>O(Max（K，A.size）)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：和可被k整除的子数组数目&quot;&gt;&lt;a href=&quot;#题目：和可被k整除的子数组数目&quot; class=&quot;headerlink&quot; title=&quot;题目：和可被k整除的子数组数目&quot;&gt;&lt;/a&gt;题目：和可被k整除的子数组数目&lt;/h3&gt;&lt;p&gt;给定一个整数数组 A，返回其中元素之
      
    
    </summary>
    
    
      <category term="算法" scheme="https://musiczh.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://musiczh.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="前缀和" scheme="https://musiczh.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>算法：删除链表节点</title>
    <link href="https://musiczh.github.io/2020/05/24/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9/"/>
    <id>https://musiczh.github.io/2020/05/24/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9/</id>
    <published>2020-05-24T11:30:00.000Z</published>
    <updated>2020-05-24T11:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：删除链表节点"><a href="#题目：删除链表节点" class="headerlink" title="题目：删除链表节点"></a>题目：删除链表节点</h3><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 来源：力扣（LeetCode）</span><br><span class="line">&gt; 链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;shan-chu-lian-biao-de-jie-dian-lcof</span><br><span class="line"></span><br><span class="line">### 分析</span><br><span class="line"></span><br><span class="line">思路非常简单，找到那个节点，然后把前面的节点指向该节点的next就可以。注意c&#x2F;c++要释放内存。</span><br><span class="line"></span><br><span class="line">### 解答</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;kotlin</span><br><span class="line">fun deleteNode(head: ListNode?, &#96;val&#96;: Int): ListNode? &#123;</span><br><span class="line">    if (head?.next &#x3D;&#x3D; null) return head</span><br><span class="line">    if (head.&#96;val&#96;&#x3D;&#x3D;&#96;val&#96;) return head.next</span><br><span class="line">    var current &#x3D; head.next</span><br><span class="line">    var previous &#x3D; head</span><br><span class="line">    while (current!&#x3D;null)&#123;</span><br><span class="line">        if (current.&#96;val&#96;&#x3D;&#x3D; &#96;val&#96;) previous?.next &#x3D; current.next</span><br><span class="line">        previous &#x3D; current</span><br><span class="line">        current &#x3D; current.next</span><br><span class="line">    &#125;</span><br><span class="line">    return head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>遍历一次链表</p><ul><li>时间复杂度：O(n)</li></ul><h5 id="空件复杂度"><a href="#空件复杂度" class="headerlink" title="空件复杂度"></a>空件复杂度</h5><p>常量空间</p><ul><li>空间复杂度：O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：删除链表节点&quot;&gt;&lt;a href=&quot;#题目：删除链表节点&quot; class=&quot;headerlink&quot; title=&quot;题目：删除链表节点&quot;&gt;&lt;/a&gt;题目：删除链表节点&lt;/h3&gt;&lt;p&gt;给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="算法" scheme="https://musiczh.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://musiczh.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="https://musiczh.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>算法：旋转链表</title>
    <link href="https://musiczh.github.io/2020/05/24/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>https://musiczh.github.io/2020/05/24/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2020-05-24T10:30:00.000Z</published>
    <updated>2020-05-24T10:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：旋转链表"><a href="#题目：旋转链表" class="headerlink" title="题目：旋转链表"></a>题目：旋转链表</h3><p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k &#x3D; 2</span><br><span class="line">输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br><span class="line">向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 来源：力扣（LeetCode）</span><br><span class="line">&gt; 链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;rotate-list</span><br><span class="line"></span><br><span class="line">### 分析</span><br><span class="line"></span><br><span class="line">这道题很简单。首先让链表变成环，然后看哪个是头节点，把上个节点的next指针变成null，返回该头节点即可。怎么找到头节点呢？用链表的长度-用k取链表长度模，就是头节点了。</span><br><span class="line"></span><br><span class="line">### 解答</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;kotlin</span><br><span class="line">fun rotateRight(head: ListNode?, k: Int): ListNode? &#123;</span><br><span class="line">    if (head?.next &#x3D;&#x3D; null) return head</span><br><span class="line"></span><br><span class="line">    var num &#x3D; 0</span><br><span class="line">    var current &#x3D; head</span><br><span class="line">    var previous : ListNode? &#x3D; head</span><br><span class="line">    while (previous?.next!&#x3D;null)&#123;</span><br><span class="line">        num++</span><br><span class="line">        previous &#x3D; previous.next</span><br><span class="line">    &#125;</span><br><span class="line">    num++</span><br><span class="line">    previous?.next &#x3D; current</span><br><span class="line">    val step &#x3D; num-k%num</span><br><span class="line">    for (i in 1..step)&#123;</span><br><span class="line">        previous &#x3D; current</span><br><span class="line">        current &#x3D; current?.next</span><br><span class="line">    &#125;</span><br><span class="line">    previous?.next &#x3D; null</span><br><span class="line">    return current</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>遍历一次链表</p><ul><li>时间复杂度：O(n)</li></ul><h5 id="空件复杂度"><a href="#空件复杂度" class="headerlink" title="空件复杂度"></a>空件复杂度</h5><p>常量空间</p><ul><li>空间复杂度：O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：旋转链表&quot;&gt;&lt;a href=&quot;#题目：旋转链表&quot; class=&quot;headerlink&quot; title=&quot;题目：旋转链表&quot;&gt;&lt;/a&gt;题目：旋转链表&lt;/h3&gt;&lt;p&gt;给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。&lt;/p&gt;
&lt;p&gt;示例
      
    
    </summary>
    
    
      <category term="算法" scheme="https://musiczh.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://musiczh.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="https://musiczh.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
</feed>
