<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HuanBlog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-02T06:30:00.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zhegnhuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法：求1+2+..+n</title>
    <link href="http://yoursite.com/2020/06/02/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%B1%821+2+..+n/"/>
    <id>http://yoursite.com/2020/06/02/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%B1%821+2+..+n/</id>
    <published>2020-06-02T06:30:00.000Z</published>
    <updated>2020-06-02T06:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：求1-2-n"><a href="#题目：求1-2-n" class="headerlink" title="题目：求1+2+..+n"></a>题目：求1+2+..+n</h3><p>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><pre><code class="hljs plain">示例 1：输入: n &#x3D; 3输出: 6</code></pre><pre><code class="hljs plain">限制：1 &lt;&#x3D; n &lt;&#x3D; 10000</code></pre><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/qiu-12n-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/qiu-12n-lcof</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这道题如果你有什么大胆的想法，直接做就是了（手动滑稽）。</p><p>先来分析一下，首先拿到这道题，第一反应就是我们熟悉的数学公式 <code>(n+1)n/2</code>。但是这里需要用到乘法和除法，不满足题干。那么接下来分析一下我们还有什么运算符可以用：</p><p>加减法，赋值，位运算，逻辑运算。</p><p>看到位运算是不是眼前一亮。运算可以取代加减乘除，本质上加减乘除也是用位运算来实现的。所以，怎么用位运算实现乘法和除法？</p><p>除法是二的指数就很简单了，直接移位就行了。非二的倍数就比较复杂，这里先不讨论。</p><p>乘法的话，看乘数化为二进制的每一位是不是1.如果是1则被乘数向左移动该位的位置数（第一位默认是0）。例如：2*3: = 010 * 011：</p><ol><li>3的第一位是1，那么结果加上010向左移动0位，即010</li><li>3的第二位是1，那么结果加上010向左移动1位，即010+100=110</li><li>3的第三位是0，结果保持不变，最终是110 即6.</li></ol><p>这样就可以得到答案了。</p><p>但是我们给出的n的大小不确定，又不能用循环判断，那怎么去不断累加呢？</p><p>注意限制条件：1&lt;=n&lt;=10000 。n不会超过·10000，也就是n的二进制位数不会超过14，所以弄14层代替循环即可。没错就是这么暴力。</p><blockquote><p>这道不同编程语言的逻辑运算可参与的数据类型不同。c/c++中可以用整数来进行逻辑运算，但是java等面向对象的语言是不可以的。要注意这点。</p></blockquote><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, A = n, B = n + <span class="hljs-number">1</span>;        <span class="hljs-keyword">boolean</span> flag;        flag = ((B &amp; <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &amp;&amp; (ans += A) &gt; <span class="hljs-number">0</span>;        A &lt;&lt;= <span class="hljs-number">1</span>;        B &gt;&gt;= <span class="hljs-number">1</span>;        flag = ((B &amp; <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &amp;&amp; (ans += A) &gt; <span class="hljs-number">0</span>;        A &lt;&lt;= <span class="hljs-number">1</span>;        B &gt;&gt;= <span class="hljs-number">1</span>;        flag = ((B &amp; <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &amp;&amp; (ans += A) &gt; <span class="hljs-number">0</span>;        A &lt;&lt;= <span class="hljs-number">1</span>;        B &gt;&gt;= <span class="hljs-number">1</span>;        flag = ((B &amp; <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &amp;&amp; (ans += A) &gt; <span class="hljs-number">0</span>;        A &lt;&lt;= <span class="hljs-number">1</span>;        B &gt;&gt;= <span class="hljs-number">1</span>;        flag = ((B &amp; <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &amp;&amp; (ans += A) &gt; <span class="hljs-number">0</span>;        A &lt;&lt;= <span class="hljs-number">1</span>;        B &gt;&gt;= <span class="hljs-number">1</span>;        flag = ((B &amp; <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &amp;&amp; (ans += A) &gt; <span class="hljs-number">0</span>;        A &lt;&lt;= <span class="hljs-number">1</span>;        B &gt;&gt;= <span class="hljs-number">1</span>;        flag = ((B &amp; <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &amp;&amp; (ans += A) &gt; <span class="hljs-number">0</span>;        A &lt;&lt;= <span class="hljs-number">1</span>;        B &gt;&gt;= <span class="hljs-number">1</span>;        flag = ((B &amp; <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &amp;&amp; (ans += A) &gt; <span class="hljs-number">0</span>;        A &lt;&lt;= <span class="hljs-number">1</span>;        B &gt;&gt;= <span class="hljs-number">1</span>;        flag = ((B &amp; <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &amp;&amp; (ans += A) &gt; <span class="hljs-number">0</span>;        A &lt;&lt;= <span class="hljs-number">1</span>;        B &gt;&gt;= <span class="hljs-number">1</span>;        flag = ((B &amp; <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &amp;&amp; (ans += A) &gt; <span class="hljs-number">0</span>;        A &lt;&lt;= <span class="hljs-number">1</span>;        B &gt;&gt;= <span class="hljs-number">1</span>;        flag = ((B &amp; <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &amp;&amp; (ans += A) &gt; <span class="hljs-number">0</span>;        A &lt;&lt;= <span class="hljs-number">1</span>;        B &gt;&gt;= <span class="hljs-number">1</span>;        flag = ((B &amp; <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &amp;&amp; (ans += A) &gt; <span class="hljs-number">0</span>;        A &lt;&lt;= <span class="hljs-number">1</span>;        B &gt;&gt;= <span class="hljs-number">1</span>;        flag = ((B &amp; <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &amp;&amp; (ans += A) &gt; <span class="hljs-number">0</span>;        A &lt;&lt;= <span class="hljs-number">1</span>;        B &gt;&gt;= <span class="hljs-number">1</span>;        flag = ((B &amp; <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &amp;&amp; (ans += A) &gt; <span class="hljs-number">0</span>;        A &lt;&lt;= <span class="hljs-number">1</span>;        B &gt;&gt;= <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> ans &gt;&gt; <span class="hljs-number">1</span>;    &#125;</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ol><li>时间复杂度：只需要遍历n的二进制位数</li></ol><blockquote><p>时间复杂度：O(logn)</p></blockquote><ol start="2"><li>空间复杂度：只需要额外的常量空间</li></ol><blockquote><p>空间复杂度：O(1)</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：求1-2-n&quot;&gt;&lt;a href=&quot;#题目：求1-2-n&quot; class=&quot;headerlink&quot; title=&quot;题目：求1+2+..+n&quot;&gt;&lt;/a&gt;题目：求1+2+..+n&lt;/h3&gt;&lt;p&gt;求 1+2+…+n ，要求不能使用乘除法、for、while、if、el
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="位运算" scheme="http://yoursite.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>算法：拥有最多糖果的孩子</title>
    <link href="http://yoursite.com/2020/06/01/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90/"/>
    <id>http://yoursite.com/2020/06/01/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90/</id>
    <published>2020-06-01T06:30:00.000Z</published>
    <updated>2020-06-01T06:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：拥有最多糖果的孩子"><a href="#题目：拥有最多糖果的孩子" class="headerlink" title="题目：拥有最多糖果的孩子"></a>题目：拥有最多糖果的孩子</h3><p>给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。</p><p>对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。</p> <pre><code class="hljs plain">示例 ：输入：candies &#x3D; [2,3,5,1,3], extraCandies &#x3D; 3输出：[true,true,true,false,true] 解释：孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。</code></pre><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>六一儿童节快乐呀。今天做的算法题也轻松一下。思路很简单，找到糖果最多的那个小朋友，然后再依次把多余的糖果分配给每一个小朋友，看他们的手上的糖果是否大于等于最大的那个。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Boolean&gt; <span class="hljs-title">kidsWithCandies</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] candies, <span class="hljs-keyword">int</span> extraCandies)</span> </span>&#123;       <span class="hljs-keyword">int</span> n = candies.length;       <span class="hljs-keyword">int</span> maxCandies = <span class="hljs-number">0</span>;       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;           maxCandies = Math.max(maxCandies, candies[i]);       &#125;       List&lt;Boolean&gt; ret = <span class="hljs-keyword">new</span> ArrayList&lt;Boolean&gt;();       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;           ret.add(candies[i] + extraCandies &gt;= maxCandies);       &#125;       <span class="hljs-keyword">return</span> ret;   &#125;</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>假设一共有n个孩子</p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><ol><li>时间复杂度：遍历两次数组</li></ol><blockquote><p>时间复杂度：O(n)</p></blockquote><ol start="2"><li>空间复杂度：只需要额外的常量空间</li></ol><blockquote><p>空间复杂度：O(1)</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：拥有最多糖果的孩子&quot;&gt;&lt;a href=&quot;#题目：拥有最多糖果的孩子&quot; class=&quot;headerlink&quot; title=&quot;题目：拥有最多糖果的孩子&quot;&gt;&lt;/a&gt;题目：拥有最多糖果的孩子&lt;/h3&gt;&lt;p&gt;给你一个数组 candies 和一个整数 extraCand
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法：判断对称二叉树</title>
    <link href="http://yoursite.com/2020/05/31/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%A4%E6%96%AD%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/05/31/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%A4%E6%96%AD%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-05-31T06:30:00.000Z</published>
    <updated>2020-05-31T06:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：判断对称二叉树"><a href="#题目：判断对称二叉树" class="headerlink" title="题目：判断对称二叉树"></a>题目：判断对称二叉树</h3><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><pre><code class="hljs plain">    1   &#x2F; \  2   2 &#x2F; \ &#x2F; \3  4 4  3</code></pre><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><pre><code class="hljs plain">  1 &#x2F; \2   2 \   \ 3    3</code></pre><pre><code class="hljs plain">示例:输入: [2,1,5,6,2,3]输出: 10</code></pre><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/symmetric-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/symmetric-tree</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>说实话这道题我想了挺久的，可能太久没接触过二叉树了。</p><p>比较容易得到的思路是是递归。根节点下的左右两棵树在一个方法内分别 进行先序递归遍历，但是不同的是，一个是从左边开始的先序遍历，一个是从右边开始的先序遍历。然后依次判断元素是否相同即可。</p><p>另外也可以使用迭代的方式，因为是先序遍历，先遍历到先判断，所以这里可以使用一个特点相同的队列数据结构来辅助迭代。每次取出来两个元素，然后按照一左一右把元素放进去即可。（参考代码即可理解）</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;    <span class="hljs-keyword">int</span> val;    TreeNode left;    TreeNode right;     TreeNode(<span class="hljs-keyword">int</span> x) &#123; val = x; &#125; &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">return</span> getBoolean(root.left,root.right);&#125; <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">getBoolean</span><span class="hljs-params">(TreeNode nodeL, TreeNode nodeR)</span></span>&#123;        <span class="hljs-keyword">if</span> (nodeL == <span class="hljs-keyword">null</span> &amp;&amp; nodeR == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span> (nodeL == <span class="hljs-keyword">null</span> || nodeR == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span> (nodeL.val != nodeR.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">return</span> getBoolean(nodeL.left,nodeR.right) &amp;&amp; getBoolean(nodeL.right,nodeR.left); &#125;</code></pre><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">return</span> check(root.left, root.right);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">check</span><span class="hljs-params">(TreeNode u, TreeNode v)</span> </span>&#123;        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();        q.offer(u);        q.offer(v);        <span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;            u = q.poll();            v = q.poll();            <span class="hljs-keyword">if</span> (u == <span class="hljs-keyword">null</span> &amp;&amp; v == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span> ((u == <span class="hljs-keyword">null</span> || v == <span class="hljs-keyword">null</span>) || (u.val != v.val)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            q.offer(u.left);            q.offer(v.right);            q.offer(u.right);            q.offer(v.left);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>假设二叉树的元素个数为n</p><h4 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h4><ol><li>时间复杂度：每个元素都需要遍历一次</li></ol><blockquote><p>时间复杂度：O(n)</p></blockquote><ol start="2"><li>空间复杂度：栈的个数不会超过元素个数</li></ol><blockquote><p>空间复杂度：O(n)</p></blockquote><h4 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h4><ol><li>时间复杂度：每个元素都需要遍历一次</li></ol><blockquote><p>时间复杂度：O(n)</p></blockquote><ol start="2"><li>空间复杂度：队列的长度不会超过n</li></ol><blockquote><p>空间复杂度：O(n)</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：判断对称二叉树&quot;&gt;&lt;a href=&quot;#题目：判断对称二叉树&quot; class=&quot;headerlink&quot; title=&quot;题目：判断对称二叉树&quot;&gt;&lt;/a&gt;题目：判断对称二叉树&lt;/h3&gt;&lt;p&gt;给定一个二叉树，检查它是否是镜像对称的。&lt;/p&gt;
&lt;p&gt;例如，二叉树 [1,
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>算法：柱状图中最大的矩形</title>
    <link href="http://yoursite.com/2020/05/29/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
    <id>http://yoursite.com/2020/05/29/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</id>
    <published>2020-05-29T09:30:00.000Z</published>
    <updated>2020-05-29T09:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：柱状图中最大的矩形"><a href="#题目：柱状图中最大的矩形" class="headerlink" title="题目：柱状图中最大的矩形"></a>题目：柱状图中最大的矩形</h3><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="https://img2020.cnblogs.com/blog/1961534/202005/1961534-20200530184957296-77413922.png" srcset="/img/loading.gif" alt=""></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p><p><img src="https://img2020.cnblogs.com/blog/1961534/202005/1961534-20200530184958716-2094348161.png" srcset="/img/loading.gif" alt=""></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p><pre><code class="hljs plain">示例:输入: [2,1,5,6,2,3]输出: 10</code></pre><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram" target="_blank" rel="noopener">https://leetcode-cn.com/problems/largest-rectangle-in-histogram</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>拿到这道题，先不要想其他的方法，看看暴力解法能不能算出来。我们会发现暴力算法有两个方案：一个是变化矩形的范围，然后求出范围中的最低柱子，就可以得到面积了。第二个是每个柱子分别向前后扩散，遇到比自己低的就停下来，那么这个范围的宽度乘上自身的高度，就是该位置的柱子可以达到的最大面积。（第二种我当时没想出来==）</p><p>然后我们从暴力算法中，看看有没有可以进行优化的地方。首先两种思路，第一种的话因为已经固定了两层嵌套循环，要去优化的话显然有点困难。第二种的思路只有一个外层循环，所以优化的空间可能会比较大，我们从第二种入手。</p><p>首先我们知道，第二种思路最费时间的点就是每次都要前后去寻找，那我们这里可以去想一下怎么把前面遍历的情况记录下来，节省时间。所以难点就是在确定边界。</p><p>重要特点：这里我们分析边界的特点。如果i &lt; j ,且heights[i] &gt; heights[j] ,这样的话，对于任何 j &lt; k,第K个元素的左边界不可能是i。因为被 j 挡住了。这个应该很好理解吧。可以的话我们继续。</p><p>首先我们进行遍历数组，看什么时候可以确定边界。假设现在有[2,4,1,5,7,3]。（大家可以自行画图体验，我这里就不画图了，懒癌犯了）</p><ol><li>遍历到2的时候，已经确定好左边界，但是还没有确定右边界；</li><li>遍历4，同二。</li><li>遍历1，这个时候我们会发现，第二个元素4，已经确定好边界了，可以得出面积4.</li><li>然后可以发现第一个元素2，也得到他的边界了。</li><li>然后我们会发现，位置1 比前面的任何元素都要小，那么后面的元素，不可能以2,4为左边界。原因看上面。</li><li>然后同理继续遍历5，和7.然后遍历到3的时候，元素 7 也确定边界了。元素5也确定边界了。</li><li>后面已经没有元素了，所以3也可以确定边界。最后再确定1的边界。</li></ol><p>观察上面的流程，有没有一丝丝什么的味道？栈的味道。遍历可以看做是入栈，确定边界的时候，可以看成出栈。先进后出。那么可不可以用一个辅助栈来完成这个流程呢？答案是肯定的。</p><p>思路和上面一模一样，重点是入栈和出栈。从上面的重要特点可以知道，当遇到比较小的元素的时候，那么前面的元素就可以确定边界了，进行出栈操作。所以栈底，永远是前面的最小元素。</p><ol><li>当遍历到的元素比栈顶要小的时候，那么就可以对栈顶元素进行出栈</li><li>这个矩形的高度是栈顶元素的高度，宽度是当前遍历到的元素的 下标 i - 栈顶元素的下一个元素的下标 j + 1.为什么是这样？大家可以画个图模拟一下，就留给大家思考了。</li><li>遍历完成后，再对栈里的元素进行出栈操作。</li><li>过程中记录最大的矩形面积。</li></ol><p>这里建议大家画图去模拟这个过程，会很好去理解，特别是关于矩形的边界的确定，如果没有画图，很容易就漏掉一些细节的考虑。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights)</span> </span>&#123;    <span class="hljs-keyword">if</span> (heights.length==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();    stack.push(<span class="hljs-number">0</span>);    <span class="hljs-keyword">int</span> maxArea = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;heights.length;i++)&#123;        <span class="hljs-keyword">if</span> (heights[i]&gt;=heights[stack.peek()]) stack.push(i);        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[i]&lt;heights[stack.peek()] )&#123;                <span class="hljs-keyword">int</span> index = stack.pop();                <span class="hljs-keyword">int</span> area;                <span class="hljs-keyword">if</span> (stack.isEmpty())&#123;                    area = i*heights[index];                &#125;<span class="hljs-keyword">else</span>&#123;                    area = (i-stack.peek()-<span class="hljs-number">1</span>)*heights[index];                &#125;                maxArea = Math.max(maxArea, area);            &#125;            stack.push(i);        &#125;    &#125;    <span class="hljs-keyword">while</span> (!stack.isEmpty())&#123;        <span class="hljs-keyword">int</span> index = stack.pop();        <span class="hljs-keyword">int</span> area;        <span class="hljs-keyword">if</span> (stack.isEmpty())&#123;            area = heights.length*heights[index];        &#125;<span class="hljs-keyword">else</span>&#123;            area = (heights.length-stack.peek()-<span class="hljs-number">1</span>)*heights[index];        &#125;        maxArea = Math.max(area,maxArea);    &#125;    <span class="hljs-keyword">return</span> maxArea;&#125;</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>假设数组的长度为n</p><ol><li>时间复杂度：首先需要遍历一次数组，每个元素至多进行一次出栈和入栈操作。</li></ol><blockquote><p>时间复杂度：O(n)</p></blockquote><ol start="2"><li>空间复杂度：这里所需要的空间是栈。最多是数组的长度。</li></ol><blockquote><p>空间复杂度：O(n)</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：柱状图中最大的矩形&quot;&gt;&lt;a href=&quot;#题目：柱状图中最大的矩形&quot; class=&quot;headerlink&quot; title=&quot;题目：柱状图中最大的矩形&quot;&gt;&lt;/a&gt;题目：柱状图中最大的矩形&lt;/h3&gt;&lt;p&gt;给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="辅助栈" scheme="http://yoursite.com/tags/%E8%BE%85%E5%8A%A9%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>算法：字符串解码</title>
    <link href="http://yoursite.com/2020/05/29/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2020/05/29/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</id>
    <published>2020-05-29T09:30:00.000Z</published>
    <updated>2020-05-29T09:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：字符串解码"><a href="#题目：字符串解码" class="headerlink" title="题目：字符串解码"></a>题目：字符串解码</h3><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><pre><code class="hljs plain">示例:s &#x3D; &quot;3[a]2[bc]&quot;, 返回 &quot;aaabcbc&quot;.s &#x3D; &quot;3[a2[c]]&quot;, 返回 &quot;accaccacc&quot;.s &#x3D; &quot;2[abc]3[cd]ef&quot;, 返回 &quot;abcabccdcdcdef&quot;.</code></pre><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/decode-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/decode-string</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>首先讲一下我拿到这道题的思路：递归。每一歌中括号可以是一层，然后递归返回中括号中的字符串，和外层的数字进行循环重复后继续下一个中括号。例如：<code>2[4[ab]]3[b]</code></p><ol><li>先得到2，然后递归进入第一个中括号</li><li>得到4，递归进入</li><li>得到ab，遇到<code>]</code>返回上一层</li><li>ab进行4次重复，遇到<code>]</code>返回上一层</li><li>把得到的字符串进行2次重复。然后继续下一组。</li></ol><p>思路应该是挺清晰的。但是这里有几个问题：在第五步的时候怎么确定下一组开始的位置？每一步递归，怎么确认开始的位置？我当时就卡在第一个问题，不知道如何解决。</p><p>对于第二个问题，很简单，重新写一个方法来递归，然后加入position参数即可。第一个问题有两个思路：</p><ol><li>全局变量</li><li>在返回参数中加入</li></ol><p>我比较喜欢第二种。因为全局变量就破坏了封装，我觉得不可取。但是返回参数，不是字符串吗，怎么附带位置信息？这里有个很好的解决方案：字符串数组。返回的字符串数组中一个保存得到的字符串，一个是数字字符串，再进行转换就可以得到位置信息了。思路到此应该就差不多了。另外的实现细节可以自己补充。</p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>有递归，那么和递归一样思路的是什么？没错就是栈，那么我们可以使用一个辅助栈解决这个问题。思路和递归是差不多的：</p><ol><li>遍历字符串数组并把字符放进栈。</li><li>当遍历到<code>]</code>时进行回溯，把中距离栈顶第一个<code>[</code>前的字符串拿出来</li><li>然后再遍历数字，遇到栈底或者<code>]</code>停止</li><li>然后进行循环运算后把字符串放进栈中</li><li>最后返回栈中的字符串</li></ol><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h4><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">decodeString</span><span class="hljs-params">(s: <span class="hljs-type">String</span>)</span></span>: String&#123;    <span class="hljs-keyword">return</span> getStrings(s,<span class="hljs-number">0</span>)[<span class="hljs-number">0</span>]&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getStrings</span><span class="hljs-params">(s:<span class="hljs-type">String</span>,i:<span class="hljs-type">Int</span>)</span></span>:StringArray&#123;    <span class="hljs-keyword">val</span> stringBuilder = StringBuilder()    <span class="hljs-keyword">var</span> num = <span class="hljs-number">0</span>    <span class="hljs-keyword">var</span> position = i    <span class="hljs-keyword">while</span> (position&lt;s.length)&#123;        <span class="hljs-keyword">if</span> (s[position] <span class="hljs-keyword">in</span> <span class="hljs-string">'a'</span>..<span class="hljs-string">'z'</span> || s[position] <span class="hljs-keyword">in</span> <span class="hljs-string">'A'</span>..<span class="hljs-string">'Z'</span>)&#123;            stringBuilder.append(s[position])        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[position] <span class="hljs-keyword">in</span> <span class="hljs-string">'0'</span>..<span class="hljs-string">'9'</span>)&#123;            num = num*<span class="hljs-number">10</span> + s[position].toInt()-<span class="hljs-number">48</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[position]==<span class="hljs-string">'['</span>)&#123;            <span class="hljs-keyword">val</span> stringArray = getStrings(s,position+<span class="hljs-number">1</span>)            position = stringArray[<span class="hljs-number">1</span>].toInt()            <span class="hljs-keyword">while</span> (num!=<span class="hljs-number">0</span>)&#123;                stringBuilder.append(stringArray[<span class="hljs-number">0</span>])                num--            &#125;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[position]==<span class="hljs-string">']'</span>)&#123;            <span class="hljs-keyword">val</span> stringArray = StringArray()            stringArray.add(stringBuilder.toString())            stringArray.add(position.toString())            <span class="hljs-keyword">return</span> stringArray        &#125;        position++    &#125;    <span class="hljs-keyword">val</span> stringArray = StringArray()    stringArray.add(stringBuilder.toString())    stringArray.add(position.toString())    <span class="hljs-keyword">return</span> stringArray&#125;</code></pre><h4 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h4><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">decodeString</span><span class="hljs-params">(s: <span class="hljs-type">String</span>)</span></span>: String&#123;    <span class="hljs-keyword">if</span> (s.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>    <span class="hljs-keyword">val</span> stack = Stack&lt;<span class="hljs-built_in">Char</span>&gt;()    <span class="hljs-keyword">for</span> (c <span class="hljs-keyword">in</span> s)&#123;        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">']'</span>)&#123;            <span class="hljs-keyword">val</span> stringBuilder = StringBuilder()            <span class="hljs-keyword">while</span> (stack.peek()!=<span class="hljs-string">'['</span>)&#123;                stringBuilder.append(stack.pop())            &#125;            stack.pop()            <span class="hljs-keyword">val</span> string = stringBuilder.reverse().toString()            <span class="hljs-keyword">var</span> num = <span class="hljs-number">0</span>            <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>            <span class="hljs-keyword">while</span> (stack.isNotEmpty() &amp;&amp; stack.peek()&gt;=<span class="hljs-string">'0'</span> &amp;&amp; stack.peek()&lt;=<span class="hljs-string">'9'</span>)&#123;                <span class="hljs-keyword">val</span> topNum = stack.pop().toInt()-<span class="hljs-number">48</span>                <span class="hljs-keyword">val</span> p = <span class="hljs-number">10</span>.toDouble().pow(i)                num += topNum*p.toInt()                i++            &#125;            <span class="hljs-keyword">for</span> (j <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..num)&#123;                stack.addAll(string.toList())            &#125;        &#125;<span class="hljs-keyword">else</span> stack.add(c)    &#125;    <span class="hljs-keyword">val</span> sb = StringBuilder()    <span class="hljs-keyword">while</span> (stack.isNotEmpty())&#123;        sb.append(stack.pop())    &#125;    sb.reverse()    <span class="hljs-keyword">return</span> sb.toString()&#125;</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>假如最终的字符串长度为n，原字符串的长度为k</p><h4 id="方法一-2"><a href="#方法一-2" class="headerlink" title="方法一"></a>方法一</h4><ol><li>时间复杂度：遍历原字符串，还需要把新字符一个个拼进来。</li></ol><blockquote><p>时间复杂度：O(n+k)</p></blockquote><ol start="2"><li>空间复杂度：这里所需要的空间是递归栈的深度，最坏情况下为k</li></ol><blockquote><p>空间复杂度：O(k)</p></blockquote><h4 id="方法二-2"><a href="#方法二-2" class="headerlink" title="方法二"></a>方法二</h4><ol><li>时间复杂度：除了遍历一次原字符串，还要把每个字符都放进栈中所以是</li></ol><blockquote><p>时间复杂度：O(n+k)</p></blockquote><ol start="2"><li>空间复杂度：需要一个栈来保存数据，栈的长度为字符串的长度</li></ol><blockquote><p>空间复杂度：O(n)</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：字符串解码&quot;&gt;&lt;a href=&quot;#题目：字符串解码&quot; class=&quot;headerlink&quot; title=&quot;题目：字符串解码&quot;&gt;&lt;/a&gt;题目：字符串解码&lt;/h3&gt;&lt;p&gt;给定一个经过编码的字符串，返回它解码后的字符串。&lt;/p&gt;
&lt;p&gt;编码规则为: k[encod
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法：和可被k整除的子数组数目</title>
    <link href="http://yoursite.com/2020/05/27/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%92%8C%E4%B8%BAK%E7%9A%84%E6%A8%A1%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/"/>
    <id>http://yoursite.com/2020/05/27/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%92%8C%E4%B8%BAK%E7%9A%84%E6%A8%A1%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/</id>
    <published>2020-05-27T09:30:00.000Z</published>
    <updated>2020-05-27T09:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：和可被k整除的子数组数目"><a href="#题目：和可被k整除的子数组数目" class="headerlink" title="题目：和可被k整除的子数组数目"></a>题目：和可被k整除的子数组数目</h3><p>给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。</p><pre><code class="hljs plain">示例：输入：A &#x3D; [4,5,0,-2,-3,1], K &#x3D; 5输出：7解释：有 7 个子数组满足其元素之和可被 K &#x3D; 5 整除：[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]</code></pre><pre><code class="hljs plain">提示：1 &lt;&#x3D; A.length &lt;&#x3D; 30000-10000 &lt;&#x3D; A[i] &lt;&#x3D; 100002 &lt;&#x3D; K &lt;&#x3D; 10000</code></pre><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/subarray-sums-divisible-by-k" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subarray-sums-divisible-by-k</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这道题的思路重点在前缀和+同余定理。</p><p>拿到这道题的时候我一直在想着一个子数组如果符合条件的话，怎样推出他周边的子数组是否符合条件？想了半天还是只有O（N^2）的思路。这里就要用到这个同余定理。</p><p>同余定理：当一个数组，当从0到x-1位置所有数加起来取K的模，和0到Y位置所有数加起来取K的模相等，那么X到Y所有数加起来满足被K整除。这个定理很好证明，这里就不证明了。</p><p>所以我们就顺然想到了前缀和。我们可以统计该数组中所有的前缀和，那么就可以得到满足的子数组数目了。</p><p>这里的实现思路是在遍历的时候维护一个hashMap，记录每种余数的前缀和有多少个。然后当遍历到i位置的时候，假如当前位置的前缀和取K的模是 M，那么查询hashMap，M对应的数目有多少个，那么就有多少个符合条件的数组了。</p><p>注意：这里因为和可能为负数，取模后可能出现负数，所以要进行矫正。不是简单的取绝对值，因为假如模是6,-2实际上等于4而不是2。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subarraysDivByK</span><span class="hljs-params">(A: <span class="hljs-type">IntArray</span>?, K: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;    <span class="hljs-keyword">val</span> hashMap = HashMap&lt;<span class="hljs-built_in">Int</span>,<span class="hljs-built_in">Int</span>&gt;()    hashMap[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>    <span class="hljs-keyword">var</span> num = <span class="hljs-number">0</span>    <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> (elem <span class="hljs-keyword">in</span> A!!)&#123;        sum += elem        <span class="hljs-keyword">val</span> remainder = (sum % K+K)%K        println(remainder)        <span class="hljs-keyword">val</span> indexNum = hashMap.getOrDefault(remainder,<span class="hljs-number">0</span>)        num += indexNum        hashMap[remainder] = indexNum+<span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">return</span> num&#125;</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>遍历一次数组</p><ul><li>时间复杂度：O(n)</li></ul><h5 id="空件复杂度"><a href="#空件复杂度" class="headerlink" title="空件复杂度"></a>空件复杂度</h5><p>维护一个哈希表。长度是Max（K，A.size）</p><ul><li>O(Max（K，A.size）)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：和可被k整除的子数组数目&quot;&gt;&lt;a href=&quot;#题目：和可被k整除的子数组数目&quot; class=&quot;headerlink&quot; title=&quot;题目：和可被k整除的子数组数目&quot;&gt;&lt;/a&gt;题目：和可被k整除的子数组数目&lt;/h3&gt;&lt;p&gt;给定一个整数数组 A，返回其中元素之
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="前缀和" scheme="http://yoursite.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>算法：删除链表节点</title>
    <link href="http://yoursite.com/2020/05/24/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2020/05/24/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9/</id>
    <published>2020-05-24T11:30:00.000Z</published>
    <updated>2020-05-24T11:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：删除链表节点"><a href="#题目：删除链表节点" class="headerlink" title="题目：删除链表节点"></a>题目：删除链表节点</h3><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p>示例 1:</p><pre><code class="hljs plain">输入: head &#x3D; [4,5,1,9], val &#x3D; 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</code></pre><pre><code class="hljs plain">&gt; 来源：力扣（LeetCode）&gt; 链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;shan-chu-lian-biao-de-jie-dian-lcof### 分析思路非常简单，找到那个节点，然后把前面的节点指向该节点的next就可以。注意c&#x2F;c++要释放内存。### 解答&#96;&#96;&#96;kotlinfun deleteNode(head: ListNode?, &#96;val&#96;: Int): ListNode? &#123;    if (head?.next &#x3D;&#x3D; null) return head    if (head.&#96;val&#96;&#x3D;&#x3D;&#96;val&#96;) return head.next    var current &#x3D; head.next    var previous &#x3D; head    while (current!&#x3D;null)&#123;        if (current.&#96;val&#96;&#x3D;&#x3D; &#96;val&#96;) previous?.next &#x3D; current.next        previous &#x3D; current        current &#x3D; current.next    &#125;    return head&#125;</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>遍历一次链表</p><ul><li>时间复杂度：O(n)</li></ul><h5 id="空件复杂度"><a href="#空件复杂度" class="headerlink" title="空件复杂度"></a>空件复杂度</h5><p>常量空间</p><ul><li>空间复杂度：O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：删除链表节点&quot;&gt;&lt;a href=&quot;#题目：删除链表节点&quot; class=&quot;headerlink&quot; title=&quot;题目：删除链表节点&quot;&gt;&lt;/a&gt;题目：删除链表节点&lt;/h3&gt;&lt;p&gt;给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>算法：旋转链表</title>
    <link href="http://yoursite.com/2020/05/24/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/05/24/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2020-05-24T10:30:00.000Z</published>
    <updated>2020-05-24T10:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：旋转链表"><a href="#题目：旋转链表" class="headerlink" title="题目：旋转链表"></a>题目：旋转链表</h3><p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p><p>示例 1:</p><pre><code class="hljs plain">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k &#x3D; 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</code></pre><pre><code class="hljs plain">&gt; 来源：力扣（LeetCode）&gt; 链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;rotate-list### 分析这道题很简单。首先让链表变成环，然后看哪个是头节点，把上个节点的next指针变成null，返回该头节点即可。怎么找到头节点呢？用链表的长度-用k取链表长度模，就是头节点了。### 解答&#96;&#96;&#96;kotlinfun rotateRight(head: ListNode?, k: Int): ListNode? &#123;    if (head?.next &#x3D;&#x3D; null) return head    var num &#x3D; 0    var current &#x3D; head    var previous : ListNode? &#x3D; head    while (previous?.next!&#x3D;null)&#123;        num++        previous &#x3D; previous.next    &#125;    num++    previous?.next &#x3D; current    val step &#x3D; num-k%num    for (i in 1..step)&#123;        previous &#x3D; current        current &#x3D; current?.next    &#125;    previous?.next &#x3D; null    return current&#125;</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>遍历一次链表</p><ul><li>时间复杂度：O(n)</li></ul><h5 id="空件复杂度"><a href="#空件复杂度" class="headerlink" title="空件复杂度"></a>空件复杂度</h5><p>常量空间</p><ul><li>空间复杂度：O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：旋转链表&quot;&gt;&lt;a href=&quot;#题目：旋转链表&quot; class=&quot;headerlink&quot; title=&quot;题目：旋转链表&quot;&gt;&lt;/a&gt;题目：旋转链表&lt;/h3&gt;&lt;p&gt;给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。&lt;/p&gt;
&lt;p&gt;示例
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>算法：合并k个有序链表</title>
    <link href="http://yoursite.com/2020/05/24/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/05/24/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2020-05-24T08:30:00.000Z</published>
    <updated>2020-05-24T08:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：合并k个有序链表"><a href="#题目：合并k个有序链表" class="headerlink" title="题目：合并k个有序链表"></a>题目：合并k个有序链表</h3><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p>示例:</p><pre><code class="hljs plain">输入:[  1-&gt;4-&gt;5,  1-&gt;3-&gt;4,  2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>要解决这个问题，首先要解决合并2个有序链表的方法，并以此作为拓展来实现合并K个有序链表。关于合并两个有序链表这里不再描述，可以去看我的相关文章。</p><p>这里提供两个思路，一是不断通过两两合并的方式把全部链表合并起来；二是每次从所有链表中选出最小的那个加到链表尾部。</p><p>思路一：这个思路很清晰，但是要注意一点，不能够一条一条合进来，要进行分治法，先两两合并后，再把剩下的两两合并。例如1234，先2+1，再3+4，最后再3+7（这里的1234指的是4个链表）。</p><p>思路二：每次从所有节点中抽取一个节点出来。这里可以使用一个优先队列来维护k个数据。每次从队列中拿走一个节点后就把该节点的下一节点放进去。这样的好处就是，优先队列可以通过效率比较高的算法排序（堆算法），比我们一个个找的效率要高，坏处就是要占用额外的空间。下面的解答我没有使用队列，直接一个个去查找，读者可以自行尝试。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span></span>(<span class="hljs-keyword">var</span> `<span class="hljs-keyword">val</span>`: <span class="hljs-built_in">Int</span>) &#123;    <span class="hljs-keyword">var</span> next: ListNode? = <span class="hljs-literal">null</span>&#125;</code></pre><h5 id="解答一"><a href="#解答一" class="headerlink" title="解答一"></a>解答一</h5><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mergeKLists</span><span class="hljs-params">(lists: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">ListNode</span>?&gt;)</span></span>: ListNode? &#123;    <span class="hljs-keyword">val</span> listArray = ArrayList&lt;ListNode&gt;()    <span class="hljs-keyword">for</span> (node <span class="hljs-keyword">in</span> lists)&#123;        <span class="hljs-keyword">if</span> (node!=<span class="hljs-literal">null</span>) listArray.add(node)    &#125;    <span class="hljs-keyword">if</span> (listArray.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>    <span class="hljs-keyword">val</span> listHead = ListNode(<span class="hljs-number">0</span>)    <span class="hljs-keyword">var</span> listCurrent = listHead    <span class="hljs-keyword">while</span> (listArray.isNotEmpty())&#123;        <span class="hljs-keyword">var</span> num = listArray[<span class="hljs-number">0</span>].`<span class="hljs-keyword">val</span>`        <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> until listArray.size)&#123;            <span class="hljs-keyword">if</span> (listArray[i].`<span class="hljs-keyword">val</span>`&lt;=num)&#123;                num = listArray[i].`<span class="hljs-keyword">val</span>`                index = i            &#125;        &#125;        listCurrent.next = listArray[index]        listCurrent = listCurrent.next!!        <span class="hljs-keyword">if</span> (listArray[index].next!=<span class="hljs-literal">null</span>) listArray[index] = listArray[index].next!!        <span class="hljs-keyword">else</span> listArray.removeAt(index)    &#125;    listCurrent.next = <span class="hljs-literal">null</span>    <span class="hljs-keyword">return</span> listHead.next&#125;</code></pre><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mergeKLists</span><span class="hljs-params">(lists: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">ListNode</span>?&gt;)</span></span>: ListNode? &#123;        <span class="hljs-keyword">if</span> (lists.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>        <span class="hljs-keyword">return</span> merge(lists,<span class="hljs-number">0</span>,lists.size-<span class="hljs-number">1</span>)    &#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">merge</span><span class="hljs-params">(lists: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">ListNode</span>?&gt;,s:<span class="hljs-type">Int</span>, e:<span class="hljs-type">Int</span>)</span></span>:ListNode?&#123;    <span class="hljs-keyword">if</span> (e&lt;=s) <span class="hljs-keyword">return</span> lists[s]    <span class="hljs-keyword">return</span> mergeTwoLists(merge(lists, s, s+(e-s)/<span class="hljs-number">2</span>),merge(lists,s+(e-s)/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,e))&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(l1: <span class="hljs-type">ListNode</span>?, l2: <span class="hljs-type">ListNode</span>?)</span></span>: ListNode? &#123;        <span class="hljs-keyword">when</span>&#123;            l1==<span class="hljs-literal">null</span>&amp;&amp;l2==<span class="hljs-literal">null</span> -&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>            l1==<span class="hljs-literal">null</span> -&gt; <span class="hljs-keyword">return</span> l2            l2==<span class="hljs-literal">null</span> -&gt; <span class="hljs-keyword">return</span> l1        &#125;        <span class="hljs-keyword">val</span> listNode :ListNode? = ListNode(<span class="hljs-number">0</span>)        <span class="hljs-keyword">var</span> current = listNode        <span class="hljs-keyword">var</span> point1 = l1        <span class="hljs-keyword">var</span> point2 = l2        <span class="hljs-keyword">while</span> (point1!=<span class="hljs-literal">null</span>&amp;&amp;point2!=<span class="hljs-literal">null</span>)&#123;            <span class="hljs-keyword">if</span> (point1.`<span class="hljs-keyword">val</span>`&lt;point2.`<span class="hljs-keyword">val</span>`)&#123;                current?.next = point1                point1 = point1.next            &#125; <span class="hljs-keyword">else</span> &#123;                current?.next = point2                point2 = point2.next            &#125;            current = current?.next        &#125;        <span class="hljs-keyword">if</span> (point1==<span class="hljs-literal">null</span>)&#123;            current?.next = point2        &#125; <span class="hljs-keyword">else</span> &#123;            current?.next = point1        &#125;        <span class="hljs-keyword">return</span> listNode?.next    &#125;</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>假设一共有k个链表，每个链表的最长长度是n</p><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>第一种方法每次要从k个链表中查找最小值，一共需要找kn次</p><ul><li>时间复杂度：O(kn*k)</li></ul><p>第二种方法递归的层数是logk，（自底向上）第一层一共分为k/2组，每组需要的时间是O(2n)。第二层一共分为k/4组，每组需要的时间是O(4n),以此类推。</p><ul><li>时间复杂度：O(logk*kn)</li></ul><p>可以看到第二种的速度会更快点，但是如果使用先序队列，那么时间复杂度就一样了。</p><h5 id="空件复杂度"><a href="#空件复杂度" class="headerlink" title="空件复杂度"></a>空件复杂度</h5><p>第一种方法不需要任何数组空间，只需要少量变量</p><ul><li>空间复杂度：O(1)</li></ul><p>第二种方法需要用到递归，栈的深度是logk，所以是</p><ul><li>空间复杂度：O(logk)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：合并k个有序链表&quot;&gt;&lt;a href=&quot;#题目：合并k个有序链表&quot; class=&quot;headerlink&quot; title=&quot;题目：合并k个有序链表&quot;&gt;&lt;/a&gt;题目：合并k个有序链表&lt;/h3&gt;&lt;p&gt;合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>算法：最小覆盖子字符串</title>
    <link href="http://yoursite.com/2020/05/23/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2020/05/23/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-05-23T12:32:16.691Z</published>
    <updated>2020-05-23T12:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：最小覆盖子字符串"><a href="#题目：最小覆盖子字符串" class="headerlink" title="题目：最小覆盖子字符串"></a>题目：最小覆盖子字符串</h3><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</p><p>示例：</p><pre><code class="hljs plain">输入: S &#x3D; &quot;ADOBECODEBANC&quot;, T &#x3D; &quot;ABC&quot;输出: &quot;BANC&quot;</code></pre><p>说明：</p><p>如果 S 中不存这样的子串，则返回空字符串 “”。<br>如果 S 中存在这样的子串，我们保证它是唯一的答案。</p><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-window-substring" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-window-substring</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这道题我到手的第一想法是用动态规划，但是后来发现，根本没有办法使用动态规划。首先，动态规划的难点在状态转换，而这道题没办法把以遍历的字符串进行状态记录，所以每次只能记录一下已遍历的字符串中是否有符合的字符串和最小长度，然后每次添加字符的时候都要把已遍历的字符串再遍历一次，因为你不确定是否可以变得更短，或者后面的可以组成更短的符合条件的字符串，所以显然可以发现动态规划很难进行下去。那怎么做呢，这里要提到另外一个概念：动态窗口。</p><p>顾名思义，我们要用一个窗口来标记字符串，然后通过窗口的平移和伸缩等进行遍历，直到遇到符合条件的字符串并记录。最终得到符合条件的最小字符串。</p><p>我们可以使用两个指针来表示窗口的左边界和右边界。每一轮的循环是：</p><ol><li>左指针不动，右指针一直往右，直到他们之间包含了字符串T，也就是所求的字符串。</li><li>左指针开始右移，去除掉左边无用的元素字符。</li><li>最终得到一个符合条件的字符串，并记录下来。</li></ol><p>上面三点是一个循环，然后不断重复，直到末尾。然后选择符合条件最短的字符串。</p><p>然后还有两个问题：</p><p>如何判断该字符是否在所求的字符串t中？如何判断左右指针之间是否已经包含了所求的字符串？这个问题可以通过维护一个hashMap来解决。先遍历一次所求的字符串t并把字符和对应的数目放进hashMap中，之后每遍历一次就-1，如果所有值都&lt;=0则说明已符合要求。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;       <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">minWindow</span><span class="hljs-params">(s: <span class="hljs-type">String</span>, t: <span class="hljs-type">String</span>)</span></span>: String &#123;        <span class="hljs-keyword">if</span> (s.isEmpty()||t.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>        <span class="hljs-keyword">val</span> hashMap  = HashMap&lt;<span class="hljs-built_in">Char</span>,<span class="hljs-built_in">Int</span>&gt;()        <span class="hljs-keyword">for</span> (char <span class="hljs-keyword">in</span> t)&#123;            <span class="hljs-keyword">if</span> (hashMap.containsKey(char)) hashMap[char] = hashMap[char]!!+<span class="hljs-number">1</span>            <span class="hljs-keyword">else</span> hashMap[char] = <span class="hljs-number">1</span>        &#125;        <span class="hljs-keyword">var</span> num = t.length        <span class="hljs-keyword">var</span> string = <span class="hljs-string">""</span>        <span class="hljs-keyword">var</span> pointLeft = <span class="hljs-number">0</span>        <span class="hljs-keyword">var</span> pointRight = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> (pointRight!=s.length)&#123;            <span class="hljs-keyword">while</span> (num!=<span class="hljs-number">0</span> &amp;&amp; pointRight&lt;s.length)&#123;                <span class="hljs-keyword">val</span> char = s[pointRight]                <span class="hljs-keyword">if</span> (hashMap.containsKey(char))&#123;                    hashMap[char] = hashMap[char]!!-<span class="hljs-number">1</span>                    hashMap[char]?.let &#123;                        <span class="hljs-keyword">if</span> (it&gt;=<span class="hljs-number">0</span>) num--                    &#125;                &#125;                pointRight++            &#125;            <span class="hljs-keyword">while</span> (num==<span class="hljs-number">0</span> &amp;&amp; pointLeft&lt;pointRight)&#123;                <span class="hljs-keyword">val</span> char = s[pointLeft]                <span class="hljs-keyword">if</span> (hashMap.containsKey(char))&#123;                    hashMap[char] = hashMap[char]!!+<span class="hljs-number">1</span>                    <span class="hljs-keyword">if</span> (hashMap[char]!!&gt;<span class="hljs-number">0</span>)&#123;                        num++                        <span class="hljs-keyword">if</span> (string.isEmpty() || string.length&gt;pointRight-pointLeft)                            string = s.substring(pointLeft,pointRight)                    &#125;                &#125;                pointLeft++            &#125;        &#125;        <span class="hljs-keyword">return</span> string    &#125;&#125;</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>首要要遍历一次字符串t，需要的时间是t的长度m。然后最坏情况下，左指针和右指针都需要遍历一次字符串s，需要的时间是s的长度n。</p><ul><li>时间复杂度：O(m+n)</li></ul><h5 id="控件复杂度"><a href="#控件复杂度" class="headerlink" title="控件复杂度"></a>控件复杂度</h5><p>需要维护一个哈希表，复杂度是t的长度m，以及一些中间变量。</p><ul><li>空间复杂度：O(m)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：最小覆盖子字符串&quot;&gt;&lt;a href=&quot;#题目：最小覆盖子字符串&quot; class=&quot;headerlink&quot; title=&quot;题目：最小覆盖子字符串&quot;&gt;&lt;/a&gt;题目：最小覆盖子字符串&lt;/h3&gt;&lt;p&gt;给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="滑动窗口" scheme="http://yoursite.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>算法：两数相加</title>
    <link href="http://yoursite.com/2020/05/23/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://yoursite.com/2020/05/23/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</id>
    <published>2020-05-23T05:30:00.000Z</published>
    <updated>2020-05-23T05:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：两数相加"><a href="#题目：两数相加" class="headerlink" title="题目：两数相加"></a>题目：两数相加</h3><p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例：</strong></p><pre><code class="hljs plain">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 &#x3D; 807</code></pre><p>拓展：如果是按照逆序呢？例如834=（8-&gt;3-&gt;4)</p><p>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers/solution/liang-shu-xiang-jia-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers/solution/liang-shu-xiang-jia-by-leetcode/</a><br>来源：力扣（LeetCode）</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这道题目思路很简单，再创建一个链表，然后记住进位，最后把剩下的接到后面即可。</p><p>关于拓展题目，使用递归或者栈来把顺序颠倒即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Example:</span><span class="hljs-comment"> * var li = ListNode(5)</span><span class="hljs-comment"> * var v = li.`val`</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * class ListNode(var `val`: Int) &#123;</span><span class="hljs-comment"> *     var next: ListNode? = null</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(l1: <span class="hljs-type">ListNode</span>?, l2: <span class="hljs-type">ListNode</span>?)</span></span>: ListNode? &#123;        <span class="hljs-keyword">if</span>  (l1==<span class="hljs-literal">null</span>||l2==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>        <span class="hljs-keyword">val</span> numString = StringBuilder()        <span class="hljs-keyword">var</span> carry = <span class="hljs-number">0</span>        <span class="hljs-keyword">var</span> link1:ListNode? = l1        <span class="hljs-keyword">var</span> link2:ListNode? = l2        <span class="hljs-keyword">while</span> (link1!=<span class="hljs-literal">null</span>||link2!=<span class="hljs-literal">null</span>)&#123;            <span class="hljs-keyword">val</span> one = link1?.`<span class="hljs-keyword">val</span>` ?: <span class="hljs-number">0</span>            <span class="hljs-keyword">val</span> two = link2?.`<span class="hljs-keyword">val</span>` ?: <span class="hljs-number">0</span>            <span class="hljs-keyword">var</span> add = one+two+carry            <span class="hljs-keyword">if</span> (add&gt;=<span class="hljs-number">10</span>)&#123;                carry = <span class="hljs-number">1</span>                add %= <span class="hljs-number">10</span>            &#125;<span class="hljs-keyword">else</span> carry = <span class="hljs-number">0</span>            numString.append(add)            link1?.let &#123; link1 = it.next &#125;            link2?.let &#123; link2 = it.next &#125;        &#125;        <span class="hljs-keyword">if</span> (carry==<span class="hljs-number">1</span>) numString.append(<span class="hljs-number">1</span>)        <span class="hljs-keyword">val</span> linkNode : ListNode = ListNode(numString[<span class="hljs-number">0</span>].toInt()-<span class="hljs-number">48</span>)        <span class="hljs-keyword">var</span> point = linkNode        <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> until numString.length)&#123;            <span class="hljs-keyword">val</span> node = ListNode(numString[i].toInt()-<span class="hljs-number">48</span>)            point.next = node            point = node        &#125;        point.next = <span class="hljs-literal">null</span>        <span class="hljs-keyword">return</span> linkNode    &#125;&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：两数相加&quot;&gt;&lt;a href=&quot;#题目：两数相加&quot; class=&quot;headerlink&quot; title=&quot;题目：两数相加&quot;&gt;&lt;/a&gt;题目：两数相加&lt;/h3&gt;&lt;p&gt;给出两个 &lt;strong&gt;非空&lt;/strong&gt; 的链表用来表示两个非负的整数。其中，它们各自的位数
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>算法：合并两个有序链表</title>
    <link href="http://yoursite.com/2020/05/23/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%90%88%E5%B9%B6%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/05/23/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%90%88%E5%B9%B6%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2020-05-22T16:30:00.000Z</published>
    <updated>2020-05-22T16:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：合并两个有序链表"><a href="#题目：合并两个有序链表" class="headerlink" title="题目：合并两个有序链表"></a>题目：合并两个有序链表</h3><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><pre><code class="hljs plain">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists</a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这道题目有两个做法，首先第一个是迭代这是做容易想到的。不断遍历，每次取出节点数字较小的拼接起来即可。</p><p>第二种方法是递归。每次分离出节点数字小的，然后把剩下继续递归，直到一方为空。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><ol><li>方法一：迭代</li></ol><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Example:</span><span class="hljs-comment"> * var li = ListNode(5)</span><span class="hljs-comment"> * var v = li.`val`</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * class ListNode(var `val`: Int) &#123;</span><span class="hljs-comment"> *     var next: ListNode? = null</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(l1: <span class="hljs-type">ListNode</span>?, l2: <span class="hljs-type">ListNode</span>?)</span></span>: ListNode? &#123;    <span class="hljs-keyword">when</span>&#123;        l1==<span class="hljs-literal">null</span>&amp;&amp;l2==<span class="hljs-literal">null</span> -&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>        l1==<span class="hljs-literal">null</span> -&gt; <span class="hljs-keyword">return</span> l2        l2==<span class="hljs-literal">null</span> -&gt; <span class="hljs-keyword">return</span> l1    &#125;    <span class="hljs-keyword">val</span> listNode :ListNode? = ListNode(<span class="hljs-number">0</span>)    <span class="hljs-keyword">var</span> current = listNode    <span class="hljs-keyword">var</span> point1 = l1    <span class="hljs-keyword">var</span> point2 = l2    <span class="hljs-keyword">while</span> (point1!=<span class="hljs-literal">null</span>&amp;&amp;point2!=<span class="hljs-literal">null</span>)&#123;        <span class="hljs-keyword">if</span> (point1.`<span class="hljs-keyword">val</span>`&lt;point2.`<span class="hljs-keyword">val</span>`)&#123;            current?.next = point1            point1 = point1.next        &#125; <span class="hljs-keyword">else</span> &#123;            current?.next = point2            point2 = point2.next        &#125;        current = current?.next    &#125;    <span class="hljs-keyword">if</span> (point1==<span class="hljs-literal">null</span>)&#123;        current?.next = point2    &#125; <span class="hljs-keyword">else</span> &#123;        current?.next = point1    &#125;    <span class="hljs-keyword">return</span> listNode?.next&#125;</code></pre><ol start="2"><li>方法二：递归</li></ol><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(l1: <span class="hljs-type">ListNode</span>?, l2: <span class="hljs-type">ListNode</span>?)</span></span>: ListNode?&#123;    <span class="hljs-keyword">when</span>&#123;        l1==<span class="hljs-literal">null</span>&amp;&amp;l2==<span class="hljs-literal">null</span> -&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>        l1==<span class="hljs-literal">null</span> -&gt; <span class="hljs-keyword">return</span> l2        l2==<span class="hljs-literal">null</span> -&gt; <span class="hljs-keyword">return</span> l1    &#125;    <span class="hljs-keyword">val</span> list1 = l1    <span class="hljs-keyword">val</span> list2 = l2    <span class="hljs-keyword">if</span> (list1!!.`<span class="hljs-keyword">val</span>`&lt;list2!!.`<span class="hljs-keyword">val</span>`)&#123;        list1.next = mergeTwoLists(list1.next,list2)        <span class="hljs-keyword">return</span> list1    &#125;<span class="hljs-keyword">else</span> &#123;        list2.next = mergeTwoLists(list2.next,list1)        <span class="hljs-keyword">return</span> list2    &#125;&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：合并两个有序链表&quot;&gt;&lt;a href=&quot;#题目：合并两个有序链表&quot; class=&quot;headerlink&quot; title=&quot;题目：合并两个有序链表&quot;&gt;&lt;/a&gt;题目：合并两个有序链表&lt;/h3&gt;&lt;p&gt;将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>算法：每个元音包含偶数次的最长字符串</title>
    <link href="http://yoursite.com/2020/05/20/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%AF%8F%E4%B8%AA%E5%85%83%E9%9F%B3%E5%8C%85%E5%90%AB%E5%81%B6%E6%95%B0%E6%AC%A1%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2020/05/20/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%AF%8F%E4%B8%AA%E5%85%83%E9%9F%B3%E5%8C%85%E5%90%AB%E5%81%B6%E6%95%B0%E6%AC%A1%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-05-20T13:35:00.000Z</published>
    <updated>2020-05-20T13:35:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ ，在子字符串中都恰好出现了偶数次。</p><p>示例 1：</p> <pre><code class="hljs plain">输入：s &#x3D; &quot;eleetminicoworoep&quot;输出：13解释：最长子字符串是 &quot;leetminicowor&quot; ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。</code></pre><p>示例 2：</p><pre><code class="hljs 输入：s">输出：5解释：最长子字符串是 &quot;leetc&quot; ，其中包含 2 个 e 。</code></pre><pre><code class="hljs plain">示例 3：&#96;&#96;&#96;输入：s &#x3D; &quot;bcbcbc&quot;输出：6解释：这个示例中，字符串 &quot;bcbcbc&quot; 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 5 x 10^5</code></li><li><code>s</code> 只包含小写英文字母。</li></ul><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts</a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这道题目我拿到手上第一个想法就是动态规划。如果你也跟我一样的想法，那就说明你的思路到目前是对的。来，让我们重温一下动态规划的做题思路：</p><ul><li>建立数组</li><li>创建状态转化方程</li><li>遍历得出最终答案</li></ul><p>第一步很容易想到，因为是一个字符串，所以我们可以建立一个一维数组来记录字符串的长度。然后接下来是最难的地方：如何记录最长的字符串？如何进行状态转换？哪一个是最终答案？这几个问题解决了，也就解决这道题了。接下来我一步步说。</p><ol><li>首先我们的重点放在，如何进行动态转换。这就涉及两个问题：记录已遍历的字符串的信息；增加一个字符后转换的信息。这是动态规划题目的重点，我们要从题目的特殊性入手。</li><li>从这道题我们可以看到是求元音是偶数，每个元音都必须是偶数。我们假设字符串从 i 到 j 位之间是偶数，那么 0 到 i-1 ，和 0 到 j 的各个元音的奇偶性是一样的。为什么？偶数+偶数=偶数，奇数+偶数=奇数，而 i 到 j 是偶数，那么0到i-1和0到j奇偶性肯定一致。能够想到这个点后面就比较顺畅了。</li><li>现在我们知道最长字符串的特征了，那我们要做的就是，当遍历到第i位时，如何找到奇偶性和他相同且最靠前的字符串？假如元音只有a，那我们只需要记录两个位置：a是偶数的位置最小值和a是奇数的位置最小值。当我们不断遍历字符串时，根据遍历的字符得到已经遍历的字符串的a的奇偶性，再减去对应的a‘的奇偶性位置最小值就可以得到最长的字符串了。同样的道理，我们只需要把情况扩展到5个元音，也就是有2的5次方个最小值位置要记录，所以我们只需要建立一个数组来记录这些最小值，然后不断更新字符串的奇偶性即可。</li><li>最后在遍历过程中不断更新最大值。把上面的思路用代码表现出来，就可以了。</li></ol><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> kotlin.math.max<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findTheLongestSubstring</span><span class="hljs-params">(s: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;        <span class="hljs-keyword">var</span> num = <span class="hljs-number">0</span> <span class="hljs-comment">//记录最长符合条件字符串的最大值</span>        <span class="hljs-keyword">var</span> status = <span class="hljs-number">0</span> <span class="hljs-comment">// 记录当前状态</span>        <span class="hljs-comment">// 记录每一种状态的位置最小值</span>        <span class="hljs-keyword">val</span> array = Array(<span class="hljs-number">1</span> shl <span class="hljs-number">5</span>) &#123;-<span class="hljs-number">1</span>&#125;         <span class="hljs-comment">// 0肯定符合偶数的条件，所以定为0，-1表示还没找到位置最小值</span>        array[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>        <span class="hljs-comment">//遍历字符串并更新状态</span>        <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> s.indices)&#123;            <span class="hljs-keyword">when</span>(s[i])&#123;                <span class="hljs-string">'a'</span> -&gt; status = status xor <span class="hljs-number">1</span>                <span class="hljs-string">'e'</span> -&gt; status = status xor (<span class="hljs-number">1</span> shl <span class="hljs-number">1</span>)                <span class="hljs-string">'i'</span> -&gt; status = status xor (<span class="hljs-number">1</span> shl <span class="hljs-number">2</span>)                <span class="hljs-string">'o'</span> -&gt; status = status xor (<span class="hljs-number">1</span> shl <span class="hljs-number">3</span>)                <span class="hljs-string">'u'</span> -&gt; status = status xor (<span class="hljs-number">1</span> shl <span class="hljs-number">4</span>)            &#125;            <span class="hljs-comment">//如果前面已经有对应的状态出现，那么就减去得到长度，如果没有就把当前位置放上去。记得加1，因为位置是从0开始</span>            <span class="hljs-keyword">if</span> (array[status]&gt;=<span class="hljs-number">0</span>)&#123;                num = max(num,i+<span class="hljs-number">1</span>-array[status])            &#125;<span class="hljs-keyword">else</span>&#123;                array[status] = i+<span class="hljs-number">1</span>            &#125;        &#125;        <span class="hljs-comment">//最后返回最大长度</span>        <span class="hljs-keyword">return</span> num    &#125;&#125;</code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>我做这道题的时候有点太局限于动态规划的思路，一开始就把数组建立好了，然后就一直在如何记录已遍历字符串的信息上面死磕，其实这样是不好的。数组怎么创建要放在分析题目后去具体建立，不能一开始就限制了思维。然后根据题目的特殊性去做好<strong>状态转换</strong>这个点。知道怎么转换状态了，后面的就非常流畅了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ ，在子字符串中都恰
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法：逆转链表</title>
    <link href="http://yoursite.com/2020/05/19/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E9%80%86%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/05/19/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E9%80%86%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2020-05-19T11:30:00.000Z</published>
    <updated>2020-05-19T11:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>反转一个单链表。</p><p>示例:</p><pre><code class="hljs plain">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre><p>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list</a></p></blockquote><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>这道题是经典链表题目，可以用迭代和递归两种不同的思路来进行解决</p><h4 id="解答一：使用迭代"><a href="#解答一：使用迭代" class="headerlink" title="解答一：使用迭代"></a>解答一：使用迭代</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>这个方法要使用到三个指针，第一个指向前一个节点，第二个指向当前节点，第三个指向下一个节点。每次把当前节点的next指针指向前一个节点，然后把三个指针往后移动，重复直到完成逆转。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Example:</span><span class="hljs-comment"> * var li = ListNode(5)</span><span class="hljs-comment"> * var v = li.`val`</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * class ListNode(var `val`: Int) &#123;</span><span class="hljs-comment"> *     var next: ListNode? = null</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head: <span class="hljs-type">ListNode</span>?)</span></span>: ListNode? &#123;        <span class="hljs-keyword">if</span> (head==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>        <span class="hljs-keyword">if</span> (head.next==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head        <span class="hljs-keyword">var</span> pre : ListNode? = <span class="hljs-literal">null</span>        <span class="hljs-keyword">var</span> current : ListNode? = head        <span class="hljs-keyword">var</span> next : ListNode? = head.next        <span class="hljs-keyword">while</span> (next!=<span class="hljs-literal">null</span>)&#123;            <span class="hljs-keyword">val</span> temp : ListNode? = next.next            current?.next = pre            pre = current            current = next            next = temp        &#125;        current?.next = pre        <span class="hljs-keyword">return</span> current    &#125;&#125;</code></pre><h4 id="解答二：使用递归"><a href="#解答二：使用递归" class="headerlink" title="解答二：使用递归"></a>解答二：使用递归</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>递归相比迭代思维比较容易想一点，代码也比较简单。但是会占用更多的空间。我们可以假设链表分为两段，前一段已经逆转完成，后一段递归进行逆转，然后把后一段的指针指向前一段即可</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Example:</span><span class="hljs-comment"> * var li = ListNode(5)</span><span class="hljs-comment"> * var v = li.`val`</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * class ListNode(var `val`: Int) &#123;</span><span class="hljs-comment"> *     var next: ListNode? = null</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head: <span class="hljs-type">ListNode</span>?)</span></span>: ListNode? &#123;        <span class="hljs-keyword">return</span> point(<span class="hljs-literal">null</span>,head)    &#125;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">point</span><span class="hljs-params">(pre:<span class="hljs-type">ListNode</span>?,current:<span class="hljs-type">ListNode</span>?)</span></span>:ListNode?&#123;        <span class="hljs-keyword">if</span> (current==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> pre        <span class="hljs-keyword">val</span> next = current.next        current.next = pre         <span class="hljs-keyword">return</span> point(current,next)&#125;&#125;</code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>刚开始做的时候在指针这一块出现了一点小问题，在考虑是用几个指针，如何进行迭代等。这道题难度不高，但是要熟练掌握两种不同做法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;反转一个单链表。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs plain&quot;&gt;输入: 1-&amp;gt;2-&amp;gt;
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Intent-Filer匹配规则解析</title>
    <link href="http://yoursite.com/2020/04/21/Android/Android%E4%B8%AD%E7%9A%84Intent-Filer%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2020/04/21/Android/Android%E4%B8%AD%E7%9A%84Intent-Filer%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%E8%A7%A3%E6%9E%90/</id>
    <published>2020-04-20T16:00:00.000Z</published>
    <updated>2020-04-21T09:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们都知道，活动的启动方式有两种：一种是显示启动，或者很简单，指定一个活动的class就可以了；另外一种就是隐式启动，这种要指定action，category，data信息，例如我们在启动系统相机的时候。看一下代码：</p><pre><code class="hljs java">Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-string">"android.media.action.IMAGE_CAPTURE"</span>);                intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri);                startActivityForResult(intent,<span class="hljs-number">1</span>);</code></pre><p>其中的”android.media.action.IMAGE_CAPTURE”就是相机的action，这样就可以启动相机了。<br>隐式启动我们在平时也用的比较少，对于自己应用中的Activity都是直接显示启动了。那什么时候用到隐式启动呢？一般是在启动别的应用的activity的时候，例如上面讲到的相机。<br>上面讲到的action，category，data就是intent-filer，也就是过滤器，筛选要启动的activity。<br>intentFiler有什么用？就像给自己上个标签。例如，你给自己上个标签是大学生，那么，当说学生出来，欸那么就匹配到你了。这个就是intentfiler的作用。用于筛选匹配。<br>那么这三个action，category，data究竟是什么？他们的具体匹配规则又是什么样的？上面讲到intentFiler是用于启动别的应用，有哪些常用的intentfiler可以使用？接下来我们就来看看。</p><h1 id="intentFiler的结构"><a href="#intentFiler的结构" class="headerlink" title="intentFiler的结构"></a>intentFiler的结构</h1><p>前面讲到intentFiler包含三个：action，category，data，让我看一下代码熟悉一下：</p><pre><code class="hljs java">&lt;intent-filter&gt;                &lt;action android:name=<span class="hljs-string">"huan"</span>/&gt;                &lt;category android:name=<span class="hljs-string">"android.intent.category.DEFAULT"</span>/&gt;            &lt;/intent-filter&gt;</code></pre><p>另外包括我们最熟悉的：</p><pre><code class="hljs java">&lt;intent-filter&gt;                &lt;action android:name=<span class="hljs-string">"android.intent.action.MAIN"</span> /&gt;                &lt;category android:name=<span class="hljs-string">"android.intent.category.LAUNCHER"</span> /&gt;            &lt;/intent-filter&gt;</code></pre><p>这三个分别表示不同的意义。你想要启动什么样的activity就通过设置这些属性来启动到对应的activity。当我们自己设置intentFiler的时候也要注意他的意义性，虽然很多可以随便设置，但是就像变量名称一样，不要随便起。</p><h1 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h1><p>action是最简单也是最常用的。</p><ul><li>意义：这个参数表示启动这个活动要干嘛。例如上面相机的是android.media.action.IMAGE_CAPTURE，很明显就是拍照功能。action的本质也是一个字符串，匹配就必须每个字符都一样，包括大小写。上面说过，虽然可以随便写这个字符串，但是要有意义。</li><li>匹配规则：action的匹配规则也很简单，Intent中的action和intentFilter中的任意一个action匹配，那么匹配成功。但是如果Intent中的action是空的，那么匹配失败。<h1 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h1>这个参数平时用得比较少，一般在一些比较特殊的情况才会用到</li><li>意义：这个参数平常使用的意义是表示实现这个action动作的类别，也就是可以响应这个Intent的组件类别。例如上面的category android:name=”android.intent.category.LAUNCHER”，表示这个action将会在顶级执行，什么意思呢？就是我们每次打开应用都会打开的第一个activity。</li><li>匹配规则：可以设置多个category。但是intent中的每一个category都必须和intentFilter中的其中一条category匹配才能匹配成功。</li><li>注意：给activity设置intentFilter的时候，如果没有其他的category，必须设置category android:name=”android.intent.category.DEFAULT”这个category。原因是startActivity或者starActivityForResult这两个方法执行的时候，如果intent中没有category的话，那么就会自动加上”android.intent.category.DEFAULT”这个category。<h1 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h1>data是三个中最复杂的一个，顾名思义，这个参数就是用来传递数据的。data不同于前面两个，他由两部分组成：Uri+mimeType.<br>很多读者可能还不怎么了解Uri这个东西，可以通过这个<a href="https://www.jianshu.com/p/7690d93bb1a1" target="_blank" rel="noopener">Android URI总结</a>简单了解一下Uri。这里就不展开了。我们先来看看data的组成：<pre><code class="hljs java">&lt;data android:scheme=<span class="hljs-string">""</span>                    android:host=<span class="hljs-string">""</span>                    android:port=<span class="hljs-string">""</span>                    android:path=<span class="hljs-string">""</span>                    android:pathPattern=<span class="hljs-string">""</span>                    android:pathPrefix=<span class="hljs-string">""</span>                    android:mimeType=<span class="hljs-string">""</span>/&gt;</code></pre>data一共由7个参数组成，一起来看看分别是什么意思：</li><li>scheme：这个表示uri的模式，有最熟悉的http：//这就是一种模式，另外安卓中还有比较常见的两种是：content：//和file：//。有学过ContentProvider的读者应该对content模式就很熟悉了。</li><li>host，port：host是主机，port是端口号，这两个合称authority。例如<a href="http://www.baidu.com这个应该就很熟悉了吧。在ContentProvider中表示哪一个contentProvider。" target="_blank" rel="noopener">www.baidu.com这个应该就很熟悉了吧。在ContentProvider中表示哪一个contentProvider。</a></li><li>path，pathPattern，pathPrefix：这三个表示路径信息。一是完整的路径，二是可以用通配符来表示例如image/*，三是路径的前缀。</li><li>mimeType：这个表示媒体类型。例如image/jpeg</li></ul><p>讲完他的结构后，有的读者可能会发现，这个data不就是一个地址+文件类型吗？是的，uri本身就是地址的意思。我们平时什么时候用到data呢？举个例子，我们调用相机拍照并存储到指定的文件夹，那么怎么让相机知道地址呢？就是data了，我们通过intent启动相机，并把地址放在data传输过去。这里的uri还涉及到安卓版本的影响有所不用，有兴趣的读者可以去了解一下。</p><p>那么，data的匹配规则是怎么样的呢？<br>和action是一样的，要求intent中必须要有data，而且和intentFilter中的一个相匹配就可以匹配成功。</p><ul><li>注意：如果在intentFilter中的data没有设置uri，那么默认的schme就是content和file。<h1 id="设置intentFilter"><a href="#设置intentFilter" class="headerlink" title="设置intentFilter"></a>设置intentFilter</h1>看完了上面知道intentFilter中的三个参数怎么去匹配了，那怎么给活动设置intentFilter，怎么给intent传输参数知道吗？这个比较简单也简单讲一下：</li></ul><p>给活动设置intentFilter比较简单，只要在AndroidManifest中设置就可以了，看示例代码：</p><pre><code class="hljs java">&lt;activity android:name=<span class="hljs-string">".MainActivity"</span>&gt;            &lt;intent-filter&gt;                &lt;action android:name=<span class="hljs-string">"android.intent.action.MAIN"</span> /&gt;                &lt;category android:name=<span class="hljs-string">"android.intent.category.LAUNCHER"</span> /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;</code></pre><p>给intent设置参数也不难，一个一个来看：</p><ul><li>action：可以在新建Intent对象的时候顺便写进去，例如：<code>Intent intent = new Intent(&quot;android.intent.action.GET_CONTENT&quot;);</code>或者调用Intent的setAction方法：<code>intent.setAction(&quot;android.intent.action.GET_CONTENT&quot;);</code><ul><li>caterogy：通过intent的方法<code>intent.addCategory();</code></li><li>data：这个比较特殊一点因为他有两个部分：uri和mimeType。有三个方法：其中setType和setData分别是设置mimeType和uri的。但是这两个方法都分别会清空另一个的数据。什么意思呢？例如我通过setData设置了一个uri，然后再通过setType设置一个mimeType，那么第一个的uri就会不见了，被删除了。所以就有第三个方法：<code>intent.setDataAndType</code>。这个方法接受两个参数，uri和mimeType，同时设置两个参数，就不会被清除了。<h1 id="常用的intentFiler"><a href="#常用的intentFiler" class="headerlink" title="常用的intentFiler"></a>常用的intentFiler</h1>上面讲到intentFilter主要是用来启动别的应用的，例如相机，电话，那么有什么是比较常用的呢？具体可以查看这篇博客<a href="https://blog.csdn.net/lo5sea/article/details/38308513" target="_blank" rel="noopener">android 常用URI 值得记住</a>。不懂得也可以百度或者评论区留言。<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1>我们上面讲到intentFilter可以用来筛选要启动的activity，同样对于service和broadcast也是一样，也同样可以给他们设置intentFilter来隐式启动对应的组件。而平时用的最多还是隐式启动活动，特别是在调用别的应用的活动的时候。要掌握一些常见的调用，这也是很重要的。<br>同时intentFilter的匹配规则也是很重要，熟记才不会在自己设置intentFilter的时候出错。<br>其中还有很多细节没有讲清楚，有疑问的读者可以评论区留言。<br>·<br>·<br>·</li></ul></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.jianshu.com/p/7690d93bb1a1" target="_blank" rel="noopener">Android URI总结</a><br><a href="https://www.cnblogs.com/linjiqin/archive/2011/05/28/2061396.html" target="_blank" rel="noopener">ContentProvider和Uri详解</a><br><a href="https://www.jianshu.com/p/67d99a82509b" target="_blank" rel="noopener">详解Intent</a><br>《Android开发艺术探索》任玉刚</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们都知道，活动的启动方式有两种：一种是显示启动，或者很简单，指定一个活动的class就可以了；另外一种就是隐式启动，这种要指定action
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Activity启动模式简析</title>
    <link href="http://yoursite.com/2020/04/21/Android/Android%E4%B8%ADActivity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2020/04/21/Android/Android%E4%B8%ADActivity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90/</id>
    <published>2020-04-20T16:00:00.000Z</published>
    <updated>2020-04-21T09:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平常我们启动活动的时候就是直接startActivity或许并没有注意活动的启动模式，默认情况下都是以默认的启动模式启动。但启动模式有时候是比较重要的。例如一个活动你想他只启动一次不要有多个实例，那么你可能需要把他设置为singleTask模式。所以有必要了解一下这一些启动模式。同时要注意一下，启动模式≠启动方式，启动方式是指显示启动和隐式启动，不要混淆，显示启动和隐式启动后续我会有专门的文章讲解。</p><h1 id="关于任务栈简介"><a href="#关于任务栈简介" class="headerlink" title="关于任务栈简介"></a>关于任务栈简介</h1><p>要了解启动模式，首先要了解一下关于任务栈的概念。关于任务栈的实现原理等我在这里就先不说了，这里主要简单介绍一下什么是任务栈。我们启动的活动实例都会放在一个叫做任务栈的东西里面。我们都知道栈是“后进先出”的特点。打个比方，任务栈就是一个羽毛球筒，活动实例就是一个个羽毛球，后放进去的只能先拿出来。所以当我们启动一个app的时候，就会自动创建一个任务栈，然后我们就往里面丢活动实例。当我们按返回销毁活动的时候，这些活动就依次从任务栈里面出来。当然，一个app可以拥有多个任务栈，例如使用singleInstence启动的活动就是在一个独立的任务栈中。了解完任务栈的概念，接下来就可以来看看活动的四种启动模式。</p><h1 id="解析Activity的四种启动模式"><a href="#解析Activity的四种启动模式" class="headerlink" title="解析Activity的四种启动模式"></a>解析Activity的四种启动模式</h1><h3 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h3><p>这种是标准启动模式，默认就是这种启动模式。每次启动这种启动模式的活动的时候都会创建一个新的实例放入栈中，不管栈中是否已经存在相同的实例。这也是最容易理解的。</p><h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h3><p>顾名思义，栈顶是单一实例的。什么意思呢。假设你现在启动一个ActivityA，但是这个时候已经存在一个ActivityA实例在栈顶，那么这个时候，就不会创建新的实例。但是如果，在非栈顶存在相同的实例，还是会创建新的实例的。例如，现在栈中的活动是 ABC，A处于栈顶。然后此时启动A，是不会再创建一个A活动出来，而是执行A的onNewIntent方法；但是如果此时启动C活动，由于栈顶是A不是C，那么还是会创建一个新的C实例出来，此时的栈情况就是CABC。</p><h3 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h3><p>单一任务模式。这个模式的意思是，在该活动的启动栈中，只能存在单一实例，不管是否位于栈顶。与其他启动模式不同的是，这个启动模式可以指定栈去启动。例如现在有一个栈Main，但是你可以给活动A指定一个栈名dev，那么启动A的时候就会创建一个栈叫做dev。所以singleTask的意思就是，当你启动一个启动模式为singleTask的活动的时候，如果栈中没有相同的实例，那么就会创建一个新的实例放入栈中；如果指定栈中存在相同的实例，例如栈中有ABC，然后你启动B，那么这个时候不会去创建新的B实例，而是把B放到栈顶，并把A顶出去，再执行B的onNewIntent方法，此时栈的情况就是BC。<br>细心的读者会发现“顶出去”。是的，我们都知道栈是后进先出的特点，例如你往筒里放了3个羽毛球，那你想要拿到中间那个羽毛球，是不是只能先把上面那个抽出来呢，同样的道理，要想把B提到栈顶，那么必须把A顶出来。可能会有很多读者误以为启动后是BAC，但其实是BC，因为A得先出栈，B才能出来。同理，如果栈中是ADFBC，这个启动B，也是BC，上面的全部被出栈了。</p><h3 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h3><p>单例模式。这个是singleTask的强化版本。他会自己新建一个栈并把这个新的实例放进去，而且这个栈只能放这个活动实例。所以当重复启动这个活动的时候，只要他存在，都是调用这个活动onNewIntent方法并切换到这个栈中，并不会去创建新的实例。</p><h1 id="设置启动模式的两种方法"><a href="#设置启动模式的两种方法" class="headerlink" title="设置启动模式的两种方法"></a>设置启动模式的两种方法</h1><p>了解了活动的四种启动模式，接下来看看如何给他指定启动模式。</p><h3 id="静态设置"><a href="#静态设置" class="headerlink" title="静态设置"></a>静态设置</h3><p>静态设置就是在AndroidManifest中给具体活动设置启动模式。通过给活动指定launchMode参数来设置启动模式。例如：</p><pre><code class="hljs java">&lt;activity android:name=<span class="hljs-string">".MainActivity"</span>           android:launchMode=<span class="hljs-string">"singleInstance"</span>/&gt;</code></pre><h3 id="动态设置"><a href="#动态设置" class="headerlink" title="动态设置"></a>动态设置</h3><p>动态设置是在启动活动的时候再指定启动模式，例如：</p><pre><code class="hljs java">Intent intent = <span class="hljs-keyword">new</span> Intent();intent.setClass(<span class="hljs-keyword">this</span>,SecondActivity<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);startActivity(intent);</code></pre><p>可以看到我们通过intent.addFlags这个方法来指定启动模式，这个方法传入一个参数来指定启动模式，其他的参数有：</p><ul><li>FLAG_ACTIVITY_NEW_TASK：singleTask模式</li><li>FLAG_ACTIVITY_SINGLE_TOP：singleTop模式</li><li>FLAG_ACTIVITY_CLEAR_TOP:清除该活动上方的所有活动。一般和singleTask一起使用。但是如果你的启动模式是standard，那么这个活动连他之上的所有活动都会被出栈再创建一个新的实例放进去。例如现在栈中是ABCD，以FLAG_ACTIVITY_CLEAR_TOP+standard模式启动C的时候，首先清理掉ABC，是的，C也会被清理，然后再创建一个新的C放进去，执行之后就是CD。<h1 id="特别注意的坑"><a href="#特别注意的坑" class="headerlink" title="特别注意的坑"></a>特别注意的坑</h1><h3 id="singleInstance返回任务栈"><a href="#singleInstance返回任务栈" class="headerlink" title="singleInstance返回任务栈"></a>singleInstance返回任务栈</h3>现在模拟一个场景：现在有三个活动 A,B,C。A和C的启动模式都是standard，B的启动模式是singleInstance。先启动A，再启动B，然后再启动C。这个时候问题来了，如果我这个时候按下返回键，是回到B吗？答案是回到A。再按一下呢，返回桌面吗？答案是回到B，再按一下再回到桌面。其实不难理解。我们都知道singleInstance会创建一个独立的栈，当我们启动A的时候，A位于栈First中，启动B的时候，就会创建一个栈Second并把B实例放进去。这个时候再启动C，就会切换到栈FIrst，因为singleInstance创建的栈只能放一个，所以C会放到栈First中，当按下返回的时候，栈First中的活动就会依次出栈，直到全部出完，才会切换到栈Second中。所以要注意这个点。<h3 id="singleTask多任务栈启动问题"><a href="#singleTask多任务栈启动问题" class="headerlink" title="singleTask多任务栈启动问题"></a>singleTask多任务栈启动问题</h3>这个问题和上面singleTop的本质是一样的。模拟一个场景：现在有两个栈：First：ABC；Second：QWE。栈First位于前台，栈Second位于后台。A位于栈顶。这个时候以singleTask的模式启动W，会发生什么样的情况呢？首先会切换到栈Second，再把Q出栈，W提到栈顶，并执行W的onNewIntent方法。这个时候按返回键就会把Second栈中的活动依次出栈，全部出完后才会切换到栈First。<h3 id="singleTask的TaskAffinity与allowTaskReparenting参数"><a href="#singleTask的TaskAffinity与allowTaskReparenting参数" class="headerlink" title="singleTask的TaskAffinity与allowTaskReparenting参数"></a>singleTask的TaskAffinity与allowTaskReparenting参数</h3>前面我们讲到给singleTask模式指定要启动的任务栈的名字，怎么指定呢？可以在AndroidManifest中指定相关的属性，如下：<pre><code class="hljs java">&lt;activity android:name=<span class="hljs-string">".Main2Activity"</span>            android:launchMode=<span class="hljs-string">"singleTask"</span>            android:taskAffinity=<span class="hljs-string">"com.huan"</span>            android:allowTaskReparenting=<span class="hljs-string">"true"</span>/&gt;</code></pre>这里解释一下这两个参数</li><li>taskAffinity：指定任务栈的名字。默认的任务栈是包名，所以不能以包名来命名。</li><li>allowTaskReparenting：这个参数表示可不可以切换到新的任务栈，通常设置为true并和上面的参数一起使用。<br>我前面讲到可以给singleTask的活动指定一个栈名，然后启动的时候，就会切换到那个栈，并把新的活动放进去。但是如果设置allowTaskReparenting参数为false的话是不会切换到新的栈的。这个参数的意思是可不可以把新的活动转移到新的任务栈。简单点来说：当我们启动一个singleTask活动的时候，这个活动还是留在启动他的活动的栈中的。但是我们指定了taskAffinity这个参数，或者启动的活动是别的应用中的活动，那么就会创建一个新的任务栈。如果allowTaskReparenting这个参数是true的话，那么这个活动就会放到那个新的任务栈中。这样应该就可以明白了。所以这两个经常是配套一起使用的。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> 活动的启动模式有四种，每种的功能都不一样，可以结合具体需要去使用，但是最重点还是要了解他的实现原理，栈中是怎么变化的，这个是比较重要的。了解这个之后那些特殊情况也就很容易理解了。<br> 上面我讲的只是简单的使用，关于活动启动模式还有很多要了解。后续可能会解析一下，读者也可以自行去深度了解。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《Android开发艺术探索》 –任玉刚</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;平常我们启动活动的时候就是直接startActivity或许并没有注意活动的启动模式，默认情况下都是以默认的启动模式启动。但启动模式有时候是
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android使用系统相机进行拍照</title>
    <link href="http://yoursite.com/2020/04/21/Android/Android%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9B%B8%E6%9C%BA%E8%BF%9B%E8%A1%8C%E6%8B%8D%E7%85%A7/"/>
    <id>http://yoursite.com/2020/04/21/Android/Android%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9B%B8%E6%9C%BA%E8%BF%9B%E8%A1%8C%E6%8B%8D%E7%85%A7/</id>
    <published>2020-04-20T16:00:00.000Z</published>
    <updated>2020-04-21T09:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在日常的开发中有时候会遇到需要用到相机的需求，而相机也是很常用的东西，例如扫二维码啊拍照上传啊等等。这里我不讲像qq那样自定义很强的拍照功能（事实上我也不会），讲个最简单的调用系统相机拍照并储存</p><h1 id="调用系统相机步骤"><a href="#调用系统相机步骤" class="headerlink" title="调用系统相机步骤"></a>调用系统相机步骤</h1><p>这里我通过一个简单的例子来讲这个内容。<br>我自己写了一个demo，布局很简单：</p><pre><code class="hljs java">&lt;Button        android:id=<span class="hljs-string">"@+id/button"</span>        android:layout_width=<span class="hljs-string">"wrap_content"</span>        android:layout_height=<span class="hljs-string">"wrap_content"</span>        android:layout_marginTop=<span class="hljs-string">"4dp"</span>        android:text=<span class="hljs-string">"take phone"</span>        app:layout_constraintEnd_toEndOf=<span class="hljs-string">"parent"</span>        app:layout_constraintHorizontal_bias=<span class="hljs-string">"0.281"</span>        app:layout_constraintStart_toStartOf=<span class="hljs-string">"parent"</span>        app:layout_constraintTop_toTopOf=<span class="hljs-string">"parent"</span> /&gt;    &lt;ImageView        android:id=<span class="hljs-string">"@+id/imageView"</span>        android:layout_width=<span class="hljs-string">"wrap_content"</span>        android:layout_height=<span class="hljs-string">"wrap_content"</span>        android:layout_marginTop=<span class="hljs-string">"29dp"</span>        app:layout_constraintEnd_toEndOf=<span class="hljs-string">"parent"</span>        app:layout_constraintStart_toStartOf=<span class="hljs-string">"parent"</span>        app:layout_constraintTop_toBottomOf=<span class="hljs-string">"@+id/button"</span>        app:srcCompat=<span class="hljs-string">"@mipmap/ic_launcher_round"</span> /&gt;</code></pre><p>就是一个按钮点击弹起相机，然后一个imageView显示拍到的照片。</p><p>·</p><p>接下来我想一下调用的整个过程我们需要做什么：<br>首先弹起相机肯定要跳到相机这个应用，那么就必须通过隐性启动相机的活动。<br>然后当我们返回应用的时候，还要将照片显示，所以这里就要用到startActivityForResult这个方法。<br>其次，我们拍照之后肯定要进行储存的，那么就涉及到文件的操作。<br>涉及到内存的操作就肯定要和权限打交道，所有还有权限相关的内容。<br>最后还有一个问题就是，相机拍完照是要储存照片的，所以我们要给他一个地址uri，但是可不可以直接把地址当成参数发过去呢？这里就要用到特殊的内容提供器FileProvider。<br>上面就是调用相机要用到的内容，虽然用的都很浅，但是都会涉及到。接下来看看具体怎么实现。看看Activity中的onCreate的代码：<br>·</p><pre><code class="hljs java">   <span class="hljs-keyword">private</span> Uri imageUri;<span class="hljs-keyword">private</span> ImageView imageView;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;       <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);       setContentView(R.layout.activity_main);       imageView = findViewById(R.id.imageView);       Button button = findViewById(R.id.button);       button.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;           <span class="hljs-meta">@Override</span>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;                      <span class="hljs-comment">//创建一个File对象。getExternalCacheDir()获取应用的缓存目录，outputImage.jpg是照片名称</span>               File outputImage = <span class="hljs-keyword">new</span> File(getExternalCacheDir(),<span class="hljs-string">"outputImage.jpg"</span>);               <span class="hljs-keyword">try</span>&#123;                               <span class="hljs-comment">//创建一个空文件            </span>                   outputImage.createNewFile();               &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;                   e.printStackTrace();               &#125;                              <span class="hljs-comment">//不同的安卓版本对用不同的获取Uri的方法</span>               <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT&gt;=<span class="hljs-number">24</span>)&#123;                   imageUri =FileProvider.getUriForFile(MainActivity.<span class="hljs-keyword">this</span>,<span class="hljs-string">"huan"</span>,outputImage);               &#125;<span class="hljs-keyword">else</span>&#123;                   imageUri = Uri.fromFile(outputImage);               &#125;               <span class="hljs-comment">//启动相机的对应Activity</span>               Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-string">"android.media.action.IMAGE_CAPTURE"</span>);               intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri);               startActivityForResult(intent,<span class="hljs-number">1</span>);           &#125;       &#125;);</code></pre><p>我们来看看这里的代码：前面的代码很简单就是控件的初始化。<br>我们知道照片是要放文件夹得，所以这里要创建一个File对象，指定文件的路径以及名字。这里路径为什么要用getExternalCacheDir()呢？因为每个应用都有对应得缓存目录，访问这些目录得时候不用访问内存权限，这样得话就可以省去需求权限得步骤啦。这个目录在/scare/Android/data/<package name>/cache。</p><p>然后我们再创建一个空的文件夹。这里如果已经有照片了的话例如我们第二次拍照的时候，那么就不会创建新的空文件夹了。直到储存的时候才会被替换掉。</p><p>然后我们刚才讲到，拍到的图片要在我们的应用中展示，那么就必须用到内容提供器。这里用到FileProvider来获取uri，关于provider我在下文有讲到可以<a href="#jump">点击跳转</a><br>如果是低于4.4版本的安卓就用Uri.fromFile(outputImage);方法可以获取到uri</p><p>再通过隐式启动相机activity可以打开相机了。这里系统相机的action是android.media.action.IMAGE_CAPTURE，相机储存路径的参数名字是MediaStore.EXTRA_OUTPUT，并把uri传输进去。</p><p>好了这样就完成了拍照并把照片储存的步骤了。接下来还差什么？对了，把照片显示出来。现在在内存中已经有这个照片了，而且uri也知道，所以就很容易了，看代码：</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> requestCode, <span class="hljs-keyword">int</span> resultCode, @Nullable Intent data)</span> </span>&#123;    <span class="hljs-keyword">if</span> (requestCode == <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">if</span> (resultCode == RESULT_OK)            <span class="hljs-keyword">try</span> &#123;                Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(imageUri));                imageView.setImageBitmap(bitmap);            &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;                e.printStackTrace();            &#125;    &#125;&#125;</code></pre><p>我们刚才使用startActivityForResult来启动活动的，所以就要重写这个方法来显示图片了。这里首先判断是哪个启动命令，然后再判断是否成功启动，再BitmapFactory.decodeStream这个方法来获取bitmap，再把bitmap显示出来就行了。BitmapFactory.decodeStream这个方法需要一个流，可以通过getContentResolver().openInputStream这个方法来开启一个流。</p><p>到此整个流程就解决了。</p><h1 id="FileProvider"><a href="#FileProvider" class="headerlink" title="FileProvider"></a><span id = "jump">FileProvider</span></h1><p>FileProvider是一个特殊的内容提供器，可以把一个file开头的uri改成content开头的，例如：file://uri -&gt; content://uri。那为什么要这么做呢？这里简单讲一下：<br>这个是因为在Android 7.0之后，官方禁止直接把一个真实路径的uri传输到别的应用，而我们要把地址送给相机，所以就会出现问题了。详细可以查阅这篇博客：<a href="https://blog.csdn.net/lmj623565791/article/details/72859156" target="_blank" rel="noopener">Android 7.0 行为变更 通过FileProvider在应用间共享文件吧</a></p><p>既然是内容提供器那么肯定是要进行注册的：</p><pre><code class="hljs java">&lt;provider            android:name=<span class="hljs-string">"android.support.v4.content.FileProvider"</span>            android:authorities=<span class="hljs-string">"huan"</span>            android:exported=<span class="hljs-string">"false"</span>            android:grantUriPermissions=<span class="hljs-string">"true"</span>&gt;            &lt;meta-data                android:name=<span class="hljs-string">"android.support.FILE_PROVIDER_PATHS"</span>                android:resource=<span class="hljs-string">"@xml/file_paths"</span> /&gt;        &lt;/provider&gt;</code></pre><p>这里的authorities参数必须和前面的getUriForFile方法的第二个参数保持一致，同个内容提供器的authorities肯定要一样啦。grantUriPermissions参数一定要是true，这个的大概意思就是给他的所有元素授权可以被访问，在FileProvider中这个参数必须是true（这也是为什么在4.4一下版本的安卓无法使用的原因之一，有兴趣可以去了解一下）export这个参数表示可不可以给其他的应用共享，这里要设置为false。&lt;meta-data这个是配置我们可以访问的文件路径，@xml/file_paths这个就是表示什么文件可以被访问，当然要建一个这个文件。看代码：</p><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?&gt;&lt;paths xmlns:android=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>&gt;    &lt;external-path        name=<span class="hljs-string">"my_image"</span>        path=<span class="hljs-string">"/"</span>/&gt;&lt;/paths&gt;</code></pre><p>&lt;external-path这个就是表示可以被访问的路径，name是后面映射用到的，可以自己随便起，我这里用一横杆表示整个目录可以被访问。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>调用系统相机的功能虽然不难，代码也不多，但是其中的零碎知识很多，零零散散，还是要注意的。特别是关于低高配的安卓版本问题还是要特别注意一下。</p><p>·<br>·<br>·<br>·</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《第一行代码》郭霖<br><a href="https://blog.csdn.net/lmj623565791/article/details/72859156" target="_blank" rel="noopener">Android 7.0 行为变更 通过FileProvider在应用间共享文件吧</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们在日常的开发中有时候会遇到需要用到相机的需求，而相机也是很常用的东西，例如扫二维码啊拍照上传啊等等。这里我不讲像qq那样自定义很强的拍照
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Activity生命周期简析</title>
    <link href="http://yoursite.com/2020/04/21/Android/Android%E5%AE%89%E5%8D%93%E4%B8%ADActivity%E6%B4%BB%E5%8A%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2020/04/21/Android/Android%E5%AE%89%E5%8D%93%E4%B8%ADActivity%E6%B4%BB%E5%8A%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2020-04-20T16:00:00.000Z</published>
    <updated>2020-04-21T09:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Activity作为安卓四大组件之一，平常我们接触得最多得也是activity，所以很有必要详细了解一下他的详细生命周期。这篇文章定位是有一点安卓基础的，所以还完全不了解的可以先去学习一下activity。这篇文章主要是讲活动的生命周期。<br>活动的生命周期，人有胎儿期，青春期，老年期一样，活动同样有他的各种生命状态。我们出生会哭，进入成年期会有成人礼。活动也一样，每进入一个状态都会回调相应的方法。对于我们来说，活动周期就是活动会在活动具体哪个时候会回调哪一些方法，然后我们可以重写这一些方法，来实现我们的功能。所以我们得具体了解究竟什么时候调用什么方法。例如在onCreate方法中初始化，在destroy中释放内存等等。<br>那接下来就看看他的具体生命周期。</p><h1 id="活动的状态"><a href="#活动的状态" class="headerlink" title="活动的状态"></a>活动的状态</h1><p>首先得了解一下活动的状态。我个人的理解把活动分为四个状态：后台状态，暂停状态，运行状态和销毁状态。</p><ol><li><p>停止状态：这个状态表示活动未进入前台，我们看不到也无法交汇。切换界面活动都会在后台。如果内存紧张的话有可能被回收。就像我们有时候打游戏切换到微信回了一下信息，回来的时候卧槽怎么把我游戏退了，就是这样。</p></li><li><p>运行状态：这个不用多讲，当你在交汇的这个活动就是运行状态。</p></li><li><p>暂停状态：当弹出一个提示框，我们回发现无法与原来的界面交汇了，就是只能点那个提示框。当一个活动位于栈顶，也就是你看的见他，但是你没办法操作他，这个时候就是属于暂停状态。</p></li><li><p>销毁状态：就是被移出栈顶的活动，马上就会被回收了。例如你退出一个应用他马上就会被杀了。</p><h1 id="常规情况下的生命周期"><a href="#常规情况下的生命周期" class="headerlink" title="常规情况下的生命周期"></a>常规情况下的生命周期</h1><h2 id="典型情况下的生命周期"><a href="#典型情况下的生命周期" class="headerlink" title="典型情况下的生命周期"></a>典型情况下的生命周期</h2><p>每个活动正常启动的话都会经历的生命周期如下图</p><pre><code class="hljs mermaid">graph TBz[活动启动]--&gt;aa[onCreate] --&gt; b[onStart]b --&gt; c[onResume]c --&gt; d[Activity运行]d--&gt;e[onPause]e--&gt;f[onStop]f--&gt;g[onDestroy]g--&gt;h[活动销毁]f--&gt;i[onRestart]i--&gt;be--&gt;c</code></pre><p>每到一个时间点都会调用相关的方法，接下来一个一个来分析一下这些方法。</p></li><li><p>onCreate：</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);    &#125;</code></pre><p>这是我们每个活动都会用到的一个方法。他在活动被创建的时候被调用，且只会调用一次。除非被destroy重新创    建。我们一般在这个方法中做一下初始化的事情。例如加载布局资源等等。细心的读者可能会注意到他有一个Bundle参数，这个参数主要是用于保存被异常销毁事的数据的，这个在后面会讲到</p></li><li><p>onStart:顾名思义这个方法表示活动正在启动，这个时候活动界面已经看的见了，但是还不能与用户交汇，简单点说就是你看得到点不了。但是一般速度很快不会让你感受到这个现象，不然就会好像卡死一样了。所以不能在这个方法中做重量级的操作，初始化什么的都放在onCreate。</p></li><li><p>onResume：这个方法表示活动显示在前台了而且也可以用了。onStart和onResume主要配合onPause和onStop方法来使用，下面会讲到。</p></li><li><p>onPause：活动被暂停的时候会调用到。例如一些弹出提示框，看得到界面但是无法进行交汇。一般执行完这个方法后紧接着就会执行onStop方法了。这个方法可以做一些动画的暂停工作等等轻量级的工作，不然弹个提示框都要卡一下用户体验也很差对吧。<br>如果没有进入onStop这个环节的话，回到原Activity的话，那么就会调用onResume这个方法了</p></li><li><p>onStop：这个方法在活动即将停止的时候调用，同样不能做重量级的工作。一般切换界面，如果内存足够没有被杀死的话，这个活动就会进入停止状态。</p></li><li><p>onRestart：当活动从停止状态回来的时候就会调用这个方法。状态和onStart其实是差不多的，只是为了区分是正常打开的还是从停止状态回来的，可以分别写不同的方法。</p></li><li><p>onDestroy：活动被销毁的时候会调用这个方法。可以做一些资源的释放什么的。但这里要特别强调的一点就是并不是所有情况下活动被销毁都会调用这个方法。例如当你按下返回键回到上个界面，这个当然是会执行这个方法。但是如果你切换到了别的应用或者回到了桌面，这个应用被后台杀死了，那么只有处于栈顶也就是这个应用最后打开的活动会执行destroy方法，其他都不会，需要特别注意一下。<br><img src="https://img-blog.csdnimg.cn/20190916205438446.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc2Njc1Mw==,size_8,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li></ol><h2 id="一些例外情况的生命周期"><a href="#一些例外情况的生命周期" class="headerlink" title="一些例外情况的生命周期"></a>一些例外情况的生命周期</h2><p>有一句话叫做用户永远不会按照你的设想去使用软件，活动也一样，总是会出现一些比较不一样的情况。这些情况活动是怎么跑的也来看看：</p><ol><li>返回桌面的时候：返回桌面其实就像切换到别的活动是一样的道理，这个时候执行的方法是：onPause –&gt; onStop。</li><li>当活动被系统回收再被打开，流程和打开一个新的活动是一样的。</li><li>打开新的活动时先执行onPause方法再启动新的活动，onStop会慢一点点执行。</li></ol><h1 id="异常情况下的生命周期"><a href="#异常情况下的生命周期" class="headerlink" title="异常情况下的生命周期"></a>异常情况下的生命周期</h1><p>这里的异常情况主要有两种：一种是放在后台被杀死了，不是我们主动去终结他的生命的，第二种是设备的配置发生了改变，例如屏幕翻转。对于这两种情况我们具体来看一下</p><h2 id="情况1-：资源相关的系统配置发生改变"><a href="#情况1-：资源相关的系统配置发生改变" class="headerlink" title="情况1 ：资源相关的系统配置发生改变"></a>情况1 ：资源相关的系统配置发生改变</h2><p>这个资源相关的系统配置怎么说呢。我们的项目目录下不是有drawable-hdpi ，drawable-mdpi，这一类的文件夹，在不同的屏幕尺寸下会获取不同的图片，就像我们手机和平板也是一样有两个不同的配置。平常中我们翻转屏幕时，屏幕尺寸就发生了变化，准确来说时屏幕的长宽比例发生了变化，那么这个时候Activity就会被重建（当然你也可以设置他不重建）。<br>细心的读者会发现，即使我的屏幕翻转了，活动重建了，可是还是保留着刚刚我操作的内容啊！例如我在输入框输入了Hello World翻转后还是Hello World，不是说活动被重建了吗，为什么这些还存在？<br>不知道还记不记得onCreate方法中有一个Bundle参数吗？没错，这个参数就是记录之前的数据的。重建的过程和平常的杀死启动活动有一些不一样，看一下：</p><pre><code class="hljs mermaid">graph TBa[Activity运行] --屏幕翻转--&gt;b[onPause,onSaveInstanceState] b--&gt; c[onStop]c--&gt;d[onDestroy]d --重新创建--&gt; e[onCreate]e--&gt;f[onRestoreInstanceState]f--&gt;g[onStart,onResume]g--&gt;h[Activity重新启动]</code></pre><p>可以看到最主要的不同就是多了onSaveInstanceState和onRestoreInstanceState这两个方法。<br>活动在这种异常的情况下被终结生命后，就会调用onSaveInstanceState方法来保存目前的数据，这个方法在onStop方法前调用，但是和onPause方法的前后关系没有必然的关系。然后作为一个Bundle参数传递给重新创建的活动。这个Bundle对象会在onCreate方法中和onRestoreInstanceState中被使用。onRestoreInstanceState这个方法主要就是把刚才的数据还原，执行的次序是在onStart之后。<br>要注意的一点是，onSaveInstanceState方法只有在活动还会被重建的时候才会被调用。例如你手动把他后台杀了，是不会调用这个方法的。</p><h2 id="资源内存不足导致活动被杀死"><a href="#资源内存不足导致活动被杀死" class="headerlink" title="资源内存不足导致活动被杀死"></a>资源内存不足导致活动被杀死</h2><p>当系统内存不足的时候，系统就会按照优先级的大小去杀死一些活动，并在后续通过上面onSaveInstanceState和onRestoreInstanceState方法来恢复数据。优先级按照状态依次是：运行状态，暂停状态，停止状态。一般最有可能是停止状态的活动被杀了。所以一些后台工作就尽量放在service中防止被杀死</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>讲了这么多的生命周期，其实我也是简单讲了我们在使用中一般会遇到的生命周期。有一些读者可能会有这个疑问：为什么我主动调用了onDestroy方法但是活动却没有被杀死？举个例子，你给一个婴儿举办成人礼，他会马上成人吗？要注意的一点就是，我们所说的这些生命周期的回调方法，本质上他们都是一样的，只是被调用的时间不用。他们只是在活动的不同时间被调用，并不是调用这个方法去推进活动的生命进行。主动销毁活动我们用到的是finish（），而不是onDestroy，要特别注意。</p><p>生命周期是活动很重要的一部分，只要了解了他的生命周期我们才可以在准确的时间给他做一些正确的事情。例如你的孩子进入了青春期，你就得跟他说好好学习不要老是想着谈恋爱对吧。我之前自己出过一个低级错误就是在onCreate方法之前使用findViewById，活动都还没创建，怎么找得到布局呢。充分了解这些生命周期后就不会犯这些低级错误了。</p><p>我也是一个安卓新手，有哪些地方写的不好还请大佬们指教</p><p>·<br>·<br>·</p><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p>《Android开发艺术探索》–任玉刚<br>《第一行代码》–郭霖</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Activity作为安卓四大组件之一，平常我们接触得最多得也是activity，所以很有必要详细了解一下他的详细生命周期。这篇文章定位是有一
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>启动页白屏解决方案</title>
    <link href="http://yoursite.com/2020/04/21/Android/Android%E5%AE%89%E5%8D%93%E5%90%AF%E5%8A%A8%E9%A1%B5%20%20%E8%A7%A3%E5%86%B3%E6%89%93%E5%BC%80%E5%BA%94%E7%94%A8%E6%98%BE%E7%A4%BA%E7%99%BD%E5%B1%8F%E6%83%85%E5%86%B5/"/>
    <id>http://yoursite.com/2020/04/21/Android/Android%E5%AE%89%E5%8D%93%E5%90%AF%E5%8A%A8%E9%A1%B5%20%20%E8%A7%A3%E5%86%B3%E6%89%93%E5%BC%80%E5%BA%94%E7%94%A8%E6%98%BE%E7%A4%BA%E7%99%BD%E5%B1%8F%E6%83%85%E5%86%B5/</id>
    <published>2020-04-20T16:00:00.000Z</published>
    <updated>2020-04-21T09:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>﻿当我们打开app的时候是不是会有一瞬间的白屏然后再进入主活动，虽然这并不会造成什么不好的后果，但是感觉用户体验就不是很好。像网易云音乐等等，打开一瞬间就显示了他们的loge，无缝衔接，没有白屏，怎么做到的呢？</p><p>一开始我的思路是这样的。可能是因为我们的主活动逻辑太多，所以加载会变慢，导致显示白屏。如果使用一个只显示一张本地图片的活动，那会不会就不会显示白屏了呢。话不多说我们尝试一下：</p><p>Activity中的代码：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 启动页，显示倾旅的logo，停顿2秒后跳转</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LunchActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);        setContentView(R.layout.activity_lunch);<span class="hljs-comment">//开启子线程进行停顿。如果在主线程停顿的话，会造成主页面卡死，所以在子线程sleep两秒后跳转</span>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">1000</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                start();                LunchActivity.<span class="hljs-keyword">this</span>.finish();            &#125;        &#125;).start();    &#125;    <span class="hljs-comment">//跳转到主页面</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>&#123;        Intent intent = <span class="hljs-keyword">new</span> Intent(LunchActivity.<span class="hljs-keyword">this</span>,MainActivity<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        startActivity(intent);    &#125;&#125;</code></pre><p>layout中的代码：</p><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?&gt;&lt;android.support.constraint.ConstraintLayout    xmlns:android=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>    xmlns:app=<span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span>    xmlns:tools=<span class="hljs-string">"http://schemas.android.com/tools"</span>    android:layout_width=<span class="hljs-string">"match_parent"</span>    android:layout_height=<span class="hljs-string">"match_parent"</span>    android:background=<span class="hljs-string">"#e74b37"</span>    tools:context=<span class="hljs-string">".LunchActivity"</span>&gt;    &lt;ImageView        android:id=<span class="hljs-string">"@+id/imageView5"</span>        android:layout_width=<span class="hljs-string">"80dp"</span>        android:layout_height=<span class="hljs-string">"80dp"</span>        app:layout_constraintBottom_toBottomOf=<span class="hljs-string">"parent"</span>        app:layout_constraintEnd_toEndOf=<span class="hljs-string">"parent"</span>        app:layout_constraintStart_toStartOf=<span class="hljs-string">"parent"</span>        app:layout_constraintTop_toTopOf=<span class="hljs-string">"parent"</span>        app:layout_constraintVertical_bias=<span class="hljs-string">"0.31"</span>        app:srcCompat=<span class="hljs-string">"@drawable/icon"</span> /&gt;&lt;/android.support.constraint.ConstraintLayout&gt;</code></pre><p>这里简单指定一个imageView来显示一张图片。并把背景设置为橘色</p><p>最后再把启动页活动设置为主活动：</p><pre><code class="hljs java">&lt;activity android:name=<span class="hljs-string">"com.example.qinglv.LunchActivity"</span>&gt;            &lt;intent-filter&gt;                &lt;action android:name=<span class="hljs-string">"android.intent.action.MAIN"</span> /&gt;                &lt;category android:name=<span class="hljs-string">"android.intent.category.LAUNCHER"</span> /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;</code></pre><p>一切想的很好，完成后打开一看，还是会白屏，怎么回事？</p><p>活动的加载都是需要时间的，比较简单的活动时间会少点，但是以然会有一瞬间的白屏。那这个白屏到底是什么？就是每个活动的背景。当打开一个活动的时候，因为还没加载出内容，所以显示的就只是背景，所以我们只需要，改变这个背景，设置为我们需要的一个logo照片即可。怎么设置呢？</p><ul><li><p>背景是在主题中指定的，首先设置一个主题，把背景改成我们要的。一般和我们的启动页保持一致，这样的话就不会看起来像两个启动页一样。也可以像网易云音乐那样，背景设置成logo，但是启动页是放广告，但是这会影响用户体验（为了收入打点广告也是可以理解的）。看代码：<br>在res-value-styles：</p><pre><code class="hljs java">&lt;style name=<span class="hljs-string">"NewAppTheme"</span> parent=<span class="hljs-string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;        &lt;!-- Customize your theme here. --&gt;        &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt;        &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt;        &lt;item name="android:windowBackground"&gt;@color/colorPrimary&lt;/item&gt;        &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt;    &lt;/style&gt;</code></pre><p>重点是这句<code>&lt;item name=&quot;android:windowBackground&quot;&gt;@color/colorPrimary&lt;/item&gt;</code><br>这里我指定的是一种颜色你们也可以指定一张图片</p></li><li><p>再给启动页活动指定主题：<br>在：AndroidManifest：</p><pre><code class="hljs java">&lt;activity android:name=<span class="hljs-string">"com.example.qinglv.LunchActivity"</span>           android:theme=<span class="hljs-string">"@style/NewAppTheme"</span>&gt;           &lt;intent-filter&gt;               &lt;action android:name=<span class="hljs-string">"android.intent.action.MAIN"</span> /&gt;               &lt;category android:name=<span class="hljs-string">"android.intent.category.LAUNCHER"</span> /&gt;           &lt;/intent-filter&gt;       &lt;/activity&gt;</code></pre><p>重点是这句<code>android:theme=&quot;@style/NewAppTheme&quot;</code></p></li></ul><p>然后再打开的时候，就会发现不会了。原本显示的白屏变成了我们设置好的图片。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿当我们打开app的时候是不是会有一瞬间的白屏然后再进入主活动，虽然这并不会造成什么不好的后果，但是感觉用户体验就不是很好。像网易云音乐等等，打开一瞬间就显示了他们的loge，无缝衔接，没有白屏，怎么做到的呢？&lt;/p&gt;
&lt;p&gt;一开始我的思路是这样的。可能是因为我们的主活动逻
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>调用系统相册选择照片</title>
    <link href="http://yoursite.com/2020/04/21/Android/Android%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%86%8C%E9%80%89%E6%8B%A9%E5%9B%BE%E7%89%87/"/>
    <id>http://yoursite.com/2020/04/21/Android/Android%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%86%8C%E9%80%89%E6%8B%A9%E5%9B%BE%E7%89%87/</id>
    <published>2020-04-20T16:00:00.000Z</published>
    <updated>2020-04-21T09:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在相册里选择图片上传也是很常见的功能了例如微信朋友圈等等。但是他们是自定义的选择器，可以选择多张图片并修改。这里我们讲一个最简单的：调用系统的相册选择一张图片并展示。另外有的读者还想到要通过相机拍照来选择图片的功能，也可以参考一下我的另一篇文章<a href="https://blog.csdn.net/weixin_43766753/article/details/101224631" target="_blank" rel="noopener">Android使用系统相机进行拍照</a></p><h1 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h1><p>这里我是通过一个简单的demo来讲解怎么去实现这个功能。首先看布局：</p><pre><code class="hljs java">&lt;Button    android:id=<span class="hljs-string">"@+id/button2"</span>    android:layout_width=<span class="hljs-string">"wrap_content"</span>    android:layout_height=<span class="hljs-string">"wrap_content"</span>    android:layout_marginTop=<span class="hljs-string">"5dp"</span>    android:layout_marginEnd=<span class="hljs-string">"52dp"</span>    android:layout_marginRight=<span class="hljs-string">"52dp"</span>    android:text=<span class="hljs-string">"choose"</span>    app:layout_constraintEnd_toEndOf=<span class="hljs-string">"parent"</span>    app:layout_constraintTop_toTopOf=<span class="hljs-string">"parent"</span> /&gt;&lt;ImageView    android:id=<span class="hljs-string">"@+id/imageView"</span>    android:layout_width=<span class="hljs-string">"wrap_content"</span>    android:layout_height=<span class="hljs-string">"wrap_content"</span>    android:layout_marginTop=<span class="hljs-string">"29dp"</span>    app:layout_constraintEnd_toEndOf=<span class="hljs-string">"parent"</span>    app:layout_constraintStart_toStartOf=<span class="hljs-string">"parent"</span>    app:layout_constraintTop_toBottomOf=<span class="hljs-string">"@+id/button"</span>    app:srcCompat=<span class="hljs-string">"@mipmap/ic_launcher_round"</span> /&gt;</code></pre><p>很简单，就是一个按钮和一个imageView。然后接下来让我们想想这个功能怎么去实现：</p><p>首先打开相册，那么肯定要通过隐式启动相册activity；然后相册返回一个路径，我们就拿这个路径把路径上对应的照片展示出来。思路挺简单的，让我们写写看：<br>首先看代码：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> Uri imageUri;    <span class="hljs-keyword">private</span> ImageView imageView;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        imageView = findViewById(R.id.imageView);        Button button1 = findViewById(R.id.button2);        button1.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;            <span class="hljs-comment">//动态申请权限</span>                <span class="hljs-keyword">if</span> (ContextCompat.checkSelfPermission(MainActivity.<span class="hljs-keyword">this</span>,Manifest.permission                        .WRITE_EXTERNAL_STORAGE)!= PackageManager.PERMISSION_GRANTED)&#123;                    ActivityCompat.requestPermissions(MainActivity.<span class="hljs-keyword">this</span>,<span class="hljs-keyword">new</span> String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,<span class="hljs-number">1</span>);                &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-comment">//执行启动相册的方法</span>                    openAlbum();                &#125;            &#125;        &#125;);     &#125;<span class="hljs-comment">//获取权限的结果</span><span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRequestPermissionsResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> requestCode, @NonNull String[] permissions, @NonNull <span class="hljs-keyword">int</span>[] grantResults)</span> </span>&#123;        <span class="hljs-keyword">if</span> (requestCode == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">if</span> (grantResults.length&gt;<span class="hljs-number">0</span>&amp;&amp;grantResults[<span class="hljs-number">0</span>] == PackageManager.PERMISSION_GRANTED) openAlbum();            <span class="hljs-keyword">else</span> Toast.makeText(MainActivity.<span class="hljs-keyword">this</span>,<span class="hljs-string">"你拒绝了"</span>,Toast.LENGTH_SHORT).show();        &#125;    &#125;<span class="hljs-comment">//启动相册的方法</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">openAlbum</span><span class="hljs-params">()</span></span>&#123;        Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-string">"android.intent.action.GET_CONTENT"</span>);        intent.setType(<span class="hljs-string">"image/*"</span>);        startActivityForResult(intent,<span class="hljs-number">2</span>);    &#125;</code></pre><p>这里先初始化控件，然后动态申请权限，因为我们要读取照片肯定是要读取内存的权限，记得在AndroidManifest中要写明权限：</p><pre><code class="hljs <uses-permission">获取权限后就打开相册选择。相册对应的action是android.intent.action.GET_CONTENT，setType(&quot;image&#x2F;*&quot;)这个方法表示把所有照片显示出来，然后开启活动。启动活动选择完照片后就会返回一个intent到onActivityResult方法中，所以接下来的主要工作就是如果获取到返回的路径。我们知道在安卓4.4以后是不能把文件的真实路径直接给别的应用的，所以返回的uri是经过封装的，所以我们要进行解析取出里面的路径。所以这里我们要进行判断安卓版本来进行不同的逻辑，先看代码：&#96;&#96;&#96;java@Override    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123;    if (requestCode &#x3D;&#x3D; 2)&#123;    &#x2F;&#x2F;判断安卓版本 if (resultCode &#x3D;&#x3D; RESULT_OK&amp;&amp;data!&#x3D;null)&#123;                if (Build.VERSION.SDK_INT&gt;&#x3D;19)                handImage(data);                else handImageLow(data);            &#125;        &#125;    &#125;&#x2F;&#x2F;安卓版本大于4.4的处理方法@RequiresApi(api &#x3D; Build.VERSION_CODES.KITKAT)    private void handImage(Intent data)&#123;        String path &#x3D;null;        Uri uri &#x3D; data.getData();        &#x2F;&#x2F;根据不同的uri进行不同的解析        if (DocumentsContract.isDocumentUri(this,uri))&#123;            String docId &#x3D; DocumentsContract.getDocumentId(uri);            if (&quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority()))&#123;                String id &#x3D; docId.split(&quot;:&quot;)[1];                String selection &#x3D; MediaStore.Images.Media._ID+&quot;&#x3D;&quot;+id;                path &#x3D; getImagePath(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,selection);            &#125;else if(&quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority()))&#123;                Uri contentUri &#x3D; ContentUris.withAppendedId(Uri.parse(&quot;content:&#x2F;&#x2F;downloads&#x2F;public_downloads&quot;),Long.valueOf(docId));                path &#x3D; getImagePath(contentUri,null);            &#125;        &#125;else if (&quot;content&quot;.equalsIgnoreCase(uri.getScheme()))&#123;            path &#x3D; getImagePath(uri,null);        &#125;else if (&quot;file&quot;.equalsIgnoreCase(uri.getScheme()))&#123;            path &#x3D; uri.getPath();        &#125;        &#x2F;&#x2F;展示图片        displayImage(path);    &#125;&#x2F;&#x2F;安卓小于4.4的处理方法private void handImageLow(Intent data)&#123;        Uri uri &#x3D; data.getData();        String path &#x3D; getImagePath(uri,null);        displayImage(path);    &#125;&#x2F;&#x2F;content类型的uri获取图片路径的方法private String getImagePath(Uri uri,String selection) &#123;        String path &#x3D; null;        Cursor cursor &#x3D; getContentResolver().query(uri,null,selection,null,null);        if (cursor!&#x3D;null)&#123;            if (cursor.moveToFirst())&#123;                path &#x3D; cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA));            &#125;            cursor.close();        &#125;        return path;    &#125;&#x2F;&#x2F;根据路径展示图片的方法private void displayImage(String imagePath)&#123;        if (imagePath !&#x3D; null)&#123;            Bitmap bitmap &#x3D; BitmapFactory.decodeFile(imagePath);            imageView.setImageBitmap(bitmap);        &#125;else&#123;            Toast.makeText(this,&quot;fail to set image&quot;,Toast.LENGTH_SHORT).show();        &#125;    &#125;</code></pre><p>上面的代码很多但是不要慌，咱们一个一个来，不难理解的。首先我们知道不同的版本有两个不同的方法来展示图片，就是：handImage和handImageLow。content类型的uri通过getImagePath这个方法来获取真实路径，真实路径通过displayImage这个方法就可以展示出来了。所以主要的工作就是怎么拿到真实路径。现在思路清晰了，让我们一个个来看：</p><p>首先来看一下两个工具方法：getImagePath和displayImage。</p><ul><li>getImagePath学过内容提供器会知道这个就是通过内容提供器来获取数据。通过这个uri以及selection获取到一个Cursor对象。Cursor是什么呢？不了解的读者可以查看这篇博客<a href="https://www.jianshu.com/p/2fc0d39bd2f6" target="_blank" rel="noopener">Android中的Cursor</a>。然后通过这个Cursor对象的MediaStore.Images.Media.DATA这个参数就可以获取到真实路径了。</li><li>displayImage这个方法收一个真实路径字符串，直接通过BitmapFactory.decodeFile这个方法获取到Bitmap再显示出来就行了</li></ul><p>了解了工具方法后，我们的目的就很明确啦：content类型的uri或者真实路径的String。<br>首先是版本低于4.4的，因为返回的是真实的uri，也就是content开头的那个，所以直接通过getImagePath获取真实路径再通过displayImage展示即可。</p><p>接下来这个可能看起来有点头疼，因为要解析不同类型的Uri。我们一个个来看：</p><ul><li><p>第一种是document类型的uri。至于什么是document类型的uri这里就不深入了，只要知道有这种类型的uri，要怎么处理就好了。首先我们要获取一个DocumentId，然后再分两种情况处理：<br>第一种的是media格式的，然后我们要取出后半截字符串我们才能获取到真正的id，这里就真正的id指的是对应数据库表中的id，用于selection的。MediaStore.Images.Media.EXTERNAL_CONTENT_URI就是这个照片的content类型uri，再把selection放进去即可。<br>第二种通过ContentUris.withAppendedId这个方法即可获取到content类型的uri，这个方法负责把id和contentUri连接成一个新的Uri。这个方法在这里也不详细讲解。</p></li><li><p>第二种的是content类型的，那不用说直接用就行了</p></li><li><p>第三种的是file类型的，这个就是真实路径了，直接getPath就可以获取到了。</p></li></ul><p>好了，到此我们的所有疑问也就解决了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>看完之后是不是发现思路很简单但是实现起来很多的知识盲区呢？确实是这样。但是当我们把这些细节都解决了之后我们就会学到很多的东西，相当于以点带面。文中还有好多没有详解的：<br> ContentUris，BitmapFactory，Cursor，DocumentsContract等等。因为这是另外一块比较大的内容，如果要讲的话将会涉及到很多内容就很容易偏离我们的主题了，所以只要知道大概是什么就可以了。<br>·<br>·<br>·</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《第一行代码》郭霖</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在相册里选择图片上传也是很常见的功能了例如微信朋友圈等等。但是他们是自定义的选择器，可以选择多张图片并修改。这里我们讲一个最简单的：调用系统
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
</feed>
