<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Android使用系统相机进行拍照</title>
    <link href="/2020/04/21/Android/Android%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9B%B8%E6%9C%BA%E8%BF%9B%E8%A1%8C%E6%8B%8D%E7%85%A7/"/>
    <url>/2020/04/21/Android/Android%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9B%B8%E6%9C%BA%E8%BF%9B%E8%A1%8C%E6%8B%8D%E7%85%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在日常的开发中有时候会遇到需要用到相机的需求，而相机也是很常用的东西，例如扫二维码啊拍照上传啊等等。这里我不讲像qq那样自定义很强的拍照功能（事实上我也不会），讲个最简单的调用系统相机拍照并储存</p><h1 id="调用系统相机步骤"><a href="#调用系统相机步骤" class="headerlink" title="调用系统相机步骤"></a>调用系统相机步骤</h1><p>这里我通过一个简单的例子来讲这个内容。<br>我自己写了一个demo，布局很简单：</p><pre><code class="hljs java">&lt;Button        android:id=<span class="hljs-string">"@+id/button"</span>        android:layout_width=<span class="hljs-string">"wrap_content"</span>        android:layout_height=<span class="hljs-string">"wrap_content"</span>        android:layout_marginTop=<span class="hljs-string">"4dp"</span>        android:text=<span class="hljs-string">"take phone"</span>        app:layout_constraintEnd_toEndOf=<span class="hljs-string">"parent"</span>        app:layout_constraintHorizontal_bias=<span class="hljs-string">"0.281"</span>        app:layout_constraintStart_toStartOf=<span class="hljs-string">"parent"</span>        app:layout_constraintTop_toTopOf=<span class="hljs-string">"parent"</span> /&gt;    &lt;ImageView        android:id=<span class="hljs-string">"@+id/imageView"</span>        android:layout_width=<span class="hljs-string">"wrap_content"</span>        android:layout_height=<span class="hljs-string">"wrap_content"</span>        android:layout_marginTop=<span class="hljs-string">"29dp"</span>        app:layout_constraintEnd_toEndOf=<span class="hljs-string">"parent"</span>        app:layout_constraintStart_toStartOf=<span class="hljs-string">"parent"</span>        app:layout_constraintTop_toBottomOf=<span class="hljs-string">"@+id/button"</span>        app:srcCompat=<span class="hljs-string">"@mipmap/ic_launcher_round"</span> /&gt;</code></pre><p>就是一个按钮点击弹起相机，然后一个imageView显示拍到的照片。</p><p>·</p><p>接下来我想一下调用的整个过程我们需要做什么：<br>首先弹起相机肯定要跳到相机这个应用，那么就必须通过隐性启动相机的活动。<br>然后当我们返回应用的时候，还要将照片显示，所以这里就要用到startActivityForResult这个方法。<br>其次，我们拍照之后肯定要进行储存的，那么就涉及到文件的操作。<br>涉及到内存的操作就肯定要和权限打交道，所有还有权限相关的内容。<br>最后还有一个问题就是，相机拍完照是要储存照片的，所以我们要给他一个地址uri，但是可不可以直接把地址当成参数发过去呢？这里就要用到特殊的内容提供器FileProvider。<br>上面就是调用相机要用到的内容，虽然用的都很浅，但是都会涉及到。接下来看看具体怎么实现。看看Activity中的onCreate的代码：<br>·</p><pre><code class="hljs java">   <span class="hljs-keyword">private</span> Uri imageUri;<span class="hljs-keyword">private</span> ImageView imageView;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;       <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);       setContentView(R.layout.activity_main);       imageView = findViewById(R.id.imageView);       Button button = findViewById(R.id.button);       button.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;           <span class="hljs-meta">@Override</span>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;                      <span class="hljs-comment">//创建一个File对象。getExternalCacheDir()获取应用的缓存目录，outputImage.jpg是照片名称</span>               File outputImage = <span class="hljs-keyword">new</span> File(getExternalCacheDir(),<span class="hljs-string">"outputImage.jpg"</span>);               <span class="hljs-keyword">try</span>&#123;                               <span class="hljs-comment">//创建一个空文件            </span>                   outputImage.createNewFile();               &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;                   e.printStackTrace();               &#125;                              <span class="hljs-comment">//不同的安卓版本对用不同的获取Uri的方法</span>               <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT&gt;=<span class="hljs-number">24</span>)&#123;                   imageUri =FileProvider.getUriForFile(MainActivity.<span class="hljs-keyword">this</span>,<span class="hljs-string">"huan"</span>,outputImage);               &#125;<span class="hljs-keyword">else</span>&#123;                   imageUri = Uri.fromFile(outputImage);               &#125;               <span class="hljs-comment">//启动相机的对应Activity</span>               Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-string">"android.media.action.IMAGE_CAPTURE"</span>);               intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri);               startActivityForResult(intent,<span class="hljs-number">1</span>);           &#125;       &#125;);</code></pre><p>我们来看看这里的代码：前面的代码很简单就是控件的初始化。<br>我们知道照片是要放文件夹得，所以这里要创建一个File对象，指定文件的路径以及名字。这里路径为什么要用getExternalCacheDir()呢？因为每个应用都有对应得缓存目录，访问这些目录得时候不用访问内存权限，这样得话就可以省去需求权限得步骤啦。这个目录在/scare/Android/data/<package name>/cache。</p><p>然后我们再创建一个空的文件夹。这里如果已经有照片了的话例如我们第二次拍照的时候，那么就不会创建新的空文件夹了。直到储存的时候才会被替换掉。</p><p>然后我们刚才讲到，拍到的图片要在我们的应用中展示，那么就必须用到内容提供器。这里用到FileProvider来获取uri，关于provider我在下文有讲到可以<a href="#jump">点击跳转</a><br>如果是低于4.4版本的安卓就用Uri.fromFile(outputImage);方法可以获取到uri</p><p>再通过隐式启动相机activity可以打开相机了。这里系统相机的action是android.media.action.IMAGE_CAPTURE，相机储存路径的参数名字是MediaStore.EXTRA_OUTPUT，并把uri传输进去。</p><p>好了这样就完成了拍照并把照片储存的步骤了。接下来还差什么？对了，把照片显示出来。现在在内存中已经有这个照片了，而且uri也知道，所以就很容易了，看代码：</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> requestCode, <span class="hljs-keyword">int</span> resultCode, @Nullable Intent data)</span> </span>&#123;    <span class="hljs-keyword">if</span> (requestCode == <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">if</span> (resultCode == RESULT_OK)            <span class="hljs-keyword">try</span> &#123;                Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(imageUri));                imageView.setImageBitmap(bitmap);            &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;                e.printStackTrace();            &#125;    &#125;&#125;</code></pre><p>我们刚才使用startActivityForResult来启动活动的，所以就要重写这个方法来显示图片了。这里首先判断是哪个启动命令，然后再判断是否成功启动，再BitmapFactory.decodeStream这个方法来获取bitmap，再把bitmap显示出来就行了。BitmapFactory.decodeStream这个方法需要一个流，可以通过getContentResolver().openInputStream这个方法来开启一个流。</p><p>到此整个流程就解决了。</p><h1 id="FileProvider"><a href="#FileProvider" class="headerlink" title="FileProvider"></a><span id = "jump">FileProvider</span></h1><p>FileProvider是一个特殊的内容提供器，可以把一个file开头的uri改成content开头的，例如：file://uri -&gt; content://uri。那为什么要这么做呢？这里简单讲一下：<br>这个是因为在Android 7.0之后，官方禁止直接把一个真实路径的uri传输到别的应用，而我们要把地址送给相机，所以就会出现问题了。详细可以查阅这篇博客：<a href="https://blog.csdn.net/lmj623565791/article/details/72859156" target="_blank" rel="noopener">Android 7.0 行为变更 通过FileProvider在应用间共享文件吧</a></p><p>既然是内容提供器那么肯定是要进行注册的：</p><pre><code class="hljs java">&lt;provider            android:name=<span class="hljs-string">"android.support.v4.content.FileProvider"</span>            android:authorities=<span class="hljs-string">"huan"</span>            android:exported=<span class="hljs-string">"false"</span>            android:grantUriPermissions=<span class="hljs-string">"true"</span>&gt;            &lt;meta-data                android:name=<span class="hljs-string">"android.support.FILE_PROVIDER_PATHS"</span>                android:resource=<span class="hljs-string">"@xml/file_paths"</span> /&gt;        &lt;/provider&gt;</code></pre><p>这里的authorities参数必须和前面的getUriForFile方法的第二个参数保持一致，同个内容提供器的authorities肯定要一样啦。grantUriPermissions参数一定要是true，这个的大概意思就是给他的所有元素授权可以被访问，在FileProvider中这个参数必须是true（这也是为什么在4.4一下版本的安卓无法使用的原因之一，有兴趣可以去了解一下）export这个参数表示可不可以给其他的应用共享，这里要设置为false。&lt;meta-data这个是配置我们可以访问的文件路径，@xml/file_paths这个就是表示什么文件可以被访问，当然要建一个这个文件。看代码：</p><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?&gt;&lt;paths xmlns:android=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>&gt;    &lt;external-path        name=<span class="hljs-string">"my_image"</span>        path=<span class="hljs-string">"/"</span>/&gt;&lt;/paths&gt;</code></pre><p>&lt;external-path这个就是表示可以被访问的路径，name是后面映射用到的，可以自己随便起，我这里用一横杆表示整个目录可以被访问。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>调用系统相机的功能虽然不难，代码也不多，但是其中的零碎知识很多，零零散散，还是要注意的。特别是关于低高配的安卓版本问题还是要特别注意一下。</p><p>·<br>·<br>·<br>·</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《第一行代码》郭霖<br><a href="https://blog.csdn.net/lmj623565791/article/details/72859156" target="_blank" rel="noopener">Android 7.0 行为变更 通过FileProvider在应用间共享文件吧</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Intent-Filer匹配规则解析</title>
    <link href="/2020/04/21/Android/Android%E4%B8%AD%E7%9A%84Intent-Filer%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%E8%A7%A3%E6%9E%90/"/>
    <url>/2020/04/21/Android/Android%E4%B8%AD%E7%9A%84Intent-Filer%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们都知道，活动的启动方式有两种：一种是显示启动，或者很简单，指定一个活动的class就可以了；另外一种就是隐式启动，这种要指定action，category，data信息，例如我们在启动系统相机的时候。看一下代码：</p><pre><code class="hljs java">Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-string">"android.media.action.IMAGE_CAPTURE"</span>);                intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri);                startActivityForResult(intent,<span class="hljs-number">1</span>);</code></pre><p>其中的”android.media.action.IMAGE_CAPTURE”就是相机的action，这样就可以启动相机了。<br>隐式启动我们在平时也用的比较少，对于自己应用中的Activity都是直接显示启动了。那什么时候用到隐式启动呢？一般是在启动别的应用的activity的时候，例如上面讲到的相机。<br>上面讲到的action，category，data就是intent-filer，也就是过滤器，筛选要启动的activity。<br>intentFiler有什么用？就像给自己上个标签。例如，你给自己上个标签是大学生，那么，当说学生出来，欸那么就匹配到你了。这个就是intentfiler的作用。用于筛选匹配。<br>那么这三个action，category，data究竟是什么？他们的具体匹配规则又是什么样的？上面讲到intentFiler是用于启动别的应用，有哪些常用的intentfiler可以使用？接下来我们就来看看。</p><h1 id="intentFiler的结构"><a href="#intentFiler的结构" class="headerlink" title="intentFiler的结构"></a>intentFiler的结构</h1><p>前面讲到intentFiler包含三个：action，category，data，让我看一下代码熟悉一下：</p><pre><code class="hljs java">&lt;intent-filter&gt;                &lt;action android:name=<span class="hljs-string">"huan"</span>/&gt;                &lt;category android:name=<span class="hljs-string">"android.intent.category.DEFAULT"</span>/&gt;            &lt;/intent-filter&gt;</code></pre><p>另外包括我们最熟悉的：</p><pre><code class="hljs java">&lt;intent-filter&gt;                &lt;action android:name=<span class="hljs-string">"android.intent.action.MAIN"</span> /&gt;                &lt;category android:name=<span class="hljs-string">"android.intent.category.LAUNCHER"</span> /&gt;            &lt;/intent-filter&gt;</code></pre><p>这三个分别表示不同的意义。你想要启动什么样的activity就通过设置这些属性来启动到对应的activity。当我们自己设置intentFiler的时候也要注意他的意义性，虽然很多可以随便设置，但是就像变量名称一样，不要随便起。</p><h1 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h1><p>action是最简单也是最常用的。</p><ul><li>意义：这个参数表示启动这个活动要干嘛。例如上面相机的是android.media.action.IMAGE_CAPTURE，很明显就是拍照功能。action的本质也是一个字符串，匹配就必须每个字符都一样，包括大小写。上面说过，虽然可以随便写这个字符串，但是要有意义。</li><li>匹配规则：action的匹配规则也很简单，Intent中的action和intentFilter中的任意一个action匹配，那么匹配成功。但是如果Intent中的action是空的，那么匹配失败。<h1 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h1>这个参数平时用得比较少，一般在一些比较特殊的情况才会用到</li><li>意义：这个参数平常使用的意义是表示实现这个action动作的类别，也就是可以响应这个Intent的组件类别。例如上面的category android:name=”android.intent.category.LAUNCHER”，表示这个action将会在顶级执行，什么意思呢？就是我们每次打开应用都会打开的第一个activity。</li><li>匹配规则：可以设置多个category。但是intent中的每一个category都必须和intentFilter中的其中一条category匹配才能匹配成功。</li><li>注意：给activity设置intentFilter的时候，如果没有其他的category，必须设置category android:name=”android.intent.category.DEFAULT”这个category。原因是startActivity或者starActivityForResult这两个方法执行的时候，如果intent中没有category的话，那么就会自动加上”android.intent.category.DEFAULT”这个category。<h1 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h1>data是三个中最复杂的一个，顾名思义，这个参数就是用来传递数据的。data不同于前面两个，他由两部分组成：Uri+mimeType.<br>很多读者可能还不怎么了解Uri这个东西，可以通过这个<a href="https://www.jianshu.com/p/7690d93bb1a1" target="_blank" rel="noopener">Android URI总结</a>简单了解一下Uri。这里就不展开了。我们先来看看data的组成：<pre><code class="hljs java">&lt;data android:scheme=<span class="hljs-string">""</span>                    android:host=<span class="hljs-string">""</span>                    android:port=<span class="hljs-string">""</span>                    android:path=<span class="hljs-string">""</span>                    android:pathPattern=<span class="hljs-string">""</span>                    android:pathPrefix=<span class="hljs-string">""</span>                    android:mimeType=<span class="hljs-string">""</span>/&gt;</code></pre>data一共由7个参数组成，一起来看看分别是什么意思：</li><li>scheme：这个表示uri的模式，有最熟悉的http：//这就是一种模式，另外安卓中还有比较常见的两种是：content：//和file：//。有学过ContentProvider的读者应该对content模式就很熟悉了。</li><li>host，port：host是主机，port是端口号，这两个合称authority。例如<a href="http://www.baidu.com这个应该就很熟悉了吧。在ContentProvider中表示哪一个contentProvider。" target="_blank" rel="noopener">www.baidu.com这个应该就很熟悉了吧。在ContentProvider中表示哪一个contentProvider。</a></li><li>path，pathPattern，pathPrefix：这三个表示路径信息。一是完整的路径，二是可以用通配符来表示例如image/*，三是路径的前缀。</li><li>mimeType：这个表示媒体类型。例如image/jpeg</li></ul><p>讲完他的结构后，有的读者可能会发现，这个data不就是一个地址+文件类型吗？是的，uri本身就是地址的意思。我们平时什么时候用到data呢？举个例子，我们调用相机拍照并存储到指定的文件夹，那么怎么让相机知道地址呢？就是data了，我们通过intent启动相机，并把地址放在data传输过去。这里的uri还涉及到安卓版本的影响有所不用，有兴趣的读者可以去了解一下。</p><p>那么，data的匹配规则是怎么样的呢？<br>和action是一样的，要求intent中必须要有data，而且和intentFilter中的一个相匹配就可以匹配成功。</p><ul><li>注意：如果在intentFilter中的data没有设置uri，那么默认的schme就是content和file。<h1 id="设置intentFilter"><a href="#设置intentFilter" class="headerlink" title="设置intentFilter"></a>设置intentFilter</h1>看完了上面知道intentFilter中的三个参数怎么去匹配了，那怎么给活动设置intentFilter，怎么给intent传输参数知道吗？这个比较简单也简单讲一下：</li></ul><p>给活动设置intentFilter比较简单，只要在AndroidManifest中设置就可以了，看示例代码：</p><pre><code class="hljs java">&lt;activity android:name=<span class="hljs-string">".MainActivity"</span>&gt;            &lt;intent-filter&gt;                &lt;action android:name=<span class="hljs-string">"android.intent.action.MAIN"</span> /&gt;                &lt;category android:name=<span class="hljs-string">"android.intent.category.LAUNCHER"</span> /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;</code></pre><p>给intent设置参数也不难，一个一个来看：</p><ul><li>action：可以在新建Intent对象的时候顺便写进去，例如：<code>Intent intent = new Intent(&quot;android.intent.action.GET_CONTENT&quot;);</code>或者调用Intent的setAction方法：<code>intent.setAction(&quot;android.intent.action.GET_CONTENT&quot;);</code><ul><li>caterogy：通过intent的方法<code>intent.addCategory();</code></li><li>data：这个比较特殊一点因为他有两个部分：uri和mimeType。有三个方法：其中setType和setData分别是设置mimeType和uri的。但是这两个方法都分别会清空另一个的数据。什么意思呢？例如我通过setData设置了一个uri，然后再通过setType设置一个mimeType，那么第一个的uri就会不见了，被删除了。所以就有第三个方法：<code>intent.setDataAndType</code>。这个方法接受两个参数，uri和mimeType，同时设置两个参数，就不会被清除了。<h1 id="常用的intentFiler"><a href="#常用的intentFiler" class="headerlink" title="常用的intentFiler"></a>常用的intentFiler</h1>上面讲到intentFilter主要是用来启动别的应用的，例如相机，电话，那么有什么是比较常用的呢？具体可以查看这篇博客<a href="https://blog.csdn.net/lo5sea/article/details/38308513" target="_blank" rel="noopener">android 常用URI 值得记住</a>。不懂得也可以百度或者评论区留言。<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1>我们上面讲到intentFilter可以用来筛选要启动的activity，同样对于service和broadcast也是一样，也同样可以给他们设置intentFilter来隐式启动对应的组件。而平时用的最多还是隐式启动活动，特别是在调用别的应用的活动的时候。要掌握一些常见的调用，这也是很重要的。<br>同时intentFilter的匹配规则也是很重要，熟记才不会在自己设置intentFilter的时候出错。<br>其中还有很多细节没有讲清楚，有疑问的读者可以评论区留言。<br>·<br>·<br>·</li></ul></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.jianshu.com/p/7690d93bb1a1" target="_blank" rel="noopener">Android URI总结</a><br><a href="https://www.cnblogs.com/linjiqin/archive/2011/05/28/2061396.html" target="_blank" rel="noopener">ContentProvider和Uri详解</a><br><a href="https://www.jianshu.com/p/67d99a82509b" target="_blank" rel="noopener">详解Intent</a><br>《Android开发艺术探索》任玉刚</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Activity生命周期简析</title>
    <link href="/2020/04/21/Android/Android%E5%AE%89%E5%8D%93%E4%B8%ADActivity%E6%B4%BB%E5%8A%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2020/04/21/Android/Android%E5%AE%89%E5%8D%93%E4%B8%ADActivity%E6%B4%BB%E5%8A%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Activity作为安卓四大组件之一，平常我们接触得最多得也是activity，所以很有必要详细了解一下他的详细生命周期。这篇文章定位是有一点安卓基础的，所以还完全不了解的可以先去学习一下activity。这篇文章主要是讲活动的生命周期。<br>活动的生命周期，人有胎儿期，青春期，老年期一样，活动同样有他的各种生命状态。我们出生会哭，进入成年期会有成人礼。活动也一样，每进入一个状态都会回调相应的方法。对于我们来说，活动周期就是活动会在活动具体哪个时候会回调哪一些方法，然后我们可以重写这一些方法，来实现我们的功能。所以我们得具体了解究竟什么时候调用什么方法。例如在onCreate方法中初始化，在destroy中释放内存等等。<br>那接下来就看看他的具体生命周期。</p><h1 id="活动的状态"><a href="#活动的状态" class="headerlink" title="活动的状态"></a>活动的状态</h1><p>首先得了解一下活动的状态。我个人的理解把活动分为四个状态：后台状态，暂停状态，运行状态和销毁状态。</p><ol><li><p>停止状态：这个状态表示活动未进入前台，我们看不到也无法交汇。切换界面活动都会在后台。如果内存紧张的话有可能被回收。就像我们有时候打游戏切换到微信回了一下信息，回来的时候卧槽怎么把我游戏退了，就是这样。</p></li><li><p>运行状态：这个不用多讲，当你在交汇的这个活动就是运行状态。</p></li><li><p>暂停状态：当弹出一个提示框，我们回发现无法与原来的界面交汇了，就是只能点那个提示框。当一个活动位于栈顶，也就是你看的见他，但是你没办法操作他，这个时候就是属于暂停状态。</p></li><li><p>销毁状态：就是被移出栈顶的活动，马上就会被回收了。例如你退出一个应用他马上就会被杀了。</p><h1 id="常规情况下的生命周期"><a href="#常规情况下的生命周期" class="headerlink" title="常规情况下的生命周期"></a>常规情况下的生命周期</h1><h2 id="典型情况下的生命周期"><a href="#典型情况下的生命周期" class="headerlink" title="典型情况下的生命周期"></a>典型情况下的生命周期</h2><p>每个活动正常启动的话都会经历的生命周期如下图</p><pre><code class="hljs mermaid">graph TBz[活动启动]--&gt;aa[onCreate] --&gt; b[onStart]b --&gt; c[onResume]c --&gt; d[Activity运行]d--&gt;e[onPause]e--&gt;f[onStop]f--&gt;g[onDestroy]g--&gt;h[活动销毁]f--&gt;i[onRestart]i--&gt;be--&gt;c</code></pre><p>每到一个时间点都会调用相关的方法，接下来一个一个来分析一下这些方法。</p></li><li><p>onCreate：</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);    &#125;</code></pre><p>这是我们每个活动都会用到的一个方法。他在活动被创建的时候被调用，且只会调用一次。除非被destroy重新创    建。我们一般在这个方法中做一下初始化的事情。例如加载布局资源等等。细心的读者可能会注意到他有一个Bundle参数，这个参数主要是用于保存被异常销毁事的数据的，这个在后面会讲到</p></li><li><p>onStart:顾名思义这个方法表示活动正在启动，这个时候活动界面已经看的见了，但是还不能与用户交汇，简单点说就是你看得到点不了。但是一般速度很快不会让你感受到这个现象，不然就会好像卡死一样了。所以不能在这个方法中做重量级的操作，初始化什么的都放在onCreate。</p></li><li><p>onResume：这个方法表示活动显示在前台了而且也可以用了。onStart和onResume主要配合onPause和onStop方法来使用，下面会讲到。</p></li><li><p>onPause：活动被暂停的时候会调用到。例如一些弹出提示框，看得到界面但是无法进行交汇。一般执行完这个方法后紧接着就会执行onStop方法了。这个方法可以做一些动画的暂停工作等等轻量级的工作，不然弹个提示框都要卡一下用户体验也很差对吧。<br>如果没有进入onStop这个环节的话，回到原Activity的话，那么就会调用onResume这个方法了</p></li><li><p>onStop：这个方法在活动即将停止的时候调用，同样不能做重量级的工作。一般切换界面，如果内存足够没有被杀死的话，这个活动就会进入停止状态。</p></li><li><p>onRestart：当活动从停止状态回来的时候就会调用这个方法。状态和onStart其实是差不多的，只是为了区分是正常打开的还是从停止状态回来的，可以分别写不同的方法。</p></li><li><p>onDestroy：活动被销毁的时候会调用这个方法。可以做一些资源的释放什么的。但这里要特别强调的一点就是并不是所有情况下活动被销毁都会调用这个方法。例如当你按下返回键回到上个界面，这个当然是会执行这个方法。但是如果你切换到了别的应用或者回到了桌面，这个应用被后台杀死了，那么只有处于栈顶也就是这个应用最后打开的活动会执行destroy方法，其他都不会，需要特别注意一下。<br><img src="https://img-blog.csdnimg.cn/20190916205438446.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc2Njc1Mw==,size_8,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li></ol><h2 id="一些例外情况的生命周期"><a href="#一些例外情况的生命周期" class="headerlink" title="一些例外情况的生命周期"></a>一些例外情况的生命周期</h2><p>有一句话叫做用户永远不会按照你的设想去使用软件，活动也一样，总是会出现一些比较不一样的情况。这些情况活动是怎么跑的也来看看：</p><ol><li>返回桌面的时候：返回桌面其实就像切换到别的活动是一样的道理，这个时候执行的方法是：onPause –&gt; onStop。</li><li>当活动被系统回收再被打开，流程和打开一个新的活动是一样的。</li><li>打开新的活动时先执行onPause方法再启动新的活动，onStop会慢一点点执行。</li></ol><h1 id="异常情况下的生命周期"><a href="#异常情况下的生命周期" class="headerlink" title="异常情况下的生命周期"></a>异常情况下的生命周期</h1><p>这里的异常情况主要有两种：一种是放在后台被杀死了，不是我们主动去终结他的生命的，第二种是设备的配置发生了改变，例如屏幕翻转。对于这两种情况我们具体来看一下</p><h2 id="情况1-：资源相关的系统配置发生改变"><a href="#情况1-：资源相关的系统配置发生改变" class="headerlink" title="情况1 ：资源相关的系统配置发生改变"></a>情况1 ：资源相关的系统配置发生改变</h2><p>这个资源相关的系统配置怎么说呢。我们的项目目录下不是有drawable-hdpi ，drawable-mdpi，这一类的文件夹，在不同的屏幕尺寸下会获取不同的图片，就像我们手机和平板也是一样有两个不同的配置。平常中我们翻转屏幕时，屏幕尺寸就发生了变化，准确来说时屏幕的长宽比例发生了变化，那么这个时候Activity就会被重建（当然你也可以设置他不重建）。<br>细心的读者会发现，即使我的屏幕翻转了，活动重建了，可是还是保留着刚刚我操作的内容啊！例如我在输入框输入了Hello World翻转后还是Hello World，不是说活动被重建了吗，为什么这些还存在？<br>不知道还记不记得onCreate方法中有一个Bundle参数吗？没错，这个参数就是记录之前的数据的。重建的过程和平常的杀死启动活动有一些不一样，看一下：</p><pre><code class="hljs mermaid">graph TBa[Activity运行] --屏幕翻转--&gt;b[onPause,onSaveInstanceState] b--&gt; c[onStop]c--&gt;d[onDestroy]d --重新创建--&gt; e[onCreate]e--&gt;f[onRestoreInstanceState]f--&gt;g[onStart,onResume]g--&gt;h[Activity重新启动]</code></pre><p>可以看到最主要的不同就是多了onSaveInstanceState和onRestoreInstanceState这两个方法。<br>活动在这种异常的情况下被终结生命后，就会调用onSaveInstanceState方法来保存目前的数据，这个方法在onStop方法前调用，但是和onPause方法的前后关系没有必然的关系。然后作为一个Bundle参数传递给重新创建的活动。这个Bundle对象会在onCreate方法中和onRestoreInstanceState中被使用。onRestoreInstanceState这个方法主要就是把刚才的数据还原，执行的次序是在onStart之后。<br>要注意的一点是，onSaveInstanceState方法只有在活动还会被重建的时候才会被调用。例如你手动把他后台杀了，是不会调用这个方法的。</p><h2 id="资源内存不足导致活动被杀死"><a href="#资源内存不足导致活动被杀死" class="headerlink" title="资源内存不足导致活动被杀死"></a>资源内存不足导致活动被杀死</h2><p>当系统内存不足的时候，系统就会按照优先级的大小去杀死一些活动，并在后续通过上面onSaveInstanceState和onRestoreInstanceState方法来恢复数据。优先级按照状态依次是：运行状态，暂停状态，停止状态。一般最有可能是停止状态的活动被杀了。所以一些后台工作就尽量放在service中防止被杀死</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>讲了这么多的生命周期，其实我也是简单讲了我们在使用中一般会遇到的生命周期。有一些读者可能会有这个疑问：为什么我主动调用了onDestroy方法但是活动却没有被杀死？举个例子，你给一个婴儿举办成人礼，他会马上成人吗？要注意的一点就是，我们所说的这些生命周期的回调方法，本质上他们都是一样的，只是被调用的时间不用。他们只是在活动的不同时间被调用，并不是调用这个方法去推进活动的生命进行。主动销毁活动我们用到的是finish（），而不是onDestroy，要特别注意。</p><p>生命周期是活动很重要的一部分，只要了解了他的生命周期我们才可以在准确的时间给他做一些正确的事情。例如你的孩子进入了青春期，你就得跟他说好好学习不要老是想着谈恋爱对吧。我之前自己出过一个低级错误就是在onCreate方法之前使用findViewById，活动都还没创建，怎么找得到布局呢。充分了解这些生命周期后就不会犯这些低级错误了。</p><p>我也是一个安卓新手，有哪些地方写的不好还请大佬们指教</p><p>·<br>·<br>·</p><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p>《Android开发艺术探索》–任玉刚<br>《第一行代码》–郭霖</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>启动页白屏解决方案</title>
    <link href="/2020/04/21/Android/Android%E5%AE%89%E5%8D%93%E5%90%AF%E5%8A%A8%E9%A1%B5%20%20%E8%A7%A3%E5%86%B3%E6%89%93%E5%BC%80%E5%BA%94%E7%94%A8%E6%98%BE%E7%A4%BA%E7%99%BD%E5%B1%8F%E6%83%85%E5%86%B5/"/>
    <url>/2020/04/21/Android/Android%E5%AE%89%E5%8D%93%E5%90%AF%E5%8A%A8%E9%A1%B5%20%20%E8%A7%A3%E5%86%B3%E6%89%93%E5%BC%80%E5%BA%94%E7%94%A8%E6%98%BE%E7%A4%BA%E7%99%BD%E5%B1%8F%E6%83%85%E5%86%B5/</url>
    
    <content type="html"><![CDATA[<p>﻿当我们打开app的时候是不是会有一瞬间的白屏然后再进入主活动，虽然这并不会造成什么不好的后果，但是感觉用户体验就不是很好。像网易云音乐等等，打开一瞬间就显示了他们的loge，无缝衔接，没有白屏，怎么做到的呢？</p><p>一开始我的思路是这样的。可能是因为我们的主活动逻辑太多，所以加载会变慢，导致显示白屏。如果使用一个只显示一张本地图片的活动，那会不会就不会显示白屏了呢。话不多说我们尝试一下：</p><p>Activity中的代码：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 启动页，显示倾旅的logo，停顿2秒后跳转</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LunchActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);        setContentView(R.layout.activity_lunch);<span class="hljs-comment">//开启子线程进行停顿。如果在主线程停顿的话，会造成主页面卡死，所以在子线程sleep两秒后跳转</span>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">1000</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                start();                LunchActivity.<span class="hljs-keyword">this</span>.finish();            &#125;        &#125;).start();    &#125;    <span class="hljs-comment">//跳转到主页面</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>&#123;        Intent intent = <span class="hljs-keyword">new</span> Intent(LunchActivity.<span class="hljs-keyword">this</span>,MainActivity<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        startActivity(intent);    &#125;&#125;</code></pre><p>layout中的代码：</p><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?&gt;&lt;android.support.constraint.ConstraintLayout    xmlns:android=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>    xmlns:app=<span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span>    xmlns:tools=<span class="hljs-string">"http://schemas.android.com/tools"</span>    android:layout_width=<span class="hljs-string">"match_parent"</span>    android:layout_height=<span class="hljs-string">"match_parent"</span>    android:background=<span class="hljs-string">"#e74b37"</span>    tools:context=<span class="hljs-string">".LunchActivity"</span>&gt;    &lt;ImageView        android:id=<span class="hljs-string">"@+id/imageView5"</span>        android:layout_width=<span class="hljs-string">"80dp"</span>        android:layout_height=<span class="hljs-string">"80dp"</span>        app:layout_constraintBottom_toBottomOf=<span class="hljs-string">"parent"</span>        app:layout_constraintEnd_toEndOf=<span class="hljs-string">"parent"</span>        app:layout_constraintStart_toStartOf=<span class="hljs-string">"parent"</span>        app:layout_constraintTop_toTopOf=<span class="hljs-string">"parent"</span>        app:layout_constraintVertical_bias=<span class="hljs-string">"0.31"</span>        app:srcCompat=<span class="hljs-string">"@drawable/icon"</span> /&gt;&lt;/android.support.constraint.ConstraintLayout&gt;</code></pre><p>这里简单指定一个imageView来显示一张图片。并把背景设置为橘色</p><p>最后再把启动页活动设置为主活动：</p><pre><code class="hljs java">&lt;activity android:name=<span class="hljs-string">"com.example.qinglv.LunchActivity"</span>&gt;            &lt;intent-filter&gt;                &lt;action android:name=<span class="hljs-string">"android.intent.action.MAIN"</span> /&gt;                &lt;category android:name=<span class="hljs-string">"android.intent.category.LAUNCHER"</span> /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;</code></pre><p>一切想的很好，完成后打开一看，还是会白屏，怎么回事？</p><p>活动的加载都是需要时间的，比较简单的活动时间会少点，但是以然会有一瞬间的白屏。那这个白屏到底是什么？就是每个活动的背景。当打开一个活动的时候，因为还没加载出内容，所以显示的就只是背景，所以我们只需要，改变这个背景，设置为我们需要的一个logo照片即可。怎么设置呢？</p><ul><li><p>背景是在主题中指定的，首先设置一个主题，把背景改成我们要的。一般和我们的启动页保持一致，这样的话就不会看起来像两个启动页一样。也可以像网易云音乐那样，背景设置成logo，但是启动页是放广告，但是这会影响用户体验（为了收入打点广告也是可以理解的）。看代码：<br>在res-value-styles：</p><pre><code class="hljs java">&lt;style name=<span class="hljs-string">"NewAppTheme"</span> parent=<span class="hljs-string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;        &lt;!-- Customize your theme here. --&gt;        &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt;        &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt;        &lt;item name="android:windowBackground"&gt;@color/colorPrimary&lt;/item&gt;        &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt;    &lt;/style&gt;</code></pre><p>重点是这句<code>&lt;item name=&quot;android:windowBackground&quot;&gt;@color/colorPrimary&lt;/item&gt;</code><br>这里我指定的是一种颜色你们也可以指定一张图片</p></li><li><p>再给启动页活动指定主题：<br>在：AndroidManifest：</p><pre><code class="hljs java">&lt;activity android:name=<span class="hljs-string">"com.example.qinglv.LunchActivity"</span>           android:theme=<span class="hljs-string">"@style/NewAppTheme"</span>&gt;           &lt;intent-filter&gt;               &lt;action android:name=<span class="hljs-string">"android.intent.action.MAIN"</span> /&gt;               &lt;category android:name=<span class="hljs-string">"android.intent.category.LAUNCHER"</span> /&gt;           &lt;/intent-filter&gt;       &lt;/activity&gt;</code></pre><p>重点是这句<code>android:theme=&quot;@style/NewAppTheme&quot;</code></p></li></ul><p>然后再打开的时候，就会发现不会了。原本显示的白屏变成了我们设置好的图片。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java的Serializable与Android的Parcelable序列化简析</title>
    <link href="/2020/04/21/Android/%E7%AE%80%E6%9E%90Java%E4%B8%AD%E7%9A%84Serializable%E4%B8%8EAndroid%E4%B8%AD%E7%9A%84Parcelable%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2020/04/21/Android/%E7%AE%80%E6%9E%90Java%E4%B8%AD%E7%9A%84Serializable%E4%B8%8EAndroid%E4%B8%AD%E7%9A%84Parcelable%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="关于序列化"><a href="#关于序列化" class="headerlink" title="关于序列化"></a>关于序列化</h1><p>这篇文章主要来讲一下在安卓中关于序列化的问题。首先了解一个问题：什么是序列化？为什么要用到序列化？</p><ul><li><p>什么是序列化：序列化就是就是把一个对象变成可传输的二进制流，可以进行传输。</p></li><li><p>什么是反序列化：与序列化对应，反序列化就是把一个二进制流转化成对象。</p></li><li><p>哪里用到序列化：上面说到序列化就是把对象变得可传输；例如在内存，或者网络中传输数据的时候，就得把一个对象变成二进制流可以进行传输。除此之外，在各种通信中，例如进程间通信，文件读取写入等等都要用到序列化。涉及到数据传输，就得使用序列化。因为只有二进制流才可以进行传输。</p></li><li><p>我们在那些地方会遇到序列化：我们会发现，仅有基本数据类型可以自动进行序列化，但是我的自定义对象并不可以进行序列化。在哪里可以体现呢？当我们从一个Activity向另外一个Activity传递数据的时候，通过Intent，我们会发现只能放基本数据类型。</p></li><li><p>怎么让自定义的对象可序列化：就是我们要讲的Serializable和Parcelable接口。这两个接口就可以让我们的自定义对象可序列化。</p><p>那这两个接口怎么使用？他们有什么区别？这就是接下来我要讲的。</p><h1 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h1><h4 id="简述原理"><a href="#简述原理" class="headerlink" title="简述原理"></a>简述原理</h4><p>Serializable只要使用Java的ObjectOutputStream与ObjectInputStream来开启流。而这个接口主要就是用来标识这个对象可以被转换。关于IO流的相关知识，读者有兴趣可以去深入了解，这里不做深入探究。</p></li></ul><h4 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h4><p>这个序列化接口是Java提供的，实现了这个接口的类，其实例就可以进行传输。那么这个接口怎么使用呢？<br>直接实现这个接口就行了。<br>因为这是一个空接口，所以使用方法极其简单，只需要实现这个接口即可。接下来看个例子：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> String string1;    <span class="hljs-keyword">private</span> String string2;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num;    <span class="hljs-keyword">private</span> Son son;    <span class="hljs-keyword">private</span> List&lt;Son&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getString1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> string1;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setString1</span><span class="hljs-params">(String string1)</span> </span>&#123;        <span class="hljs-keyword">this</span>.string1 = string1;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getString2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> string2;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setString2</span><span class="hljs-params">(String string2)</span> </span>&#123;        <span class="hljs-keyword">this</span>.string2 = string2;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNum</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> num;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        <span class="hljs-keyword">this</span>.num = num;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Son <span class="hljs-title">getSon</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> son;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSon</span><span class="hljs-params">(Son son)</span> </span>&#123;        <span class="hljs-keyword">this</span>.son = son;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Son&gt; <span class="hljs-title">getList</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setList</span><span class="hljs-params">(List&lt;Son&gt; list)</span> </span>&#123;        <span class="hljs-keyword">this</span>.list = list;    &#125;&#125;</code></pre><p>这样就可以把这个Test对象序列化了。</p><h1 id="Parcelable"><a href="#Parcelable" class="headerlink" title="Parcelable"></a>Parcelable</h1><p>同样是使对象可序列化，同样是继承接口，但是Parcelable相比Serializable就要复杂得多了。Paecelable需要在要序列化的类中利用Parcel重写序列化和反序列化的方法。</p><h4 id="Parcelable的实现原理"><a href="#Parcelable的实现原理" class="headerlink" title="Parcelable的实现原理"></a>Parcelable的实现原理</h4><p>Parcelable的实现原理主要就是在内存中开辟一个共享内存块，然后进行传输，看图：<br><img src="https://img-blog.csdnimg.cn/20191017234934209.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>如图在AB两个进程中要进行传输，不能直接把一个对象传输过去，开辟一块内存，通过Parcel，也就是打包的方式，把数据存在了共享内存，再把共享内存中的数据用Parcel取出来，实现数据传输。通俗点来讲，就像送外卖一样，商家找了外卖这个中间人，把食物打包给了外卖小哥，然后你再找外卖小哥拿外卖，再拆包就可以拿到食物了。<br>通过原理可以看到，实现这个接口的重点就在：装包，拆包。如果将对象里面的数据，一个个装起来，是我们要在类中实现的方法。而装拆包公司就是Parcel。所以首先来了解一下这个包装公司：Parcel！</p><h4 id="“包装公司”Parcel"><a href="#“包装公司”Parcel" class="headerlink" title="“包装公司”Parcel"></a>“包装公司”Parcel</h4><p>Parcel的使用和Intent是差不多的，就是write（put）进去，再read（get）出来。简单来看看怎么使用：</p><h6 id="装包"><a href="#装包" class="headerlink" title="装包"></a>装包</h6><p>直接上代码，相关方法说明看注释：</p><pre><code class="hljs java">Parcel parcel;<span class="hljs-comment">//打包字符串</span>parcel.writeString(String string);<span class="hljs-comment">//打包整型数</span>      parcel.writeInt(<span class="hljs-keyword">int</span> num);            <span class="hljs-comment">//打包布尔变量，要和bite进行转换</span>      parcel.writeByte((<span class="hljs-keyword">byte</span>) (<span class="hljs-keyword">boolean</span> bl? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>));            <span class="hljs-comment">//打包字符串集合</span>      parcel.writeStringList(List&lt;String&gt; list);             <span class="hljs-comment">//ElemType表示一个自定义类</span>      <span class="hljs-comment">//序列化对象的时候传入要序列化的对象和一个flag,这里的flag的意思是是否要将这个作为返回值返回</span>      <span class="hljs-comment">//一般传入0，要作为返回值就写1。另外这个对象也一定要是可序列化的</span>      parcel.writeParcelable(ElemType elem, <span class="hljs-number">0</span>);       <span class="hljs-comment">//这里写入自定义元素集合有两种方法，区别是是否写入类的信息</span> <span class="hljs-comment">//第一种方法是不写入类信息，相对应的取出来的时候要用Parcel把元素里面的每一个元素拿出来</span>      parcel.writeTypedList(mFriends);      <span class="hljs-comment">//第二种方法是写入类的信息，取出来的时候就要用类加载器去加载</span>      parcel.writeList(mFriends);      <span class="hljs-comment">//同样也要保证集合的元素可序列化</span></code></pre><p>这里可以看到整体和Intent的传入数据是十分像的。重点有三个地方不太一样：</p><ul><li>布尔变量。布尔变量不能直接放进去，要转换成bite</li><li>可序列化对象。这个放进去的时候要保证这个对象是可序列化的，也就是必须实现序列化接口</li><li>集合。集合分为两种。一种是把元素类的信息也放进去，一种是不把元素的类的信息放进去。下面将拆包会详细讲一下。</li></ul><h6 id="拆包"><a href="#拆包" class="headerlink" title="拆包"></a>拆包</h6><p>直接上代码：（变量使用装包中的变量）</p><pre><code class="hljs java">Parcel source;<span class="hljs-comment">//这个对象在反序列化的时候会作为参数传入供给使用</span><span class="hljs-comment">//获取字符串</span>String string= source.readString();<span class="hljs-comment">//获取整型</span>        <span class="hljs-keyword">int</span> i = source.readInt();<span class="hljs-comment">//获取布尔数</span>        <span class="hljs-keyword">boolean</span> b = source.readByte() != <span class="hljs-number">0</span>;<span class="hljs-comment">//这里注意转化</span><span class="hljs-comment">//获取自定义对象</span><span class="hljs-comment">// 读取对象需要提供一个类加载器去读取,因为写入的时候写入了类的相关信息</span>ElemType e = source.readParcelable(ElemType<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getClassLoader</span>())</span>; <span class="hljs-comment">//获取字符串集合</span>        List&lt;String&gt; list = source.createStringArrayList();                        <span class="hljs-comment">//这一类需要用相应的类加载器去获取</span>        <span class="hljs-comment">//ElemType表示一个自定义类</span>        source.readList(List&lt;Elemtype&gt; list, ElemType<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getClassLoader</span>())</span>;        <span class="hljs-comment">//这一类需要使用自定义类的CREATOR,也就是使用Pacel的反序列方法去获取</span>        <span class="hljs-comment">//source.readTypedList(ElemType e, ElemType.CREATOR); //对应writeTypeList</span>        <span class="hljs-comment">//books = in.createTypedArrayList(ElemType.CREATOR); //对应writeTypeList</span></code></pre><p>主要就是对于布尔变量以及集合的转换会比较不一样。<br>代码中的Friend.CREATOR是Parcelable接口中反序列的方法，实现原理也是用Parcel把对象里面的数据一个个转换出来。</p><ul><li>布尔变量要进行转换</li><li>对象要用类加载器去加载。因为写入的时候写入了类信息</li><li>集合看情况；写入了类信息就要用类加载器；否则用反序列的方法。</li></ul><h6 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h6><p>Parcel的使用方法和Intent很像，但是有几个点要注意一下：</p><ul><li><p>Parcel中没有布尔变量，所以必须将布尔变量和bite进行转换</p></li><li><p>Parcel包装自定义对象时，这个对象对应的类必须也得是实现了序列化接口的才可以进行打包。装包的这个方法因为写入了类的信息，所以拆包的时候需要用到对应类的加载器来进行加载。</p></li><li><p>Parcel在包装集合的时候有两种方法：一种是写入类的信息，一种是不写入类的信息。但都有一个前提：集合中的元素必须是可序列化的。第一种方法需要用到类加载器去加载，第二种就需要用到自定义类中的Parcel的反序列化方法。</p></li><li><p>对于类中有多个相同类型的数据，例如3个字符串，3个int等等，存入的顺序和取出来的顺序一定要一致。例如存int a，int b；那么取出来的时候也得是int a，int b。不能颠倒。</p><h4 id="Parcelable的使用"><a href="#Parcelable的使用" class="headerlink" title="Parcelable的使用"></a>Parcelable的使用</h4><p>看完了上面的Pacel可能还是有一点懵，那这个怎么Parcelable怎么用Pacel实现呢？Parcelable的主要实现思路就是把一个对象中的数据进行分解，分解出来的数据都是可以用Parcel打包的。Parcelable具体怎么使用呢？接下来就来看一下。先看看谷歌给出的示例（代码很重要，记得看注释）：</p><pre><code class="hljs java"><span class="hljs-comment">//首先要实现Parcelable接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyParcelable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Parcelable</span> </span>&#123;<span class="hljs-comment">//类中的数据</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mData;<span class="hljs-comment">//接下来这两个方法是关于序列化的。一定要重写的两个方法</span><span class="hljs-comment">//第一个方法是内容描述。一般没什么要求都是返回0就行了</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">describeContents</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;        <span class="hljs-comment">//第二个是序列化数据的方法。当我们序列化这个类的对象的时候就会调用到这个方法</span>    <span class="hljs-comment">//两个参数：一个是Pacel“包装公司”上面我们讲的，一个是flags。第二个参数表示是否把数据返回。一般为0.</span>    <span class="hljs-comment">//利用这个Parcel把类中所有的数据“打包”序列化</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeToParcel</span><span class="hljs-params">(Parcel out, <span class="hljs-keyword">int</span> flags)</span> </span>&#123;    <span class="hljs-comment">//这个就是上面我们介绍的Parcel的使用</span>         out.writeInt(mData);   &#125;<span class="hljs-comment">//接下来的这两个就是关于反序列化的了</span><span class="hljs-comment">//CREATOR是Parcelable中的一个静态变量，这个名字不能改，因为他内部调用的时候就是用CREATOR来调用的改了名字就找不到了</span><span class="hljs-comment">//观察我们上面的Pacel使用方法也可以发现，是传入ElemType.CREATOR。如果改了名字就找不到了。</span><span class="hljs-comment">//Creator对象中有两个方法要重写：</span>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Creator&lt;MyParceable&gt; CREATOR             = <span class="hljs-keyword">new</span> Creator&lt;MyParceable&gt;() &#123;                       <span class="hljs-comment">//这个就是反序列方法了。在Pacel中把数据取出来构建成一个MyParcelable对象</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> MyParcelable <span class="hljs-title">createFromParcel</span><span class="hljs-params">(Parcel in)</span> </span>&#123;         <span class="hljs-comment">//这里我们用到构造器来获取这个对象。具体构造器实现方法在下面</span>             <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyParcelable(in);         &#125;<span class="hljs-comment">//这个是开辟数组供给使用。一般按照下面的格式写就好了。</span>         <span class="hljs-keyword">public</span> MyParcelable[] newArray(<span class="hljs-keyword">int</span> size) &#123;             <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyParcelable[size];         &#125;    &#125;;   <span class="hljs-comment">//这个是构造器。从Parcel中把数据取出来  </span>     <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">MyParcelable</span><span class="hljs-params">(Parcel in)</span> </span>&#123;     <span class="hljs-comment">//这里就用到了上面我们讲的Parcel的获取数据的方法了</span>         mData = in.readInt();     &#125;</code></pre><p>通过上面的代码相信也可以很清晰的了解怎么实现了。主要就是分为两个部分：序列化和反序列化。</p></li><li><p>序列化主要就是用一个Parcel把数据封装起来。怎么使用按照上面的Parcel使用方法。</p></li><li><p>反序列化要用到一个静态变量，这也可以说是一个构造器，Creator本身就是创造的意思嘛。通过这个Creator吧Parcel中的数据取出来再构造成一个对象，对应拆包。具体我们使用构造器来实现。构造器里面用Parcel的获取数据方法来把数据取出来。需要注意的是这里的CREATOR名字不能改。</p><h1 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h1><p>好了。到这里相信都了解怎么使用这两个接口了。主要是Parcelable比较复杂。现在有个问题了，为什么要造一个如此复杂的接口呢？来看看他们各自的优缺点。</p><h5 id="Serializable-1"><a href="#Serializable-1" class="headerlink" title="Serializable"></a>Serializable</h5><p>这个是java内部定义的序列化接口。</p></li><li><p>优点：使用范围广，在网络，内存文件等均可以使用；使用方式简单，仅仅只需要继承一个接口就可以使用。</p></li><li><p>缺点：性能差；序列化的时候需要创建很多的临时对象。</p></li></ul><h5 id="Parcelable-1"><a href="#Parcelable-1" class="headerlink" title="Parcelable"></a>Parcelable</h5><p>这个安卓中可以使用的接口，仅用于安卓。</p><ul><li>优点：性能强大。开发者号称比Serialization强大10倍的性能。</li><li>缺点：实现过程复杂，需要把对象中的数据一个个拆开进行序列化；<pre><code>从实现原理可以看出来，这个只能用于内存中的序列化，不能用于网络和本地硬盘文件。</code></pre></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>序列化在安卓开发中还是很常用的，例如活动之间传递信息，跨进程传递数据等等都要用到。这两个接口一个简单粗暴，一个复杂强大，平常开发的话，尽量还是使用第二个接口，毕竟多一点代码可以加强这么多的性能何乐不为呢。Parcelable可能比较难理解，多看几遍就可以了。不理解或者笔者写错的可以评论区留言。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LitePal的使用</title>
    <link href="/2020/04/21/Android/LitePal%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/04/21/Android/LitePal%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据库操作一直都是比较繁琐而且单一的东西，平时开发中数据库也很常见。有学过mysql的读者可能会觉得sql语句确实让人很难受。同样android中，虽然有内置数据库SQLite，但是操作起来还是非常的不方便。跟网络请求类似，当我们用原生的HttpURLConnection请求数据再用json解析，过程很繁琐，所以我们一般是封装成一个工具类，但是retrofit出现了，他帮我们解决了网络请求和解析数据的封装，同时还支持RxJava的异步，十分强大。不了解retrofit的读者也建议你们去学习一下retrofit确实非常好用。LitePal也是同样的道理，把创建数据库和增删查改等等操作都封装起来，所以我们用起来会非常的方便。同时还支持异步操作，不需要我们自己去开启子线程，代码非常的整洁，简单。那接下来就来看看这个神奇的框架LitePal。</p><h1 id="简述映射"><a href="#简述映射" class="headerlink" title="简述映射"></a>简述映射</h1><p>LitePal是采用映射的方式来把数据存储在数据库中的，和GSON的道理是一样的。例如我们现在有一个类，这个类必须是javaBean类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LitePalSupport</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;&#125;</code></pre><p>那么他在数据库中就会有一个表，这个表有三列：id，name和age，id是自动生成的，这样就可以理解映射了吧。所以我们使用LitePal的时候不用去指定每一列是什么，只需要给他一个Bean类，自动就会生成了。</p><h1 id="配置LitePal"><a href="#配置LitePal" class="headerlink" title="配置LitePal"></a>配置LitePal</h1><p>LitePal使用之前需要先配置一下，一共分为两步：</p><ol><li>添加依赖库：在app/build.gradle中添加如下内容：<pre><code class="hljs java">dependencies &#123;    implementation <span class="hljs-string">'org.litepal.android:java:3.0.0'</span>&#125;</code></pre>其中3.0.0是版本号，写这个文章的时候是3.0，他更新也是很快的，读者可以自行到文末进入官网查询最新的版本号。添加完之后sync一下就行了。</li><li>修改AndroidManifest中的代码：添加一句android:name=”org.litepal.LitePalApplication”：<pre><code class="hljs java">&lt;application        android:name=<span class="hljs-string">"org.litepal.LitePalApplication"</span>        ...&lt;application</code></pre></li></ol><p>添加这句的意思是让启动app的时候会自动实例化LitePalApplication这个类供给LitePal这个框架使用。如果有自己写了一个android：name的，那么只需要添加这一句LitePal.initialize(context);就可以了。其中的context参数为全局app的context。例如：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Context context;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>.onCreate();        context = getApplicationContext();        LitePal.initialize(context);    &#125;     &#125;</code></pre><ol start="3"><li>在main目录下创建一个Directory：assets。然后再assets目录下再创建一个litepal.xml，如下图：<br><img src="https://img-blog.csdnimg.cn/20190921221538303.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></li><li>编辑litepal.xml中的内容：<pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?&gt;&lt;litepal&gt;    &lt;dbname value=<span class="hljs-string">"bookStore"</span>/&gt;    &lt;version value=<span class="hljs-string">"1"</span>/&gt;    &lt;list&gt;         &lt;/list&gt;&lt;/litepal&gt;</code></pre>dbname就是数据库的名字，version是数据库的版本，list中是数据库中的表，可以在这里添加，怎么添加后面会讲到。</li></ol><h1 id="CRUD操作"><a href="#CRUD操作" class="headerlink" title="CRUD操作"></a>CRUD操作</h1><p>常规增删查改操作，但是在这个框架下都显得特别的简单。</p><h2 id="增加表和数据"><a href="#增加表和数据" class="headerlink" title="增加表和数据"></a>增加表和数据</h2><ol><li>例如我们现在要在数据库中创建一个学生的表，首先要创建一个学生的类,再让他继承LitePalSupport类，至于为什么下面会讲到：<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LitePalSupport</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;&#125;</code></pre></li><li>然后在刚才的litepal.xml中添加表：<pre><code class="hljs java">&lt;list&gt;       &lt;mapping <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"com.example.myapplication.Student"</span>/&gt;&lt;/list&gt;</code></pre>这里的class要是你的类的真实目录，视具体情况而定。<br>添加其他的表也是同样的道理。</li><li>调用student对象的save()方法：<pre><code class="hljs java">Student student = <span class="hljs-keyword">new</span> Student();                student.setAge(<span class="hljs-number">12</span>);                student.setName(<span class="hljs-string">"hha"</span>);                student.save();</code></pre>这里的save方法就是继承前面的LitePalSuppport类的，调用这个方法后就会自动添加到库中对应的表中的一行。<br>添加其他行数据也是同样的道理<h2 id="更改表结构"><a href="#更改表结构" class="headerlink" title="更改表结构"></a>更改表结构</h2>更新表的列。例如前面的学生类是name和age，但是如果你想要增加一个studentId，可以很简单地实现。具体操作如下：</li><li>首先更改你的bean类，想怎么改就怎么改</li><li>在litepal.xml中更改版本号增加1.例如：<pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?&gt;&lt;litepal&gt;    &lt;dbname value=<span class="hljs-string">"bookStore"</span>/&gt;    &lt;version value=<span class="hljs-string">"2"</span>/&gt;    &lt;list&gt;            &lt;mapping <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"com.example.myapplication.Student"</span>/&gt;    &lt;/list&gt;&lt;/litepal&gt;</code></pre>把他改成2就行了。<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2>删除数据也很简单，有两种删除方法，一种是指定行删除，一种给个约束条件删除。</li><li>删除单行：<br>LitePal.delete(Student.class , id);</li><li>约束条件：<br>LitePal.deleteAll(Student.class, “age &gt; ?” , “12”);<br>指定约束条件删除，？是占位符会把后面的12放进去。<br>如果只传入一个Student.class，那么就会把整个表的数据都删除了</li></ol><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p>查询数据的接口都会返回一个List，每一行对应一个对象。所以是LitePal把数据解析都给我们做好了，我们直接拿对象使用就ok了。这里有几种方法接口都看一下：</p><ol><li>LitePal.findAll(Student.class,id);查询对应表的对应行，如果没有传入id参数，就返回这个表的所有内容。同样findFirst是返回第一行，findLast是返回最后一行。</li><li>查询的内容还可以进行筛选，这里就用到几个方法：<ul><li>select（）对应查哪几列的内容</li><li>where（）查询的约束条件</li><li>order（）排序方式</li><li>limit（）指定查询的数量</li><li>offset（）指定结果的偏移量。这个可能比较难理解，举个例子：假设你查的id是1，但是你设置了偏移量是1，那么返回的就是第二行的数据。<br>最后举一个综合例子演示一下：<pre><code class="hljs java">List&lt;Song&gt; songs = LitePal.where(<span class="hljs-string">"name like ? and duration &lt; ?"</span>, <span class="hljs-string">"song%"</span>, <span class="hljs-string">"200"</span>).order(<span class="hljs-string">"duration"</span>).select(<span class="hljs-string">"name"</span>).limit(<span class="hljs-number">3</span>).offset(<span class="hljs-number">3</span>).find(Song<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;</code></pre>这样就可以查询到对应的数据了。<h1 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h1>有时候如果我们的数据库中的内容很多，涉及到重量级的数据库操作往往是比较费时的，那么这个时候肯定时不能放在主线程去进行操作的，这样会造成系统卡死。那么我们就需要去把这个操作放在子线程中。LitePal早就为我们考虑到这个问题了，所以也增加了异步操作，轻松实现，来看看怎么用吧。<br>先看个例子：<pre><code class="hljs java">LitePal.findAllAsync(Song<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">listen</span>(<span class="hljs-title">new</span> <span class="hljs-title">FindMultiCallback</span>&lt;<span class="hljs-title">Song</span>&gt;() </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFinish</span><span class="hljs-params">(List&lt;Song&gt; allSongs)</span> </span>&#123;        &#125;&#125;);</code></pre>这是在官网中的例子，要注意的两个点</li><li>用findAllAsync代替findAll方法</li><li>添加listen方法，并新建匿名类FindMultiCallback&lt;&gt;()作为参数，重写里面的onFinish方法即可<br>这样获取完数据后就会执行onFinish方法了<br>轻松实现异步操作。同样这个可以结合上面的数据筛选。<h1 id="创建多个数据库"><a href="#创建多个数据库" class="headerlink" title="创建多个数据库"></a>创建多个数据库</h1>如果你一个数据库不够用，想要创建多个数据库，当然也是可以的，看代码：<pre><code class="hljs java">LitePalDB litePalDB = <span class="hljs-keyword">new</span> LitePalDB(<span class="hljs-string">"demo2"</span>, <span class="hljs-number">1</span>);litePalDB.addClassName(Singer<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>())</span>;LitePal.use(litePalDB);</code></pre>这里就创建了一个库叫做demo2，并增加了一个表：Singer。最后执行LitePal.use方法来启用这个库。这样的话就默认使用这个库了。对象的save方法都会执行到这个库中<br>如果想切回到litepal.xml中的那个库，可以用下面的方法：<br>LitePal.useDefault();</li></ul></li></ol><p>如果想删除一个库（删库跑路可能会被乱棒打死）<br>LitePal.deleteDatabase(“demo2”);<br>是不是很简单？</p><h1 id="监听数据库创建或者升级"><a href="#监听数据库创建或者升级" class="headerlink" title="监听数据库创建或者升级"></a>监听数据库创建或者升级</h1><p>当数据库创建或者升级的时候都会调用下面的两个方法：</p><pre><code class="hljs java">LitePal.registerDatabaseListener(<span class="hljs-keyword">new</span> DatabaseListener() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// fill some initial data</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUpgrade</span><span class="hljs-params">(<span class="hljs-keyword">int</span> oldVersion, <span class="hljs-keyword">int</span> newVersion)</span> </span>&#123;    <span class="hljs-comment">// upgrade data in db</span>    &#125;&#125;);</code></pre><p>可以在里面写要执行的逻辑。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>LitePal这个库确实是非常的强大，把很复杂的数据库操作都简化成了一个个的方法。但是更新很快，需要时刻看着他更新的内容，有可能会换API，所以建议大家多去官网学习。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>·<br>·<br>·<br>《第一行代码》 郭霖<br>LitePal官网：<a href="https://github.com/LitePalFramework/LitePal" target="_blank" rel="noopener">LitePal项目地址</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>调用系统相册选择照片</title>
    <link href="/2020/04/21/Android/Android%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%86%8C%E9%80%89%E6%8B%A9%E5%9B%BE%E7%89%87/"/>
    <url>/2020/04/21/Android/Android%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%86%8C%E9%80%89%E6%8B%A9%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在相册里选择图片上传也是很常见的功能了例如微信朋友圈等等。但是他们是自定义的选择器，可以选择多张图片并修改。这里我们讲一个最简单的：调用系统的相册选择一张图片并展示。另外有的读者还想到要通过相机拍照来选择图片的功能，也可以参考一下我的另一篇文章<a href="https://blog.csdn.net/weixin_43766753/article/details/101224631" target="_blank" rel="noopener">Android使用系统相机进行拍照</a></p><h1 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h1><p>这里我是通过一个简单的demo来讲解怎么去实现这个功能。首先看布局：</p><pre><code class="hljs java">&lt;Button    android:id=<span class="hljs-string">"@+id/button2"</span>    android:layout_width=<span class="hljs-string">"wrap_content"</span>    android:layout_height=<span class="hljs-string">"wrap_content"</span>    android:layout_marginTop=<span class="hljs-string">"5dp"</span>    android:layout_marginEnd=<span class="hljs-string">"52dp"</span>    android:layout_marginRight=<span class="hljs-string">"52dp"</span>    android:text=<span class="hljs-string">"choose"</span>    app:layout_constraintEnd_toEndOf=<span class="hljs-string">"parent"</span>    app:layout_constraintTop_toTopOf=<span class="hljs-string">"parent"</span> /&gt;&lt;ImageView    android:id=<span class="hljs-string">"@+id/imageView"</span>    android:layout_width=<span class="hljs-string">"wrap_content"</span>    android:layout_height=<span class="hljs-string">"wrap_content"</span>    android:layout_marginTop=<span class="hljs-string">"29dp"</span>    app:layout_constraintEnd_toEndOf=<span class="hljs-string">"parent"</span>    app:layout_constraintStart_toStartOf=<span class="hljs-string">"parent"</span>    app:layout_constraintTop_toBottomOf=<span class="hljs-string">"@+id/button"</span>    app:srcCompat=<span class="hljs-string">"@mipmap/ic_launcher_round"</span> /&gt;</code></pre><p>很简单，就是一个按钮和一个imageView。然后接下来让我们想想这个功能怎么去实现：</p><p>首先打开相册，那么肯定要通过隐式启动相册activity；然后相册返回一个路径，我们就拿这个路径把路径上对应的照片展示出来。思路挺简单的，让我们写写看：<br>首先看代码：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> Uri imageUri;    <span class="hljs-keyword">private</span> ImageView imageView;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        imageView = findViewById(R.id.imageView);        Button button1 = findViewById(R.id.button2);        button1.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;            <span class="hljs-comment">//动态申请权限</span>                <span class="hljs-keyword">if</span> (ContextCompat.checkSelfPermission(MainActivity.<span class="hljs-keyword">this</span>,Manifest.permission                        .WRITE_EXTERNAL_STORAGE)!= PackageManager.PERMISSION_GRANTED)&#123;                    ActivityCompat.requestPermissions(MainActivity.<span class="hljs-keyword">this</span>,<span class="hljs-keyword">new</span> String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,<span class="hljs-number">1</span>);                &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-comment">//执行启动相册的方法</span>                    openAlbum();                &#125;            &#125;        &#125;);     &#125;<span class="hljs-comment">//获取权限的结果</span><span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRequestPermissionsResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> requestCode, @NonNull String[] permissions, @NonNull <span class="hljs-keyword">int</span>[] grantResults)</span> </span>&#123;        <span class="hljs-keyword">if</span> (requestCode == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">if</span> (grantResults.length&gt;<span class="hljs-number">0</span>&amp;&amp;grantResults[<span class="hljs-number">0</span>] == PackageManager.PERMISSION_GRANTED) openAlbum();            <span class="hljs-keyword">else</span> Toast.makeText(MainActivity.<span class="hljs-keyword">this</span>,<span class="hljs-string">"你拒绝了"</span>,Toast.LENGTH_SHORT).show();        &#125;    &#125;<span class="hljs-comment">//启动相册的方法</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">openAlbum</span><span class="hljs-params">()</span></span>&#123;        Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-string">"android.intent.action.GET_CONTENT"</span>);        intent.setType(<span class="hljs-string">"image/*"</span>);        startActivityForResult(intent,<span class="hljs-number">2</span>);    &#125;</code></pre><p>这里先初始化控件，然后动态申请权限，因为我们要读取照片肯定是要读取内存的权限，记得在AndroidManifest中要写明权限：</p><pre><code class="hljs <uses-permission">获取权限后就打开相册选择。相册对应的action是android.intent.action.GET_CONTENT，setType(&quot;image&#x2F;*&quot;)这个方法表示把所有照片显示出来，然后开启活动。启动活动选择完照片后就会返回一个intent到onActivityResult方法中，所以接下来的主要工作就是如果获取到返回的路径。我们知道在安卓4.4以后是不能把文件的真实路径直接给别的应用的，所以返回的uri是经过封装的，所以我们要进行解析取出里面的路径。所以这里我们要进行判断安卓版本来进行不同的逻辑，先看代码：&#96;&#96;&#96;java@Override    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123;    if (requestCode &#x3D;&#x3D; 2)&#123;    &#x2F;&#x2F;判断安卓版本 if (resultCode &#x3D;&#x3D; RESULT_OK&amp;&amp;data!&#x3D;null)&#123;                if (Build.VERSION.SDK_INT&gt;&#x3D;19)                handImage(data);                else handImageLow(data);            &#125;        &#125;    &#125;&#x2F;&#x2F;安卓版本大于4.4的处理方法@RequiresApi(api &#x3D; Build.VERSION_CODES.KITKAT)    private void handImage(Intent data)&#123;        String path &#x3D;null;        Uri uri &#x3D; data.getData();        &#x2F;&#x2F;根据不同的uri进行不同的解析        if (DocumentsContract.isDocumentUri(this,uri))&#123;            String docId &#x3D; DocumentsContract.getDocumentId(uri);            if (&quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority()))&#123;                String id &#x3D; docId.split(&quot;:&quot;)[1];                String selection &#x3D; MediaStore.Images.Media._ID+&quot;&#x3D;&quot;+id;                path &#x3D; getImagePath(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,selection);            &#125;else if(&quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority()))&#123;                Uri contentUri &#x3D; ContentUris.withAppendedId(Uri.parse(&quot;content:&#x2F;&#x2F;downloads&#x2F;public_downloads&quot;),Long.valueOf(docId));                path &#x3D; getImagePath(contentUri,null);            &#125;        &#125;else if (&quot;content&quot;.equalsIgnoreCase(uri.getScheme()))&#123;            path &#x3D; getImagePath(uri,null);        &#125;else if (&quot;file&quot;.equalsIgnoreCase(uri.getScheme()))&#123;            path &#x3D; uri.getPath();        &#125;        &#x2F;&#x2F;展示图片        displayImage(path);    &#125;&#x2F;&#x2F;安卓小于4.4的处理方法private void handImageLow(Intent data)&#123;        Uri uri &#x3D; data.getData();        String path &#x3D; getImagePath(uri,null);        displayImage(path);    &#125;&#x2F;&#x2F;content类型的uri获取图片路径的方法private String getImagePath(Uri uri,String selection) &#123;        String path &#x3D; null;        Cursor cursor &#x3D; getContentResolver().query(uri,null,selection,null,null);        if (cursor!&#x3D;null)&#123;            if (cursor.moveToFirst())&#123;                path &#x3D; cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA));            &#125;            cursor.close();        &#125;        return path;    &#125;&#x2F;&#x2F;根据路径展示图片的方法private void displayImage(String imagePath)&#123;        if (imagePath !&#x3D; null)&#123;            Bitmap bitmap &#x3D; BitmapFactory.decodeFile(imagePath);            imageView.setImageBitmap(bitmap);        &#125;else&#123;            Toast.makeText(this,&quot;fail to set image&quot;,Toast.LENGTH_SHORT).show();        &#125;    &#125;</code></pre><p>上面的代码很多但是不要慌，咱们一个一个来，不难理解的。首先我们知道不同的版本有两个不同的方法来展示图片，就是：handImage和handImageLow。content类型的uri通过getImagePath这个方法来获取真实路径，真实路径通过displayImage这个方法就可以展示出来了。所以主要的工作就是怎么拿到真实路径。现在思路清晰了，让我们一个个来看：</p><p>首先来看一下两个工具方法：getImagePath和displayImage。</p><ul><li>getImagePath学过内容提供器会知道这个就是通过内容提供器来获取数据。通过这个uri以及selection获取到一个Cursor对象。Cursor是什么呢？不了解的读者可以查看这篇博客<a href="https://www.jianshu.com/p/2fc0d39bd2f6" target="_blank" rel="noopener">Android中的Cursor</a>。然后通过这个Cursor对象的MediaStore.Images.Media.DATA这个参数就可以获取到真实路径了。</li><li>displayImage这个方法收一个真实路径字符串，直接通过BitmapFactory.decodeFile这个方法获取到Bitmap再显示出来就行了</li></ul><p>了解了工具方法后，我们的目的就很明确啦：content类型的uri或者真实路径的String。<br>首先是版本低于4.4的，因为返回的是真实的uri，也就是content开头的那个，所以直接通过getImagePath获取真实路径再通过displayImage展示即可。</p><p>接下来这个可能看起来有点头疼，因为要解析不同类型的Uri。我们一个个来看：</p><ul><li><p>第一种是document类型的uri。至于什么是document类型的uri这里就不深入了，只要知道有这种类型的uri，要怎么处理就好了。首先我们要获取一个DocumentId，然后再分两种情况处理：<br>第一种的是media格式的，然后我们要取出后半截字符串我们才能获取到真正的id，这里就真正的id指的是对应数据库表中的id，用于selection的。MediaStore.Images.Media.EXTERNAL_CONTENT_URI就是这个照片的content类型uri，再把selection放进去即可。<br>第二种通过ContentUris.withAppendedId这个方法即可获取到content类型的uri，这个方法负责把id和contentUri连接成一个新的Uri。这个方法在这里也不详细讲解。</p></li><li><p>第二种的是content类型的，那不用说直接用就行了</p></li><li><p>第三种的是file类型的，这个就是真实路径了，直接getPath就可以获取到了。</p></li></ul><p>好了，到此我们的所有疑问也就解决了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>看完之后是不是发现思路很简单但是实现起来很多的知识盲区呢？确实是这样。但是当我们把这些细节都解决了之后我们就会学到很多的东西，相当于以点带面。文中还有好多没有详解的：<br> ContentUris，BitmapFactory，Cursor，DocumentsContract等等。因为这是另外一块比较大的内容，如果要讲的话将会涉及到很多内容就很容易偏离我们的主题了，所以只要知道大概是什么就可以了。<br>·<br>·<br>·</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《第一行代码》郭霖</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Activity启动模式简析</title>
    <link href="/2020/04/21/Android/Android%E4%B8%ADActivity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90/"/>
    <url>/2020/04/21/Android/Android%E4%B8%ADActivity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平常我们启动活动的时候就是直接startActivity或许并没有注意活动的启动模式，默认情况下都是以默认的启动模式启动。但启动模式有时候是比较重要的。例如一个活动你想他只启动一次不要有多个实例，那么你可能需要把他设置为singleTask模式。所以有必要了解一下这一些启动模式。同时要注意一下，启动模式≠启动方式，启动方式是指显示启动和隐式启动，不要混淆，显示启动和隐式启动后续我会有专门的文章讲解。</p><h1 id="关于任务栈简介"><a href="#关于任务栈简介" class="headerlink" title="关于任务栈简介"></a>关于任务栈简介</h1><p>要了解启动模式，首先要了解一下关于任务栈的概念。关于任务栈的实现原理等我在这里就先不说了，这里主要简单介绍一下什么是任务栈。我们启动的活动实例都会放在一个叫做任务栈的东西里面。我们都知道栈是“后进先出”的特点。打个比方，任务栈就是一个羽毛球筒，活动实例就是一个个羽毛球，后放进去的只能先拿出来。所以当我们启动一个app的时候，就会自动创建一个任务栈，然后我们就往里面丢活动实例。当我们按返回销毁活动的时候，这些活动就依次从任务栈里面出来。当然，一个app可以拥有多个任务栈，例如使用singleInstence启动的活动就是在一个独立的任务栈中。了解完任务栈的概念，接下来就可以来看看活动的四种启动模式。</p><h1 id="解析Activity的四种启动模式"><a href="#解析Activity的四种启动模式" class="headerlink" title="解析Activity的四种启动模式"></a>解析Activity的四种启动模式</h1><h3 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h3><p>这种是标准启动模式，默认就是这种启动模式。每次启动这种启动模式的活动的时候都会创建一个新的实例放入栈中，不管栈中是否已经存在相同的实例。这也是最容易理解的。</p><h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h3><p>顾名思义，栈顶是单一实例的。什么意思呢。假设你现在启动一个ActivityA，但是这个时候已经存在一个ActivityA实例在栈顶，那么这个时候，就不会创建新的实例。但是如果，在非栈顶存在相同的实例，还是会创建新的实例的。例如，现在栈中的活动是 ABC，A处于栈顶。然后此时启动A，是不会再创建一个A活动出来，而是执行A的onNewIntent方法；但是如果此时启动C活动，由于栈顶是A不是C，那么还是会创建一个新的C实例出来，此时的栈情况就是CABC。</p><h3 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h3><p>单一任务模式。这个模式的意思是，在该活动的启动栈中，只能存在单一实例，不管是否位于栈顶。与其他启动模式不同的是，这个启动模式可以指定栈去启动。例如现在有一个栈Main，但是你可以给活动A指定一个栈名dev，那么启动A的时候就会创建一个栈叫做dev。所以singleTask的意思就是，当你启动一个启动模式为singleTask的活动的时候，如果栈中没有相同的实例，那么就会创建一个新的实例放入栈中；如果指定栈中存在相同的实例，例如栈中有ABC，然后你启动B，那么这个时候不会去创建新的B实例，而是把B放到栈顶，并把A顶出去，再执行B的onNewIntent方法，此时栈的情况就是BC。<br>细心的读者会发现“顶出去”。是的，我们都知道栈是后进先出的特点，例如你往筒里放了3个羽毛球，那你想要拿到中间那个羽毛球，是不是只能先把上面那个抽出来呢，同样的道理，要想把B提到栈顶，那么必须把A顶出来。可能会有很多读者误以为启动后是BAC，但其实是BC，因为A得先出栈，B才能出来。同理，如果栈中是ADFBC，这个启动B，也是BC，上面的全部被出栈了。</p><h3 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h3><p>单例模式。这个是singleTask的强化版本。他会自己新建一个栈并把这个新的实例放进去，而且这个栈只能放这个活动实例。所以当重复启动这个活动的时候，只要他存在，都是调用这个活动onNewIntent方法并切换到这个栈中，并不会去创建新的实例。</p><h1 id="设置启动模式的两种方法"><a href="#设置启动模式的两种方法" class="headerlink" title="设置启动模式的两种方法"></a>设置启动模式的两种方法</h1><p>了解了活动的四种启动模式，接下来看看如何给他指定启动模式。</p><h3 id="静态设置"><a href="#静态设置" class="headerlink" title="静态设置"></a>静态设置</h3><p>静态设置就是在AndroidManifest中给具体活动设置启动模式。通过给活动指定launchMode参数来设置启动模式。例如：</p><pre><code class="hljs java">&lt;activity android:name=<span class="hljs-string">".MainActivity"</span>           android:launchMode=<span class="hljs-string">"singleInstance"</span>/&gt;</code></pre><h3 id="动态设置"><a href="#动态设置" class="headerlink" title="动态设置"></a>动态设置</h3><p>动态设置是在启动活动的时候再指定启动模式，例如：</p><pre><code class="hljs java">Intent intent = <span class="hljs-keyword">new</span> Intent();intent.setClass(<span class="hljs-keyword">this</span>,SecondActivity<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);startActivity(intent);</code></pre><p>可以看到我们通过intent.addFlags这个方法来指定启动模式，这个方法传入一个参数来指定启动模式，其他的参数有：</p><ul><li>FLAG_ACTIVITY_NEW_TASK：singleTask模式</li><li>FLAG_ACTIVITY_SINGLE_TOP：singleTop模式</li><li>FLAG_ACTIVITY_CLEAR_TOP:清除该活动上方的所有活动。一般和singleTask一起使用。但是如果你的启动模式是standard，那么这个活动连他之上的所有活动都会被出栈再创建一个新的实例放进去。例如现在栈中是ABCD，以FLAG_ACTIVITY_CLEAR_TOP+standard模式启动C的时候，首先清理掉ABC，是的，C也会被清理，然后再创建一个新的C放进去，执行之后就是CD。<h1 id="特别注意的坑"><a href="#特别注意的坑" class="headerlink" title="特别注意的坑"></a>特别注意的坑</h1><h3 id="singleInstance返回任务栈"><a href="#singleInstance返回任务栈" class="headerlink" title="singleInstance返回任务栈"></a>singleInstance返回任务栈</h3>现在模拟一个场景：现在有三个活动 A,B,C。A和C的启动模式都是standard，B的启动模式是singleInstance。先启动A，再启动B，然后再启动C。这个时候问题来了，如果我这个时候按下返回键，是回到B吗？答案是回到A。再按一下呢，返回桌面吗？答案是回到B，再按一下再回到桌面。其实不难理解。我们都知道singleInstance会创建一个独立的栈，当我们启动A的时候，A位于栈First中，启动B的时候，就会创建一个栈Second并把B实例放进去。这个时候再启动C，就会切换到栈FIrst，因为singleInstance创建的栈只能放一个，所以C会放到栈First中，当按下返回的时候，栈First中的活动就会依次出栈，直到全部出完，才会切换到栈Second中。所以要注意这个点。<h3 id="singleTask多任务栈启动问题"><a href="#singleTask多任务栈启动问题" class="headerlink" title="singleTask多任务栈启动问题"></a>singleTask多任务栈启动问题</h3>这个问题和上面singleTop的本质是一样的。模拟一个场景：现在有两个栈：First：ABC；Second：QWE。栈First位于前台，栈Second位于后台。A位于栈顶。这个时候以singleTask的模式启动W，会发生什么样的情况呢？首先会切换到栈Second，再把Q出栈，W提到栈顶，并执行W的onNewIntent方法。这个时候按返回键就会把Second栈中的活动依次出栈，全部出完后才会切换到栈First。<h3 id="singleTask的TaskAffinity与allowTaskReparenting参数"><a href="#singleTask的TaskAffinity与allowTaskReparenting参数" class="headerlink" title="singleTask的TaskAffinity与allowTaskReparenting参数"></a>singleTask的TaskAffinity与allowTaskReparenting参数</h3>前面我们讲到给singleTask模式指定要启动的任务栈的名字，怎么指定呢？可以在AndroidManifest中指定相关的属性，如下：<pre><code class="hljs java">&lt;activity android:name=<span class="hljs-string">".Main2Activity"</span>            android:launchMode=<span class="hljs-string">"singleTask"</span>            android:taskAffinity=<span class="hljs-string">"com.huan"</span>            android:allowTaskReparenting=<span class="hljs-string">"true"</span>/&gt;</code></pre>这里解释一下这两个参数</li><li>taskAffinity：指定任务栈的名字。默认的任务栈是包名，所以不能以包名来命名。</li><li>allowTaskReparenting：这个参数表示可不可以切换到新的任务栈，通常设置为true并和上面的参数一起使用。<br>我前面讲到可以给singleTask的活动指定一个栈名，然后启动的时候，就会切换到那个栈，并把新的活动放进去。但是如果设置allowTaskReparenting参数为false的话是不会切换到新的栈的。这个参数的意思是可不可以把新的活动转移到新的任务栈。简单点来说：当我们启动一个singleTask活动的时候，这个活动还是留在启动他的活动的栈中的。但是我们指定了taskAffinity这个参数，或者启动的活动是别的应用中的活动，那么就会创建一个新的任务栈。如果allowTaskReparenting这个参数是true的话，那么这个活动就会放到那个新的任务栈中。这样应该就可以明白了。所以这两个经常是配套一起使用的。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> 活动的启动模式有四种，每种的功能都不一样，可以结合具体需要去使用，但是最重点还是要了解他的实现原理，栈中是怎么变化的，这个是比较重要的。了解这个之后那些特殊情况也就很容易理解了。<br> 上面我讲的只是简单的使用，关于活动启动模式还有很多要了解。后续可能会解析一下，读者也可以自行去深度了解。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《Android开发艺术探索》 –任玉刚</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>json数据与String的互相转换</title>
    <link href="/2020/04/21/other/json%E6%95%B0%E6%8D%AE%E4%B8%8EString%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/"/>
    <url>/2020/04/21/other/json%E6%95%B0%E6%8D%AE%E4%B8%8EString%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>﻿json数据本质上也是字符串，所以他们之间的转换也是比较容易的，记住方法和需要注意的事项就行了。</p><h4 id="字符串转json"><a href="#字符串转json" class="headerlink" title="字符串转json"></a>字符串转json</h4><p>在构造json的对象时候把string对象传进去即可。看例子</p><pre><code class="hljs java">String data = <span class="hljs-string">"&#123;</span><span class="hljs-string">    "</span>result<span class="hljs-string">":"</span>success<span class="hljs-string">",</span><span class="hljs-string">    "</span>message<span class="hljs-string">":null</span><span class="hljs-string">    &#125;"</span>;<span class="hljs-keyword">try</span> &#123;JSONObject jsonObect = <span class="hljs-keyword">new</span> JSONObject(data);&#125; <span class="hljs-keyword">catch</span> (JSONException e)&#123;    e.printStackTrace();&#125; <span class="hljs-keyword">catch</span>(NullPointerException e)&#123;e.printStackTrace();&#125;</code></pre><p>这里建立jsonObject对象的时候因为不确定该字符串是否符合json规范，如果不符合规范就会抛出JSONException异常，而如果该字符串是null的时候就会抛出空指针异常。这里也可以判断一下字符串是否为空防止空指针异常。</p><h4 id="json数据转字符串"><a href="#json数据转字符串" class="headerlink" title="json数据转字符串"></a>json数据转字符串</h4><p>这个就比较容易了，直接调用jsonObject对象的toString方法即可。看代码</p><pre><code class="hljs java"><span class="hljs-comment">//这里的jsonObject是上文的JSONObject对象</span>String s = jsonObect.toString();</code></pre>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>json</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
