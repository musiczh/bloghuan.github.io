<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>kotlin/协程的结构化管理</title>
      <link href="/2020/06/26/kotlin/%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%BB%93%E6%9E%84%E5%8C%96%E7%AE%A1%E7%90%86/"/>
      <url>/2020/06/26/kotlin/%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%BB%93%E6%9E%84%E5%8C%96%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>kotlin/kotlin协程的具体使用</title>
      <link href="/2020/06/26/kotlin/kotlin%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/06/26/kotlin/kotlin%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>kotlin/和线程的那些事</title>
      <link href="/2020/06/26/kotlin/%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
      <url>/2020/06/26/kotlin/%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>kotlin/kotlin协程到底有多方便</title>
      <link href="/2020/06/26/kotlin/kotlin%E5%8D%8F%E7%A8%8B%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E6%96%B9%E4%BE%BF/"/>
      <url>/2020/06/26/kotlin/kotlin%E5%8D%8F%E7%A8%8B%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E6%96%B9%E4%BE%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="『彻底弄懂kotlin协程系列』–kotlin协程到底有多方便？"><a href="#『彻底弄懂kotlin协程系列』–kotlin协程到底有多方便？" class="headerlink" title="『彻底弄懂kotlin协程系列』–kotlin协程到底有多方便？"></a>『彻底弄懂kotlin协程系列』–kotlin协程到底有多方便？</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>kotlin/和线程那些事</title>
      <link href="/2020/06/26/kotlin/%E5%92%8C%E7%BA%BF%E7%A8%8B%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
      <url>/2020/06/26/kotlin/%E5%92%8C%E7%BA%BF%E7%A8%8B%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="『彻底弄懂kotlin协程系列』–关于挂起与恢复的认识"><a href="#『彻底弄懂kotlin协程系列』–关于挂起与恢复的认识" class="headerlink" title="『彻底弄懂kotlin协程系列』–关于挂起与恢复的认识"></a>『彻底弄懂kotlin协程系列』–关于挂起与恢复的认识</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>阅读之前建议去看一下我的上一篇文章关于什么是kotlin协程的讲解。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>kotlin/什么是kotlin协程</title>
      <link href="/2020/06/24/kotlin/%E4%BB%80%E4%B9%88%E6%98%AFkotlin%E5%8D%8F%E7%A8%8B/"/>
      <url>/2020/06/24/kotlin/%E4%BB%80%E4%B9%88%E6%98%AFkotlin%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="『彻底弄懂kotlin协程系列』–什么是kotlin协程？"><a href="#『彻底弄懂kotlin协程系列』–什么是kotlin协程？" class="headerlink" title="『彻底弄懂kotlin协程系列』–什么是kotlin协程？"></a>『彻底弄懂kotlin协程系列』–什么是kotlin协程？</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>kotlin是一门比较新的语言了，自动被谷歌设为android开发的官方语言后，他的趋势大好，使用的人也越来越多。在kotlin中，有很多新的特性，有好用的，也有不太习惯的，但，协程绝对是让我们又爱又恨的。会用的程序员说他很好用，但是入门的学习门槛又好像挺高的，一不小心还绊倒了。</p><p>我使用了kotlin一阵子之后，对协程也有了一定的了解，写下这一系列的文章来介绍一下协程，当是分享也是给我自己加深印象。我不是业界仅仅只是一个爱编程的程序猿，有不同的见解，还请评论区一起交流或者私信。</p><p>因为kotlin我目前是应用在android开发，所以这一系列的文章也是以android开发为主。。那话不多说，直接开始把</p><h3 id="协程是什么？"><a href="#协程是什么？" class="headerlink" title="协程是什么？"></a>协程是什么？</h3><p>要了解kotlin的协程，可以先来看一下广义中协程的特点是怎么样的。线程和进程我们都很清楚是什么，协程在网上的很多资料也讲了很多。用户态、非阻塞、高性能等等。但是，协程到底是什么？协程是一种对于并发的处理方案。这里要区分一下并行和并发。</p><ul><li>并行：两个任务同时执行，多线程就是这个道理。</li><li>并发：多端同时请求同个对象。例如消费者和生产者模型，同时都要拿到那个容器来进行操作</li></ul><blockquote><p>生产者消费者模型：这个模型是非常经典的。简单点来说就是：现在有一个篮子，A往里面放苹果，B从篮子里取苹果吃，当篮子满了，A会等着，篮子空了，B会等着。这样就是这个模型的大致。但是有几个问题</p><ul><li>如果A和B同时对篮子进行操作，那么篮子里面的苹果会处于不正常的状态。例如当B拿到篮子的副本取出一个苹果，同时A也拿到篮子，存了一个进去，B吃完更新了篮子的状态，然后A再更新状态回去，这个时候篮子中被B 吃掉的苹果就会回来了。出现了错误。</li><li>如果对篮子进行加锁，那么假如篮子是空的，B拿到篮子后，就会等着，而A因为拿不到锁，就会一直等着锁，造成了死锁问题</li></ul></blockquote><p>所以从上面的例子可以看到并发产生的问题，是非常多的，上面只是冰山一角。那协程如何处理这个问题呢？</p><p>协程，顾明思义，协作线程，协程是在线程下粒度更小的程序。他可以在程序运行到某个时刻，先挂起，执行别的程序，然后等到合适的情况再回来继续执行。例如上面的生产者消费者，因为生产和消费处于不同的线程，所以，会导致并发问题。而协程处于单线程，所以没有了并发，那单线程如何并行执行任务呢？</p><p>我们可以先运行B ，去拿到篮子进行取苹果，然后取一半停下来，先去A 那里生产苹果，A生产了，再回来继续执行B的取苹果，吃完苹果取下一个的时候停下来，再重复同样的操作，通过不断地跳跃代码执行的顺序，实现了代码的“并行”，但不是真正的并行，因为是单线程的，所以不存在并行，只是看起来是“并行的”。</p><p>举个栗子，下面是伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">coroutine1：</span><br><span class="line">while(true)&#123;</span><br><span class="line">apple &#x3D; yield &#x2F;&#x2F;1</span><br><span class="line">eat(apple)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">coroutine2：</span><br><span class="line">while(true)&#123;</span><br><span class="line">apple.send(new apple) &#x2F;&#x2F;2</span><br><span class="line">product</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是运行在同个线程的，同运行到1的时候，这个代码所在的协程被挂起，然后执行下面的协程，然后到了2的时候，就返回到协程1，吃完苹果循环又回到了协程2继续执行代码，就这样不断在两个协程之间切换代码执行顺序。实现了看似并并的情况。</p><p>所以我们可以看到协程他是：</p><ul><li>单线程的</li><li>通过控制代码的执行顺序实现“并行”但不是真正的并行</li><li>解决了并发问题，因为单线程不会出现并发</li><li>比线程性能更高，因为他只是通过程序控制了代码的执行顺序，并没有通过操作系统去切换线程，也就是他是“用户态”的</li></ul><p>但是：</p><ul><li>当协程被阻塞的时候，整个线程都会被阻塞</li><li>协程不能处理耗时任务，不然会阻塞线程</li></ul><p>到此我们对协程是什么已经有了一个大概的认识。笔者对于协程的认识只是冰山一角，上述解释有误，还请指出。</p><h3 id="那kotlin中的协程又是什么？"><a href="#那kotlin中的协程又是什么？" class="headerlink" title="那kotlin中的协程又是什么？"></a>那kotlin中的协程又是什么？</h3><p>我们前面讲过，kotlin是基于jvm’的语言，但jvm我们知道，java是不支持协程的啊，也就是.class文件是没有协程的支持的，而kotlin最终是要编译成.class，那kotlin自然是不支持协程，可是kotlin协程，为什么还存在呢？他到底是什么？</p><p>对，kotlin是不支持我上面讲的广义中的协程的本质的，因为jvm是不支持的。但是kotlin的协程，本质上是<strong>一种线程框架</strong>。kotlin通过自动切换线程，来实现协程的优良特性。</p><p>举个栗子，（kotlin代码，不要纠结具体语法细节）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个线程，执行两个方法</span></span><br><span class="line">GlobalScope.launch&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">getApples() </span><br><span class="line">eatApples()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取苹果的方法</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getApples</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//切换到IO线程</span></span><br><span class="line">    withContext(IO线程)&#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>)</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//吃苹果的方法</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eatApples</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面我在kotlin的一个协程内实现了一个循环：先取苹果，再吃苹果。</p><p>我们会发现我们是直接线性写下来的，按照我们的常规思路，这两个方法都不能是耗时的，如果是耗时的那么需要进行别的线程运行逻辑然后回调对吧，但是我们发现，获取苹果的方法是耗时（Thread.sleep(3000)）的，那这样写不就会阻塞线程吗？这才是kotlin协程的巧妙之处。</p><p>前面我讲过了，kotlin协程是一个线程框架，他会自动切换线程。我们看到获取苹果的方法里面，我们手动切换到了IO线程执行耗时逻辑，但是居然不用回调吃苹果的方法，这样不就会让吃苹果的方法先执行了吗？不会的，kotlin协程，会在获取苹果的那个地方先挂起，然后等到获取完苹果，<strong>再回到协程所在的线程</strong>，注意这里吃苹果方法的线程是切回来了，继续执行吃苹果方法，而且不会阻塞线程，因为是在别的线程执行耗时逻辑。</p></blockquote><p>通过上面的一个例子，我们应该可以大概理解了，原来kotlin的协程就是，会自动跳转线程，然后完事还会回到现在的线程，消灭了回调，我们可以用非阻塞的写法来实现阻塞逻辑。是的，如果能了解到这个点，那么我的文章也是有所作用了。</p><h3 id="再了解kotlin协程"><a href="#再了解kotlin协程" class="headerlink" title="再了解kotlin协程"></a>再了解kotlin协程</h3><p>我们可以发现kotlin的协程和广义的协程在使用上是很像的，都是实现了代码的挂起和恢复。只是他们的本质是不同的。kotin的协程把代码挂起不阻塞线程，然后跑去别的线程执行逻辑，然后搞定了再回来继续执行剩下的逻辑，当然，剩下的逻辑也可以进行挂起。而广义的协程是在单线程内进行代码挂起，可以随意调整代码的执行顺序，而kotlin协程，是没有办法做到这一点的，在jvm上无法随意调整代码的执行顺序。</p><p>我们可能有疑问：这样切换线程，是不是开销很大？答案是肯定的，但也不是非常大。这里涉及到源码设计问题，我也不是很理解我就简单说一下我所认识的内容。kotlin内部是维护一个线程池来实现线程切换的，所以他的成本会低了很多。而在线程切换上，底层还是使用Handle来进行切换线程。我前面讲到，kotlin协程他是线程框架，所以他也只是把线程池和handle封装了起来。</p><p>那是不是协程就没啥卵用了？不不不，一个框架最重要的是什么？方便！kotlin协程的方便，超乎你想像。这一个文章就不介绍太多已经两千多字了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这篇文章我们了解了两个点：什么是广义的协程，什么是kotlin的协程。广义的协程是指在代码中调整代码的执行顺序，在单线程解决并发问题，但是不能解决阻塞问题。kotlin的协程由于jvm的限制，他封装线程来实现代码的挂起，用非阻塞的写法来实现阻塞逻辑，但是由于是用到切换线程，所以性能上会比较差。</p><p>如果通过这篇文章你对协程有了新的认识，那么我就满足了。另外，协程他到底有多方便？协程要怎么用？协程他怎么指定线程？协程他怎么知道哪个方法是需要挂起的？上面你写的suspend关键字到底是啥？（没看见suspend，回去看一下例子代码）等等。我都会在我的系列文章更新。欢迎交流。</p><p>文章到此就结束了，有帮助还请点个赞，评个论，收个藏，转个发，谢谢。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法：判断链表是否有环</title>
      <link href="/2020/06/13/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/"/>
      <url>/2020/06/13/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="题目：判断链表是否有环"><a href="#题目：判断链表是否有环" class="headerlink" title="题目：判断链表是否有环"></a>题目：判断链表是否有环</h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>说明：不允许修改给定的链表。</p><p>示例 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：tail connects to node index 1</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle-ii</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>经典问题，这就不考虑哈希表直接用快慢指针了。因为他们的之间并没有一个思维的转换过程而是属于两种思维。</p><p>快慢指针，就是追及问题。我们假设快指针一次走两步，慢指针一次走一步，如下图（图片来自<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii" target="_blank" rel="noopener">leetcode</a>）</p><p><img src="https://img2020.cnblogs.com/blog/1961534/202006/1961534-20200613174021128-445007250.png" alt=""></p><p>在最右边的点第一次相遇。我们运用等式关系可得： 2(F+a) = F+a+k(a+b)</p><p>这里的K是表示在相遇前，快指针走了几次环，k&gt;=1。然后进行化简就可以得到 F = n(a+b)-a  。那也就是F的长度是整数倍（a+b）然后再减去a。这样的话，设置两个指针，一个从原点开始，一个从第一次相遇的点开始，一次递增，最终就会在入口处相遇。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (fast.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;<span class="keyword">while</span> (slow != fast);</span><br><span class="line"></span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span> (slow!=fast)&#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>假设链表的长度是n</p><ol><li>时间复杂度：一共需要2F+a，最坏的情况是入口在末端，需要遍历两次链表</li></ol><blockquote><p>时间复杂度：O(n）</p></blockquote><ol start="2"><li>空间复杂度：只需要指针常量空间</li></ol><blockquote><p>空间复杂度：O（1)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：每日温度</title>
      <link href="/2020/06/12/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/"/>
      <url>/2020/06/12/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="题目：每日温度"><a href="#题目：每日温度" class="headerlink" title="题目：每日温度"></a>题目：每日温度</h3><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/daily-temperatures" target="_blank" rel="noopener">https://leetcode-cn.com/problems/daily-temperatures</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>很经典的单调栈题目。思路很简单。还是老方法，算法题，首先从暴力算法开始。</p><p>暴力法：我们遍历数组，然后例如 [73, 74, 75, 71, 69, 72, 76, 73]，首先到73，然后就要找到比他大的第一个数，找到74，然后下标相减，得到1；继续遍历下去就可以。但是这样的话复杂度肯定是太高了。</p><p>仔细观察会发现，暴力法之所以太复杂，是因为没有记录每一次的遍历结果。例如在75的时候，当一直往下遍历到72的时候，其实71和69已经确定了；当到76的时候，72也确定了，最后才确定75，先进后出，这不就是栈吗？</p><p>依次遍历数组，如果栈顶元素的数比当前大，则入栈，如果小，则依次出栈，直到栈空。要注意的是，最后要把栈中的元素全部出栈。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">        <span class="keyword">if</span> (T.length==<span class="number">0</span>) <span class="keyword">return</span> array;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;T.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> top ;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; T[stack.peek()]&lt;T[i])&#123;</span><br><span class="line">                top = stack.pop();</span><br><span class="line">                array[top] = i - top;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            array[stack.pop()] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>假设数组的长度是n</p><ol><li>时间复杂度：遍历一次数组</li></ol><blockquote><p>时间复杂度：O(n）</p></blockquote><ol start="2"><li>空间复杂度：栈的深度和新建数组的大小都是T的长度</li></ol><blockquote><p>空间复杂度：O（n)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：把数字翻译成字符串</title>
      <link href="/2020/06/09/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/06/09/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目：把数字翻译成字符串"><a href="#题目：把数字翻译成字符串" class="headerlink" title="题目：把数字翻译成字符串"></a>题目：把数字翻译成字符串</h3><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p>示例 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这道题其实思路不难了。经典的动态规划题目。这道题的另一个出题的方向就是算能转换成最多的字符个数。道理是一样的。</p><p>动态规划最核心是什么？动态转换方程。对，<strong>一定要完全理解好这个方程，否则就会一直出错</strong>。这道题中每一个数，如果和他上一个数合起来成为两位数，如果这个两位数在10-25之间，那么这个位置所能表示的最多翻译方法是上一个位置的数目+上上一个位置的数目。我们来看看为什么。</p><p>例如有12258</p><ul><li>首先得到1，那么只有一种可能。</li><li>得到2，那么有两种可能：一种是2保持本身得到一个字符，那么这种情况下的个数就是和前一个位置一样；第二种情况是和1合并成为12，所以一共有1+1=2种可能。</li><li>再次得到2 ，和上面的步骤二相同，1+2=3种</li><li>得到5,2+3=5</li><li>得到8，这里就不一样了，因为58不能表示为字符，所以只能8单独作为一个字符，所以和上个位置一样：5.</li></ul><p>所以整个转态转换可以理解了吧。判断两位是否可以成为一个字符，然后再代入转态转换方程即可。</p><p>这个思想有两种实现方式：迭代和递归。两种方式都很好理解，思想是一样的，看下面代码就可以理解了。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="方法一：迭代"><a href="#方法一：迭代" class="headerlink" title="方法一：迭代"></a>方法一：迭代</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (num&lt;<span class="number">10</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        String s = String.valueOf(num);</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">        array[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        array[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i-<span class="number">2</span>)&gt;<span class="string">'2'</span>||s.charAt(i-<span class="number">2</span>)&lt;<span class="string">'1'</span>) array[i] = array[i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i-<span class="number">2</span>)==<span class="string">'2'</span>&amp;&amp;s.charAt(i-<span class="number">1</span>)&gt;<span class="string">'5'</span>) array[i] = array[i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span>  array[i] = array[i-<span class="number">1</span>]+array[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> array[array.length-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num&gt;<span class="number">9</span>&amp;&amp;num&lt;<span class="number">26</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (num&lt;<span class="number">100</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (num%<span class="number">100</span>&lt;<span class="number">26</span>&amp;&amp;num%<span class="number">100</span>&gt;<span class="number">9</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> translateNum(num/<span class="number">10</span>)+translateNum(num/<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> translateNum(num/<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>假设num的大小是n</p><ol><li>时间复杂度：我们需要遍历数字num的长度</li></ol><blockquote><p>时间复杂度：O(logn）</p></blockquote><ol start="2"><li>空间复杂度：栈的深度和新建数组字符串的大小都是num的长度</li></ol><blockquote><p>空间复杂度：O(logn)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：最长连续序列</title>
      <link href="/2020/06/09/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/"/>
      <url>/2020/06/09/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题目：最长连续序列"><a href="#题目：最长连续序列" class="headerlink" title="题目：最长连续序列"></a>题目：最长连续序列</h3><p>给定一个未排序的整数数组，找出最长连续序列的长度。</p><p>要求算法的时间复杂度为 O(n)。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [100, 4, 200, 1, 3, 2]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-consecutive-sequence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-consecutive-sequence</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>找到一组数的集合，我们想一下可能有的方法，动态规划？貌似没有状态转移方程可以写；滑动窗口？他不是连续的子数组。</p><p>首先依然是暴力：遍历每个数，找到每个数的时候，再遍历数组看看有没有下个数，然后再遍历，再看看有没有下个数，三次循环就可以得到以每个数为起点的最长字段。ok我们发现，复杂度是O(n^3)。这是不可接受的。然后我们来进行优化。</p><p>我们在查找每个数的下继，例如得到2 ，那我们就要看看有没有3。这种情况能不能进行优化？答案是可以的，用哈希表。我们把每个数当成key值放进哈希表，然后只要直接查询该数是否存在即可。哈希表的查询复杂度是O(1)所以这里就降低成为了O(n^2)。显然还不够，我们继续优化。</p><p>我们会发现，如果存在2,3,4,5这个集合，那么我们会轮流都去以2,3,4,5为最小值去寻找最长字符串。例如一个数组是[2,3,4,5]。第一次在下标0得到2，然后继续寻找直到得到2,3,4,5.然后第二次来到下标1得到3，我们会继续去寻找得到3,4,5，但其实，我们前面的2,3,4,5已经包含了他，所以我们不用再去寻找一遍了。所以问题来到，我们如何去记录已经得到的遍历结果？显然记录的话会有额外的空间成本，这是必然的，否则就是进行状态转换，但是显然不太行（或者你有思路可以留言分享一下）。我们会发现3,4,5之所以不行是因为前面还有一个2对不对？那么我们在遍历的时候，只需要找还有没有前继，如果没有就进行寻找最长字符串，如果有，就跳过。这样下来每个字符在形成最长连续序列中只会遍历一次，所以也就压缩了时间复杂度成为O（n）</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">     Set&lt;Integer&gt; num_set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">         num_set.add(num);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> longestStreak = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> num : num_set) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!num_set.contains(num - <span class="number">1</span>)) &#123;</span><br><span class="line">             <span class="keyword">int</span> currentNum = num;</span><br><span class="line">             <span class="keyword">int</span> currentStreak = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">while</span> (num_set.contains(currentNum + <span class="number">1</span>)) &#123;</span><br><span class="line">                 currentNum += <span class="number">1</span>;</span><br><span class="line">                 currentStreak += <span class="number">1</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             longestStreak = Math.max(longestStreak, currentStreak);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> longestStreak;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ol><li>时间复杂度：我们需要遍历数组，在形成最长连续序列中每个数都要遍历一次</li></ol><blockquote><p>时间复杂度：O(n）</p></blockquote><ol start="2"><li>空间复杂度：只需要一个哈希表</li></ol><blockquote><p>空间复杂度：O(n)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：合并两个有序链表</title>
      <link href="/2020/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E8%BF%90%E8%BE%93%E5%B1%82/"/>
      <url>/2020/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E8%BF%90%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络-–-运输层"><a href="#计算机网络-–-运输层" class="headerlink" title="计算机网络 – 运输层"></a>计算机网络 – 运输层</h1><h2 id="运输层协议概述"><a href="#运输层协议概述" class="headerlink" title="运输层协议概述"></a>运输层协议概述</h2><h3 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信"></a>进程之间的通信</h3><ol><li><p>什么是运输层？</p><p>网络层是解决主机与主机之间的通信，例如我的手机和你的手机之间的数据连通。但是手机中有微信，qq，王者荣耀，你一边更新王者荣耀一遍发微信，你的手机同时接收的数据包，怎么知道这些包是微信的还是王者的呢？这就是运输层做的事情：提供进程之间的通信。</p></li><li><p>和网络层以及应用层的关系？</p><p>运输层是提供一条进程之间的逻辑线路，让进程之间去通信，是比网络层更上层的协议。在路由转发中只涉及到网络层。同时运输层也是用户感知的最底层，他是直接和应用层进行连接。</p></li></ol><h3 id="运输层两个重要协议"><a href="#运输层两个重要协议" class="headerlink" title="运输层两个重要协议"></a>运输层两个重要协议</h3><ol><li><p>概述</p><p>两个比较重要的协议。但是要注意和网络层的协议区分开。这里的协议指的是端对端的，是应用和主机端口之间的通信协议，而不是在路由转发中的协议。</p></li><li><p>UDP</p><p>用户数据报协议。无连接而且不可靠，因为受到数据报不需要回复。但是优点是开销小。</p></li><li><p>TCP</p><p>传输控制协议。面向连接且可靠的，但是缺点是开销比较大。而且连接的特性决定了不能进行广播和多播。</p></li></ol><h3 id="运输层的端口"><a href="#运输层的端口" class="headerlink" title="运输层的端口"></a>运输层的端口</h3><ol><li><p>什么是端口？</p><p>这个其实很好理解。因为运输层是应用程序和主机之间的逻辑通信，所以每个应用程序应该有一个标识，就像IP地址一样，不然怎么知道数据报给哪个应用呢。所以主机拿到数据报，解析一下端口号，例如80，然后就把数据给80这个端口，然后使用这个端口的应用程序就可以拿到数据了。但是有一个点是要注意的：端口是固定的但是应用程序是动态的，所以也就保证了应用程序不断切换，例如后台杀死重建啊什么的，但是依然可以接收到数据。只要使用同一个端口即可。</p></li><li><p>运输层端口和链路层的端口有什么区别？</p><p>运输层的端口是只有本都意义的，在互联网上没有任何意义。而链路层的路由器上面的端口是硬件端口，是不同设备之间的连接。而运输层的端口只是为了标识应用程序。</p></li><li><p>两大类端口</p><ul><li>服务端使用的端口：服务端嘛，就是要稳定，不然一直换端口别人就受不了了。所以服务端的端口特点就是稳定，数值也比较少。</li><li>客户端的端口：数值比较大，但是不稳定，所以数量多。</li></ul></li></ol><h2 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol><li><p>UDP有什么作用：</p><p>UDP十分简单。我们知道，应用程序把数据报给到传输层，而UDP只是吧应用程序给的数据报加个头部就给网络层去转发了。头部主要是标记源端口和目的端口，以及检验正确性。</p></li><li><p>UDP的特点：</p><ul><li>他是不可靠的。因为只是把数据加个头就发过去，也没有错误重发什么的。所以只是尽量交付，而不是可靠交付。</li><li>UDP是无连接的。这个从他的工作原理可以看出来。</li><li>UDP是面向报文的。UDP主要就是处理报文然后给网络层去转发。</li><li>UDP没有拥塞控制。因为没有重发，也就不需要拥塞控制了。</li></ul><p>但是</p><ul><li>UDP开销比较小。因为没有花里胡哨的工作。</li><li>UDP的速度比较快，不用去创建连接直接就可以用了。</li><li>UDP支持一对多或者多对多。</li></ul></li></ol><h3 id="UDP头部"><a href="#UDP头部" class="headerlink" title="UDP头部"></a>UDP头部</h3><ol><li>组成：三部分：源端口目的端口，长度和校验码</li><li>伪头部：用于创建检验码用的，伪头部主要是源IP地址，目的IP地址，协议字段值以及UDP的长度。</li></ol><h2 id="传输控制协议TCP概述"><a href="#传输控制协议TCP概述" class="headerlink" title="传输控制协议TCP概述"></a>传输控制协议TCP概述</h2><h3 id="什么是TCP"><a href="#什么是TCP" class="headerlink" title="什么是TCP"></a>什么是TCP</h3><p>这里只简单讲一下关于TCP的一些特点，具体的实现原理后面还有好多好多节去学习。简单来说，TCP是一个运输层的协议，他是<strong>面向连接</strong>的，和UDP不一样。TCP是建立一个连接，然后源源不断地发送数据过去。要注意的是这个连接是虚拟的，不是真实的物理连接。</p><h3 id="TCP的特点"><a href="#TCP的特点" class="headerlink" title="TCP的特点"></a>TCP的特点</h3><ol><li>他是面向连接的</li><li>他是点对点的，不能一对多或者多对多等</li><li>他可以提供可靠交付</li><li>提供全双工通信（两边都可以互发信息）</li><li>面向字节流</li></ol><h3 id="什么是面向字节流"><a href="#什么是面向字节流" class="headerlink" title="什么是面向字节流"></a>什么是面向字节流</h3><p>这个是TCP工作原理的重点，虽然不难，但是一定要懂。</p><p>TCP不是像UDP那样从用户那里拿数据报然后一个个发送，TCP是把这些数据看成流，在缓冲区合成一整块，然后根据网络状况，分割后加上TCP头部发送。所以说TCP是面向字节流的，因为他没有数据包的概念，用户的数据都看成流。这样的好处是TCP可以根据网络情况进行恰当地切割，防止拥塞。</p><h3 id="TCP的连接"><a href="#TCP的连接" class="headerlink" title="TCP的连接"></a>TCP的连接</h3><ol><li>TCP不是和UDP一样用端口作为点对象，而是使用socket也就是套接字为端点。套接字是什么？这个也很好理解，就是 IP+端口号。这个就可以唯一标识一个TCP连接了。</li><li>TCP的连接是由软件所提供的一种抽象，不是真正真正真正的连接。</li></ol><h2 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h2><h3 id="怎样才是可靠的？"><a href="#怎样才是可靠的？" class="headerlink" title="怎样才是可靠的？"></a>怎样才是可靠的？</h3><p>前面讲到TCP是可靠的，但是为什么TCP是可靠的？原理是什么？这一小节就比较详细地展开。这里要讲一个点，都说可靠可靠，那到底满足什么样的条件才是可靠的？</p><ol><li>在网络传输的过程中不会出现数据的损坏或者丢失。</li><li>无论发送方用怎么样的速率去传输，接收方始终可以一直接受。</li></ol><p>满足上述两个条件就可以实现可靠运输了。但是这两个条件和让你拿着一把刀去抢劫银行一样，看似好像很微妙，事实上就是吃太多作业太少成天幻想。所以我们要做的就是如何用协议去实现这样的特性，把不可靠的网络环境，实现可靠的数据传输。</p><h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><h4 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h4><ol><li>TCP对应用程序来的数据缓存后进行切割后，分成一个个数据报进行转发，每一个数据报转发给对方后就停下来，对方收到后就发送ACK告诉自己收到了，这个时候就可以发送第二个了。</li><li>如果发送的数据损坏了，或者数据在传输的时候人间蒸发了，这个时候对方什么也不做。自己就会等，等到一点时间没回复再继续发送一次，这就是超时重传。</li><li>如果对方给自己的确认ACK丢失或者迟到了了怎么办？自己还是按照超时重传再发一份，如果收到重复的数据就丢弃就行。对方收到重复的数据包也是直接丢弃。</li><li>当网络情况不好的时候，那么就会一直重发，达到一定的次数就说明当前网络不可用，停止发送。</li></ol><p>自动重传请求：上述步骤自动完成就是ARQ自动重传请求。ARQ实现了在不可靠的网络上进行可靠的数据传输。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>信道利用率很低。每次都要等，特别是网络状况不好的时候，效率会变得极低。</p><h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><h4 id="为什么有这个协议？"><a href="#为什么有这个协议？" class="headerlink" title="为什么有这个协议？"></a>为什么有这个协议？</h4><p>我们可以发现就是前面的停止等待协议效率太慢了，傻傻的。一个发送出去了，没收到回复就是什么都不做，干等，所以我们可以改善这个情况。这里就要引入一个概念：流水线传输。不断地一个个发送，不用去等待回复后才可以继续发送。</p><h4 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h4><ol><li>在上文的停止等待协议的基础上，不进行等待，不断地进行发送，用一个滑动窗口来记录。当收到对方的ACK的时候就把窗口往前移动一点。例如有123456789 共九个包，现在发送了1234，这个时候窗口就是1234，这个时候收到了数据包1 的ACK，那么窗口就变成234，以此类推。</li><li>接收方主要是采用累积确认的方式，只发送按序的最后一个确认。例如现在发了12345共五个包过去，然后第4个炸了，那么接受方只返回到第三的ACK，而45就会进行超时重传。好处是不用一直发送确认ACK，缺点是没办法实时监控每个包的发送情况。</li><li>如果发生错误，上文讲到会回退到45重传，这就是G-back-N。接收方只返回按序正确的最后一个ACK，剩下的就等待超时重传。缺点是当网络不好的时候就是一个灾难，会一直回退，导致效率极低。</li></ol><h3 id="TCP可靠传输小结"><a href="#TCP可靠传输小结" class="headerlink" title="TCP可靠传输小结"></a>TCP可靠传输小结</h3><p>现在我们来小结一下如何实现可靠传输。</p><ol><li>TCP协议通过把用户要传输的数据当成流输入在缓存区后，按照窗口以及网络情况等适当切割并标上序号，分别发送。</li><li>接收端也有一个缓存区，把接收到的包都放在缓存区中，进行校对。</li><li>发送采用连续ARQ协议，不断发送，接受方只返回到损坏包前的序号的ACK，发送端要重传该序号后的所有包。</li><li>发送端和接收端都有类似的窗口来记录传输结果，保证所有包都完整送达。按照序号来保证传输的可靠传输而不是字节。所以TCP都是基于序号而不是字节。</li><li>因为网络情况的复杂性，所以超时重传的时间要估算比较合理。</li></ol><p>TCP靠着连接，然后把数据分包不断重传直到全部完整发送完毕，实现了在不可靠的网络环境中，进行可靠的数据传输。</p><h2 id="TCP-报文段的首部格式"><a href="#TCP-报文段的首部格式" class="headerlink" title="TCP 报文段的首部格式"></a>TCP 报文段的首部格式</h2><h3 id="头部各字段的含义"><a href="#头部各字段的含义" class="headerlink" title="头部各字段的含义"></a>头部各字段的含义</h3><p>这一小节的内容比较枯燥，而且涉及的概念比较多。有了解过http报文的可能知道头部有很多的参数，每个参数都有独特的意义，所以还是要过一遍。然后难懂一点的字段的解释我会分开讲一下。</p><p>先上一个图：</p><p><img src="https://img-blog.csdnimg.cn/2020060219590141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc2Njc1Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><table><thead><tr><th>头部参数</th><th>字节数</th><th>作用</th></tr></thead><tbody><tr><td>源端口和目的端口字段</td><td>各占两字节</td><td>端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。</td></tr><tr><td>序号字段</td><td>4 字节</td><td>TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。</td></tr><tr><td>确认号字段</td><td>4字节</td><td>是期望收到对方的下一个报文段的数据的第一个字节的序号。</td></tr><tr><td>数据偏移（即首部长度）</td><td>4位</td><td>指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）</td></tr><tr><td>保留字段</td><td>6位</td><td>保留为今后使用，但目前应置为 0</td></tr><tr><td>紧急 URG</td><td>1位</td><td>当 URG =1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)</td></tr><tr><td>确认 ACK</td><td>1位</td><td>只有当 ACK=1 时确认号字段才有效。当 ACK = 0 时，确认号无效</td></tr><tr><td>推送 PSH (PuSH</td><td>1位</td><td>接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。</td></tr><tr><td>复位 RST (ReSeT)</td><td>1位</td><td>当 RST =1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。</td></tr><tr><td>同步 SYN</td><td>1位</td><td>同步 SYN = 1 表示这是一个连接请求或连接接受报文。</td></tr><tr><td>终止 FIN (FINish)</td><td>1位</td><td>用来释放一个连接。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接</td></tr><tr><td>窗口字段</td><td>2字节</td><td>用来让对方设置发送窗口的依据，单位为字节。</td></tr><tr><td>检验和</td><td>2字节</td><td>检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</td></tr><tr><td>紧急指针字段</td><td>2字节</td><td>指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）</td></tr><tr><td>选项字段</td><td>长度不定</td><td>TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。”（这里他的概念是不正确的，MSS说是最大报文段长度，但实际上指的是数据段而不是整个报文段）</td></tr><tr><td>填充字段</td><td>不定</td><td>这是为了使整个首部长度是 4 字节的整数倍。</td></tr></tbody></table><p>选项字段中包含以下其他选项：</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>窗口扩大选项</td><td>占 3 字节，其中有一个字节表示移位值 S。新的窗口值等于 TCP 首部中的窗口位数增大到 (16 + S)，相当于把窗口值向左移动 S 位后获得实际的窗口大小</td></tr><tr><td>时间戳选项</td><td>占 10 字节，其中最主要的字段时间戳值字段（4 字节）和时间戳回送回答字段（4 字节）</td></tr><tr><td>选择确认选项</td><td>接收方收到了和前面的字节流不连续的两个字节块。</td></tr><tr><td>如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据</td><td></td></tr></tbody></table><h3 id="重点难懂字段的解析"><a href="#重点难懂字段的解析" class="headerlink" title="重点难懂字段的解析"></a>重点难懂字段的解析</h3><h4 id="序号，确认号，窗口值"><a href="#序号，确认号，窗口值" class="headerlink" title="序号，确认号，窗口值"></a>序号，确认号，窗口值</h4><p>这几个是关系比较大的。首先我们知道tcp报是有序号的，第一个序号是指发送端发送的报文是从哪个开始，确认号是接受端返回给发送端告诉他下一个应该从哪开始。例如发送了1234，那么序号就是1，确认号就是5。窗口值指的是接收端缓冲区的大小。告诉对方我这里剩下多少缓冲内存了，你不要发太多我缓冲不下来。<strong>这里序号的单位是字节。每一个字节遍一个序号</strong></p><h4 id="选项字段"><a href="#选项字段" class="headerlink" title="选项字段"></a>选项字段</h4><p>选项字段的长度是不定的，看要发送什么数据。根据需要改变长度。</p><h2 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h2><p>上面我们已经讲到他的原理，这里更加详细地陈述如何实现可靠传输。</p><h3 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h3><p>经过上面原理的讲述已经可以大概了解这个窗口的实现。可以先跳到前面看一下。这里说一些重点。</p><h4 id="缓存区"><a href="#缓存区" class="headerlink" title="缓存区"></a>缓存区</h4><ul><li><p>发送缓存用来暂时存放：<br>发送应用程序传送给发送方 TCP 准备发送的数据；<br>TCP 已发送出但尚未收到确认的数据。</p></li><li><p>接收缓存用来暂时存放：<br>按序到达的、但尚未被接收应用程序读取的数据；<br>不按序到达的数据。</p></li></ul><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><h5 id="发送端的构造窗口"><a href="#发送端的构造窗口" class="headerlink" title="发送端的构造窗口"></a>发送端的构造窗口</h5><ul><li><p>根据 B 给出的窗口值，A 构造出自己的发送窗口。</p></li><li><p>发送窗口表示：在没有收到 B 的确认的情况下，A 可以连续把窗口内的数据都发送出去。 </p></li><li><p>发送窗口里面的序号表示允许发送的序号。</p></li><li><p>显然，窗口越大，发送方就可以在收到对方确认之前连续发送更多的数据，因而可能获得更高的传输效率。</p></li></ul><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>发送端</p><ul><li><p>应用程序把需要发送的数据放到tcp发送缓存区中</p></li><li><p>发送端会根据接收端的窗口大小不断发送包</p></li><li><p>已经确认收到的，窗口后沿会往前走，没有收到确认就会一直等待，超时重传，直到收到确认。</p></li><li><p>后沿往前走，窗口前沿也会往前走直到全部发送完成</p></li></ul><p>接收端</p><ul><li>接收端接收到数据就会放到缓存区中</li><li>序号连续的表示数据完好，然后窗口后沿往前走，等待数据被应用程序读取。</li><li>遇到丢失的数据包，会发送确认让发送端重新发送。</li><li>窗口中包含未发送确认但是已经收到的包（也包含尚未接受到的包）</li></ul><p>下面看个图片方便理解</p><p><img src="https://img-blog.csdnimg.cn/20200602220922374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc2Njc1Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h4><ul><li>第一，A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）。</li><li>第二，TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。</li><li>第三，TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。</li><li>接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。<br>但请注意两点：<ul><li>第一，接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，这反而浪费了网络的资源。。 </li><li>第二，捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。</li></ul></li></ul><h3 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h3><h4 id="为什么很重要"><a href="#为什么很重要" class="headerlink" title="为什么很重要"></a>为什么很重要</h4><p>这个点是前面我们没有讲的但是非常重要的点。因为这个时间要把握好。如果把握不好会有什么问题：</p><ul><li>时间太长：空闲时间太长，效率差</li><li>时间太短：频繁重发，浪费资源。</li></ul><h4 id="受什么因素影响"><a href="#受什么因素影响" class="headerlink" title="受什么因素影响"></a>受什么因素影响</h4><p>网络的情况是十分复杂的，所以导致网络传输的情况变得十分复杂，所以这个时间也很难去确定，所以必须采用合适的算法来确定这个时间。</p><h4 id="算法：加权平均往返时间"><a href="#算法：加权平均往返时间" class="headerlink" title="算法：加权平均往返时间"></a>算法：加权平均往返时间</h4><p><code>加权平均往返时间RTTs = （1-a）*旧的往返时间+a*新的往返时间</code></p><p>这里一开始RTT采用第一次测得的往返时间，并以此为基础进行计算。这里的a是一个系数，RFC规定是 0.125.</p><p>这样就可以不断地更新往返时间，得到网络的情况，可以更好地确定超时重传时间。</p><h4 id="超时重传时间RTO算法"><a href="#超时重传时间RTO算法" class="headerlink" title="超时重传时间RTO算法"></a>超时重传时间RTO算法</h4><p><code>RTO = RTTs+4*RTTd</code></p><p><code>RTTd = (1-b)*旧的RTTd+b*|RTTs-新的样本RTT|</code></p><ul><li>RTTd是RTT 的偏差的加权平均值，一般来说第一次取RTT的一半</li><li>b的推荐值是0.25</li><li>这个算法是根据网络波动来确定重传的时间的，如果网络稳定，则重传时间就接近往返时间，网络波动越大，则超时重传的时间约大</li></ul><h4 id="Karn算法"><a href="#Karn算法" class="headerlink" title="Karn算法"></a>Karn算法</h4><p>这里还有一个问题就是：如果重传了，然后接收到一个ack，那么这个ack是重传前的那个包的，还是重传后这个包的？很难确定对吧。所以这里就诞生了这个算法。</p><p>最初这个算法是直接丢弃重传包样本，但是这样肯定不行的，会让算法不准确。所以修正后是<code>RTO = y*旧的RTO</code>。这里的y一般是2.这样当发生重传的时候，就会把该样本的信息记录下来了。</p><h3 id="选择确认SACK"><a href="#选择确认SACK" class="headerlink" title="选择确认SACK"></a>选择确认SACK</h3><p>前面我们讲到累积确认的时候讲到：当收到错误或者漏包的时候，只会发送这个错误的包前的确认完好的ack，剩下的都要重传。例如收到12678。那么会发送确认号为3的ack，这样的话，678也要重传一次，就浪费资源了。所以我们可以告诉发送端说我已经收到了什么，只需要把缺的发送给我就行。这个时候就可以用到选择确认SACK。</p><p>上文讲头部字段的时候讲到这个选项，他的<strong>最大值是40字节</strong>。每一个确认的字段，例如上面的12678例子。12段需要一个左边界1和右边界2,678需要左边界6，右边界8.所以每个要告诉发送端的已经完好的字段都需要两个边界：<strong>左边界和右边界</strong>。一个边界需要4个字节，所以<strong>最多只能告诉接收端4个完好的字段</strong>。</p><h3 id="TCP可靠传输小结-1"><a href="#TCP可靠传输小结-1" class="headerlink" title="TCP可靠传输小结"></a>TCP可靠传输小结</h3><p>TCP通过滑动窗口以及超时重传算法来使得发送的数据变得非常可靠，效率也比较高。另外再通过选择确认SACK进一步加强了性能。这三个是需要掌握的点，特别是超时重传时间的算法和滑动窗口的原理。</p><h2 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h2><h3 id="什么是流量控制？为什么要进行流量控制？"><a href="#什么是流量控制？为什么要进行流量控制？" class="headerlink" title="什么是流量控制？为什么要进行流量控制？"></a>什么是流量控制？为什么要进行流量控制？</h3><p>流量控制这个很好理解，就是控制管道中传输的数据量。控制流量是为了不让管道发生拥塞，从而来提高效率。另一方面，如果发送端的速度太快，接收端可能会来不及接受就会导致数据的丢失。</p><h3 id="利用滑动窗口来提高效率"><a href="#利用滑动窗口来提高效率" class="headerlink" title="利用滑动窗口来提高效率"></a>利用滑动窗口来提高效率</h3><p>前面我们讲到tcp头部有一个窗口值，可以用来记录接收方还有多少的缓存。tcp主要就是利用这一点来保证有足够的缓存，而不会无法接收。当接收方的的缓存满了之后，ack’中的窗口值就是0。当接收方中的缓存多了之后，就会发送一个数据报告知发送端我有内存了，可以发送数据过来了。</p><p>这里有一个问题：如果接收端告知可以发送数据的tcp报丢失了怎么办？持续计时器。</p><p>当发送端收到窗口值为0的tcp报的时候，就会开始计时器，计时器时间到了就会发送一个试探报，数据只有一个字节。如果还是缓存满，就重新开始计算计时器。</p><h3 id="提高传输效率"><a href="#提高传输效率" class="headerlink" title="提高传输效率"></a>提高传输效率</h3><h4 id="相关机制"><a href="#相关机制" class="headerlink" title="相关机制"></a>相关机制</h4><ul><li>发送的数据长度不能太短也不能太长，参考MSS。</li><li>按照接收端的要求发送push报文</li><li>持续计时器到了，就要发送数据报，不能干等待</li></ul><h4 id="糊涂窗口综合症和Nagle算法"><a href="#糊涂窗口综合症和Nagle算法" class="headerlink" title="糊涂窗口综合症和Nagle算法"></a>糊涂窗口综合症和Nagle算法</h4><p>听起来好高大上，其实很简单。当缓存区还没有数据的时候，这个时候收到一个字节是不是就会马上发出去了？这样就不符合上面说的效率限制了。然后接收端，如果是满的，然后应用程序读取了一个字节，是不是马上就通知发送端可以发送一个字节的数据了。这样都是会让网络效率降低。所以正确的方法就是：等。等到一定长度后，再进行发送。这也就是Nagle算法。</p><h2 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h2><h4 id="拥塞原理"><a href="#拥塞原理" class="headerlink" title="拥塞原理"></a>拥塞原理</h4><h5 id="什么是拥塞？"><a href="#什么是拥塞？" class="headerlink" title="什么是拥塞？"></a>什么是拥塞？</h5><p>什么是拥塞？为什么会发生拥塞？拥塞顾名思义就是像塞车那样发生了堵塞。通道的能力是一定的，当网球传输的压力逐渐增大的时候，那么就会发生了堵塞，甚至路由器的缓冲队列满了，直接把数据报丢掉。所以这里会有一个问题：数据传输慢了好多，甚至被丢包。然后会发生什么？超时重传。然后数据报一直发送不过去，这边一直重传，就形成了恶循环。导致整个网络瘫痪。所以一定要控制好流量。</p><p>这里的流量控制和上文讲滑动窗口的时候那个流量控制有什么区别？上文讲的流量控制是为了避免数据太快以致于接收端无法及时接受数据。这里是为了避免发生拥塞而导致网络瘫痪。但是都是同样的手段：流量控制。</p><h5 id="导致拥塞的原因有什么？可以直接提高带宽解决吗？"><a href="#导致拥塞的原因有什么？可以直接提高带宽解决吗？" class="headerlink" title="导致拥塞的原因有什么？可以直接提高带宽解决吗？"></a>导致拥塞的原因有什么？可以直接提高带宽解决吗？</h5><p>拥塞控制不只是用到流量控制，导致拥塞的原因有：带宽，路由缓存，处理机处理速度等等非常多的因素。提高某个因素的能力会把瓶颈转移到其他的地方，所以能做的最重要一个就是控制流量。</p><h5 id="拥塞的指标是什么？怎么判断发生了拥塞？"><a href="#拥塞的指标是什么？怎么判断发生了拥塞？" class="headerlink" title="拥塞的指标是什么？怎么判断发生了拥塞？"></a>拥塞的指标是什么？怎么判断发生了拥塞？</h5><p>由于缺少缓存空间而被丢弃的分组的百分数；<br>平均队列长度；<br>超时重传的分组数；<br>平均分组时延；<br>分组时延的标准差，等等</p><ul><li>开环控制：在网络执行前进行预估尽量避免</li><li>闭环控制：实时监控控制</li></ul><p>减少拥塞有两种方案：一种是硬件的能力，这个只能尽量，但是提升空间小，瓶颈大，第二种就是通过算法来减少，也就是tcp要做的。</p><h4 id="tcp的拥塞控制方法"><a href="#tcp的拥塞控制方法" class="headerlink" title="tcp的拥塞控制方法"></a>tcp的拥塞控制方法</h4><p>首先来看一张图，这张图就讲了整个tcp控制拥塞的算法：</p><p><img src="https://img2020.cnblogs.com/blog/1961534/202006/1961534-20200604230417771-1636180342.png" alt=""></p><p>一共有4个点：慢开始，拥塞避免，快重传，快恢复。</p><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><p>tcp控制拥塞的算法核心就是动态窗口。上面我们讲到，发送端可以发送的最多数据报是根据接收端的缓冲区以及自身的缓冲区大小决定，但是我们不能任他无限大发送。如果每个链接都发送50g的数据岂不是得炸掉。所以这里增加了一个拥塞窗口，控制可以发送的数据数量，控制流量。</p><p>因为动态窗口需要根据情况实时调整，所以，必须得到及时的反馈，所以接收端收到数据报的时候，需要迅速把确认发送给发送端。</p><h5 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h5><p>这个算法要求当接收端发现缺少包的时候要及时反映给发送端。例如发送了1，2但是3丢了，此时继续发送4，5，6，那么接收端就要返回三个重复确认，3还没来就发4,5,6肯定是你的3丢了，赶紧重发。然后接受端收到三个重复的，就赶紧补发3过去。</p><h5 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h5><p>这里的慢开始就是一开始的窗口值要小，不能太大，然后去试探拥塞的底线。这里一般的起点是一般是发送端一个数据报可以发送的最大长度的1~2倍。然后每一个轮次，也就一个往返，就把窗口值加倍。这里的往返要注意一下，是要整个窗口中的数据全部往返一次，才算是一个轮次。例如窗口的大小是8，那么需要8的数据报都收到ack才算是一个轮次结束。</p><h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h5><p>这里有一个界限，如果一直增大下去那岂不是就指数爆炸了。所以到了一个界限：ssthresh，这个值是自己设定的。之后就是以线性慢慢增长。然后就会出现两种情况：</p><ol><li>发生超时重传</li><li>得到三个重复的ack</li></ol><p>首先看第一种情况，如果发生了超时重传，则说明很可能是发生了拥塞，那么这个时候就要迅速慢开始，把ssthresh设置当前窗口大小的1/2，然后把窗口压缩到最初的状态。重头开始。第二种情况就是快恢复了。</p><h5 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h5><p>当收到三个重复的ack的时候，只是有可能但是可能性比较小出现了拥塞，所以就把ssthresh设置为当前窗口的1/2，同时把当前窗口值设置为何ssthresh一样大。不用慢开始直接拥塞避免阶段。</p><h5 id="窗口值上限"><a href="#窗口值上限" class="headerlink" title="窗口值上限"></a>窗口值上限</h5><p>这个上限就是前面讲到的根据两端缓存区的大小来确定了。</p><h4 id="主动队列管理AQM"><a href="#主动队列管理AQM" class="headerlink" title="主动队列管理AQM"></a>主动队列管理AQM</h4><p>如果发生拥塞，那么会瞬间让整个网络的效率降低到很小的一个值，所以要尽量避免，多一点快恢复。</p><p>我们知道路由器的缓冲队列长度是有限的，当满了之后接下来的分组都会被丢弃那么，我们可以在快满的时候就通知慢点发送，快拥塞了。管理好这个队列，而不能等到发生事故了在进行处理。这就是主动队列管理。</p><h2 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h2><p>tcp是面向连接的，所以就涉及到连接的建立释放。那么连接就有状态，就涉及到有限状态机。也就是以下三个：</p><h4 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h4><img src="https://img2020.cnblogs.com/blog/1961534/202006/1961534-20200605000952368-1256869162.png" width="400"><p>这个有个很重要的概念：三次握手。</p><p>他们建立的过程类似这样：</p><ul><li>client：我要和你连接</li><li>service：好的，你真的要连接吗</li><li>client：对，我真的要</li></ul><p>然后就连接了。这个过程需要发送三个报文，也称为三报文握手。然后互相交换各自的信息例如窗口值 RTT等。相亲的互问根底不过是为了婚姻更幸福的生活不是吗（此处手动滑稽）</p><h4 id="连接释放"><a href="#连接释放" class="headerlink" title="连接释放"></a>连接释放</h4><img src="https://img2020.cnblogs.com/blog/1961534/202006/1961534-20200605000948327-1061875421.png" width="400"><p>释放的话会比较麻烦一点，毕竟闪婚容易，离婚就可能和庆兄或者祥哥一样可爱了。（哦祥哥貌似当时还没结婚）释放连接要进行4次握手：</p><ul><li>client：我不要你了我要释放连接</li><li>service：你真的不要我了吗，哼，不要就滚</li><li>service：我决定了。释放连接</li><li>client：好，拜拜。</li><li>client：等待2msl时间后完全释放连接</li></ul><p>最后一个是一个等待时间，避免受到无效的请求。因为进行了四次握手也成为四报文握手。（也有叫挥手的，挥手比较好点）这样就直接释放连接了。这里有几个点要注意：</p><ol><li>客户端请求释放，受到服务端的确认后并没有完全释放连接，而是会等待服务端的下一个回复才真正断开。但是，还不是完全断开，要再等两个最大报文生存时间，网络中完全不存在无效报文了再彻底断开。</li><li>另外等待时间也是为了最后一个报文能到达服务端，万一服务端反悔了就可以收到对吧，如果没有等待2msl，就可能下一个tcp连接收到了无效的请求。</li></ol><h4 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h4><p>通过上面的讲述可以发现tcp连接存在很多的状态。所以也就有了这个状态机。给个图你们感受一下：</p><img src="https://img2020.cnblogs.com/blog/1961534/202006/1961534-20200605000955584-1738895006.png" width="500"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章从什么是运输层，运输层的协议，到重点介绍tcp的工作原理，如何可靠传输，tcp报的格式，到更加深入的拥塞原理，流量控制提高传输效率，最后讲了tcp的连接管理。</p><p>tcp是运输层一个非常重要的协议，除了少部分使用udp，其他基本都是使用tcp，所以要对tcp的原理模清楚。另外要懂得tcp的效率问题以及出错的拥塞问题连接问题。</p><p>运输层是直接和我们应用层打交道的，所以了解清楚运输层是有必要的。当我们需要建立一些socket连接的时候，就必须对运输层有一定的了解。</p><p>好了关于运输层就大概讲这么多，希望可以给你们有一些帮助。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 运输层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：新21点</title>
      <link href="/2020/06/03/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%96%B021%E7%82%B9/"/>
      <url>/2020/06/03/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%96%B021%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="题目：新21点"><a href="#题目：新21点" class="headerlink" title="题目：新21点"></a>题目：新21点</h3><p>爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：</p><p>爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。</p><p>当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：N &#x3D; 10, K &#x3D; 1, W &#x3D; 10</span><br><span class="line">输出：1.00000</span><br><span class="line">说明：爱丽丝得到一张卡，然后停止。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：N &#x3D; 6, K &#x3D; 1, W &#x3D; 10</span><br><span class="line">输出：0.60000</span><br><span class="line">说明：爱丽丝得到一张卡，然后停止。</span><br><span class="line">在 W &#x3D; 10 的 6 种可能下，她的得分不超过 N &#x3D; 6 分。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：N &#x3D; 21, K &#x3D; 17, W &#x3D; 10</span><br><span class="line">输出：0.73278</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;&#x3D; K &lt;&#x3D; N &lt;&#x3D; 10000</span><br><span class="line">1 &lt;&#x3D; W &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure><p>如果答案与正确答案的误差不超过 10^-5，则该答案将被视为正确答案通过。<br>此问题的判断限制时间已经减少。</p><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/new-21-game" target="_blank" rel="noopener">https://leetcode-cn.com/problems/new-21-game</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>详细题解可前往上述力扣官网查看。此处我讲解我做题的思路和一些个人总结等</p></blockquote><p>首先要做的就是理解题意，知道难点在哪。我当时做这道题，就是因为不理解题意。我们可以使用暴力推算来一步步看具体计算逻辑，再进行化简。<strong>暴力算法不是没用，他是一切优化算法的基石</strong>。</p><p>拿一个例子：k=5，n=7，w=,4。</p><ol><li>首先要理解这个游戏是怎么玩的，我们可以一直抽牌，牌的大小在[1,w]，如果手上的点数不超过k，那么必须继续抽，如果超过了，就停下来。然后看看手上的点数此时是否超过了n。（默认每次抽到任何点数的概率相同）</li><li>算概率，我们先算样本空间。最大值是k-1+w。因为k的话已经满足了，那么当手上的点数是k-1且抽到最大点数的牌w，那么就是<code>k-1+w</code>。最小值毋庸置疑就是<code>k</code>了。</li><li>这样基本上我们就了解整个题意了。然后看看怎么暴力解决它。大于k的时候已经没办法抽了，所以我们考虑小于k的情况。当手上的点数是k-1时，那么可能的结果就是[k,k-1+w]，且每个结果概率相等。然后求小于n的概率，那是不是很容易就可以求出来了。古典概率模型嘛。例如上面的例子，当手上的点数是4的时候，那么小于等于8就只有5,6,7；剩下的8，就不行了，所以概率是0.75.来我们继续。也就是从4出发的话，概率是0.75.那我们看看从3出发，概率是多少。</li><li>从3出发可能的范围是[4,8]，然后4的概率我们已经知道了是0.75，然后5,6,7,8都是小于n的，那么3出发的概率就是0.75<em>0.25+0.75。是不是已经发现什么了？只要这样一直往前推，推导第一位那答案不是就出来了？而且每一个答案都和前面的答案有关？是不是闻到了一股熟悉的味道？对就是*</em>动态规划**</li><li>按照上面的思路我们只需要一步步往前推。接下来是我们要确定状态转移方程。从上面我们可以发现 P(3) = 1/4 * P(4) + 3/4 * [P(4)-P(3+4)] 。然后把里面一些数字用循环的i变量和参数代替就可以了。</li></ol><p>个人思考：一定要先理解题意然后用暴力解法思考一下，不要一开始就想着套用什么模板。暴力解法之后才知道题目的本质是什么，然后用什么方法可以简化。然后再运用动态规划，滑动窗口等等方法去解决。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">new21Game</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (K == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span>[] dp = <span class="keyword">new</span> <span class="keyword">double</span>[K + W];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = K; i &lt;= N &amp;&amp; i &lt; K + W; i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[K - <span class="number">1</span>] = <span class="number">1.0</span> * Math.min(N - K + <span class="number">1</span>, W) / W;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = K - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp[i] = dp[i + <span class="number">1</span>] - (dp[i + W + <span class="number">1</span>] - dp[i + <span class="number">1</span>]) / W;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ol><li>时间复杂度：只需要遍历数组。长度是k+w，当时当n小于k+w的时候只需要遍历到n就行，剩下都是0.</li></ol><blockquote><p>时间复杂度：O(min（n，k+w)）</p></blockquote><ol start="2"><li>空间复杂度：只需要一个数组</li></ol><blockquote><p>空间复杂度：O(k+w)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：求1+2+..+n</title>
      <link href="/2020/06/02/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%B1%821+2+..+n/"/>
      <url>/2020/06/02/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%B1%821+2+..+n/</url>
      
        <content type="html"><![CDATA[<h3 id="题目：求1-2-n"><a href="#题目：求1-2-n" class="headerlink" title="题目：求1+2+..+n"></a>题目：求1+2+..+n</h3><p>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: n &#x3D; 3</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">限制：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/qiu-12n-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/qiu-12n-lcof</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这道题如果你有什么大胆的想法，直接做就是了（手动滑稽）。</p><p>先来分析一下，首先拿到这道题，第一反应就是我们熟悉的数学公式 <code>(n+1)n/2</code>。但是这里需要用到乘法和除法，不满足题干。那么接下来分析一下我们还有什么运算符可以用：</p><p>加减法，赋值，位运算，逻辑运算。</p><p>看到位运算是不是眼前一亮。运算可以取代加减乘除，本质上加减乘除也是用位运算来实现的。所以，怎么用位运算实现乘法和除法？</p><p>除法是二的指数就很简单了，直接移位就行了。非二的倍数就比较复杂，这里先不讨论。</p><p>乘法的话，看乘数化为二进制的每一位是不是1.如果是1则被乘数向左移动该位的位置数（第一位默认是0）。例如：2*3: = 010 * 011：</p><ol><li>3的第一位是1，那么结果加上010向左移动0位，即010</li><li>3的第二位是1，那么结果加上010向左移动1位，即010+100=110</li><li>3的第三位是0，结果保持不变，最终是110 即6.</li></ol><p>这样就可以得到答案了。</p><p>但是我们给出的n的大小不确定，又不能用循环判断，那怎么去不断累加呢？</p><p>注意限制条件：1&lt;=n&lt;=10000 。n不会超过·10000，也就是n的二进制位数不会超过14，所以弄14层代替循环即可。没错就是这么暴力。</p><blockquote><p>这道不同编程语言的逻辑运算可参与的数据类型不同。c/c++中可以用整数来进行逻辑运算，但是java等面向对象的语言是不可以的。要注意这点。</p></blockquote><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, A = n, B = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ol><li>时间复杂度：只需要遍历n的二进制位数</li></ol><blockquote><p>时间复杂度：O(logn)</p></blockquote><ol start="2"><li>空间复杂度：只需要额外的常量空间</li></ol><blockquote><p>空间复杂度：O(1)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：拥有最多糖果的孩子</title>
      <link href="/2020/06/01/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90/"/>
      <url>/2020/06/01/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h3 id="题目：拥有最多糖果的孩子"><a href="#题目：拥有最多糖果的孩子" class="headerlink" title="题目：拥有最多糖果的孩子"></a>题目：拥有最多糖果的孩子</h3><p>给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。</p><p>对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 ：</span><br><span class="line"></span><br><span class="line">输入：candies &#x3D; [2,3,5,1,3], extraCandies &#x3D; 3</span><br><span class="line">输出：[true,true,true,false,true] </span><br><span class="line">解释：</span><br><span class="line">孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。</span><br><span class="line">孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。</span><br><span class="line">孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。</span><br><span class="line">孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。</span><br><span class="line">孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。</span><br></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>六一儿童节快乐呀。今天做的算法题也轻松一下。思路很简单，找到糖果最多的那个小朋友，然后再依次把多余的糖果分配给每一个小朋友，看他们的手上的糖果是否大于等于最大的那个。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Boolean&gt; <span class="title">kidsWithCandies</span><span class="params">(<span class="keyword">int</span>[] candies, <span class="keyword">int</span> extraCandies)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = candies.length;</span><br><span class="line">       <span class="keyword">int</span> maxCandies = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">           maxCandies = Math.max(maxCandies, candies[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;Boolean&gt; ret = <span class="keyword">new</span> ArrayList&lt;Boolean&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">           ret.add(candies[i] + extraCandies &gt;= maxCandies);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>假设一共有n个孩子</p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><ol><li>时间复杂度：遍历两次数组</li></ol><blockquote><p>时间复杂度：O(n)</p></blockquote><ol start="2"><li>空间复杂度：只需要额外的常量空间</li></ol><blockquote><p>空间复杂度：O(1)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：判断对称二叉树</title>
      <link href="/2020/05/31/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%A4%E6%96%AD%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/05/31/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%A4%E6%96%AD%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="题目：判断对称二叉树"><a href="#题目：判断对称二叉树" class="headerlink" title="题目：判断对称二叉树"></a>题目：判断对称二叉树</h3><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [2,1,5,6,2,3]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/symmetric-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/symmetric-tree</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>说实话这道题我想了挺久的，可能太久没接触过二叉树了。</p><p>比较容易得到的思路是是递归。根节点下的左右两棵树在一个方法内分别 进行先序递归遍历，但是不同的是，一个是从左边开始的先序遍历，一个是从右边开始的先序遍历。然后依次判断元素是否相同即可。</p><p>另外也可以使用迭代的方式，因为是先序遍历，先遍历到先判断，所以这里可以使用一个特点相同的队列数据结构来辅助迭代。每次取出来两个元素，然后按照一左一右把元素放进去即可。（参考代码即可理解）</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">     TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> getBoolean(root.left,root.right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(TreeNode nodeL, TreeNode nodeR)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nodeL == <span class="keyword">null</span> &amp;&amp; nodeR == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (nodeL == <span class="keyword">null</span> || nodeR == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (nodeL.val != nodeR.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> getBoolean(nodeL.left,nodeR.right) &amp;&amp; getBoolean(nodeL.right,nodeR.left);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> check(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode u, TreeNode v)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        q.offer(u);</span><br><span class="line">        q.offer(v);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            u = q.poll();</span><br><span class="line">            v = q.poll();</span><br><span class="line">            <span class="keyword">if</span> (u == <span class="keyword">null</span> &amp;&amp; v == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((u == <span class="keyword">null</span> || v == <span class="keyword">null</span>) || (u.val != v.val)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            q.offer(u.left);</span><br><span class="line">            q.offer(v.right);</span><br><span class="line"></span><br><span class="line">            q.offer(u.right);</span><br><span class="line">            q.offer(v.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>假设二叉树的元素个数为n</p><h4 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h4><ol><li>时间复杂度：每个元素都需要遍历一次</li></ol><blockquote><p>时间复杂度：O(n)</p></blockquote><ol start="2"><li>空间复杂度：栈的个数不会超过元素个数</li></ol><blockquote><p>空间复杂度：O(n)</p></blockquote><h4 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h4><ol><li>时间复杂度：每个元素都需要遍历一次</li></ol><blockquote><p>时间复杂度：O(n)</p></blockquote><ol start="2"><li>空间复杂度：队列的长度不会超过n</li></ol><blockquote><p>空间复杂度：O(n)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：柱状图中最大的矩形</title>
      <link href="/2020/05/29/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
      <url>/2020/05/29/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目：柱状图中最大的矩形"><a href="#题目：柱状图中最大的矩形" class="headerlink" title="题目：柱状图中最大的矩形"></a>题目：柱状图中最大的矩形</h3><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="https://img2020.cnblogs.com/blog/1961534/202005/1961534-20200530184957296-77413922.png" alt=""></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p><p><img src="https://img2020.cnblogs.com/blog/1961534/202005/1961534-20200530184958716-2094348161.png" alt=""></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [2,1,5,6,2,3]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram" target="_blank" rel="noopener">https://leetcode-cn.com/problems/largest-rectangle-in-histogram</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>拿到这道题，先不要想其他的方法，看看暴力解法能不能算出来。我们会发现暴力算法有两个方案：一个是变化矩形的范围，然后求出范围中的最低柱子，就可以得到面积了。第二个是每个柱子分别向前后扩散，遇到比自己低的就停下来，那么这个范围的宽度乘上自身的高度，就是该位置的柱子可以达到的最大面积。（第二种我当时没想出来==）</p><p>然后我们从暴力算法中，看看有没有可以进行优化的地方。首先两种思路，第一种的话因为已经固定了两层嵌套循环，要去优化的话显然有点困难。第二种的思路只有一个外层循环，所以优化的空间可能会比较大，我们从第二种入手。</p><p>首先我们知道，第二种思路最费时间的点就是每次都要前后去寻找，那我们这里可以去想一下怎么把前面遍历的情况记录下来，节省时间。所以难点就是在确定边界。</p><p>重要特点：这里我们分析边界的特点。如果i &lt; j ,且heights[i] &gt; heights[j] ,这样的话，对于任何 j &lt; k,第K个元素的左边界不可能是i。因为被 j 挡住了。这个应该很好理解吧。可以的话我们继续。</p><p>首先我们进行遍历数组，看什么时候可以确定边界。假设现在有[2,4,1,5,7,3]。（大家可以自行画图体验，我这里就不画图了，懒癌犯了）</p><ol><li>遍历到2的时候，已经确定好左边界，但是还没有确定右边界；</li><li>遍历4，同二。</li><li>遍历1，这个时候我们会发现，第二个元素4，已经确定好边界了，可以得出面积4.</li><li>然后可以发现第一个元素2，也得到他的边界了。</li><li>然后我们会发现，位置1 比前面的任何元素都要小，那么后面的元素，不可能以2,4为左边界。原因看上面。</li><li>然后同理继续遍历5，和7.然后遍历到3的时候，元素 7 也确定边界了。元素5也确定边界了。</li><li>后面已经没有元素了，所以3也可以确定边界。最后再确定1的边界。</li></ol><p>观察上面的流程，有没有一丝丝什么的味道？栈的味道。遍历可以看做是入栈，确定边界的时候，可以看成出栈。先进后出。那么可不可以用一个辅助栈来完成这个流程呢？答案是肯定的。</p><p>思路和上面一模一样，重点是入栈和出栈。从上面的重要特点可以知道，当遇到比较小的元素的时候，那么前面的元素就可以确定边界了，进行出栈操作。所以栈底，永远是前面的最小元素。</p><ol><li>当遍历到的元素比栈顶要小的时候，那么就可以对栈顶元素进行出栈</li><li>这个矩形的高度是栈顶元素的高度，宽度是当前遍历到的元素的 下标 i - 栈顶元素的下一个元素的下标 j + 1.为什么是这样？大家可以画个图模拟一下，就留给大家思考了。</li><li>遍历完成后，再对栈里的元素进行出栈操作。</li><li>过程中记录最大的矩形面积。</li></ol><p>这里建议大家画图去模拟这个过程，会很好去理解，特别是关于矩形的边界的确定，如果没有画图，很容易就漏掉一些细节的考虑。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (heights.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;heights.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (heights[i]&gt;=heights[stack.peek()]) stack.push(i);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[i]&lt;heights[stack.peek()] )&#123;</span><br><span class="line">                <span class="keyword">int</span> index = stack.pop();</span><br><span class="line">                <span class="keyword">int</span> area;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty())&#123;</span><br><span class="line">                    area = i*heights[index];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    area = (i-stack.peek()-<span class="number">1</span>)*heights[index];</span><br><span class="line">                &#125;</span><br><span class="line">                maxArea = Math.max(maxArea, area);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> index = stack.pop();</span><br><span class="line">        <span class="keyword">int</span> area;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty())&#123;</span><br><span class="line">            area = heights.length*heights[index];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            area = (heights.length-stack.peek()-<span class="number">1</span>)*heights[index];</span><br><span class="line">        &#125;</span><br><span class="line">        maxArea = Math.max(area,maxArea);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>假设数组的长度为n</p><ol><li>时间复杂度：首先需要遍历一次数组，每个元素至多进行一次出栈和入栈操作。</li></ol><blockquote><p>时间复杂度：O(n)</p></blockquote><ol start="2"><li>空间复杂度：这里所需要的空间是栈。最多是数组的长度。</li></ol><blockquote><p>空间复杂度：O(n)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 辅助栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：字符串解码</title>
      <link href="/2020/05/29/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"/>
      <url>/2020/05/29/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h3 id="题目：字符串解码"><a href="#题目：字符串解码" class="headerlink" title="题目：字符串解码"></a>题目：字符串解码</h3><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">s &#x3D; &quot;3[a]2[bc]&quot;, 返回 &quot;aaabcbc&quot;.</span><br><span class="line">s &#x3D; &quot;3[a2[c]]&quot;, 返回 &quot;accaccacc&quot;.</span><br><span class="line">s &#x3D; &quot;2[abc]3[cd]ef&quot;, 返回 &quot;abcabccdcdcdef&quot;.</span><br></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/decode-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/decode-string</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>首先讲一下我拿到这道题的思路：递归。每一歌中括号可以是一层，然后递归返回中括号中的字符串，和外层的数字进行循环重复后继续下一个中括号。例如：<code>2[4[ab]]3[b]</code></p><ol><li>先得到2，然后递归进入第一个中括号</li><li>得到4，递归进入</li><li>得到ab，遇到<code>]</code>返回上一层</li><li>ab进行4次重复，遇到<code>]</code>返回上一层</li><li>把得到的字符串进行2次重复。然后继续下一组。</li></ol><p>思路应该是挺清晰的。但是这里有几个问题：在第五步的时候怎么确定下一组开始的位置？每一步递归，怎么确认开始的位置？我当时就卡在第一个问题，不知道如何解决。</p><p>对于第二个问题，很简单，重新写一个方法来递归，然后加入position参数即可。第一个问题有两个思路：</p><ol><li>全局变量</li><li>在返回参数中加入</li></ol><p>我比较喜欢第二种。因为全局变量就破坏了封装，我觉得不可取。但是返回参数，不是字符串吗，怎么附带位置信息？这里有个很好的解决方案：字符串数组。返回的字符串数组中一个保存得到的字符串，一个是数字字符串，再进行转换就可以得到位置信息了。思路到此应该就差不多了。另外的实现细节可以自己补充。</p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>有递归，那么和递归一样思路的是什么？没错就是栈，那么我们可以使用一个辅助栈解决这个问题。思路和递归是差不多的：</p><ol><li>遍历字符串数组并把字符放进栈。</li><li>当遍历到<code>]</code>时进行回溯，把中距离栈顶第一个<code>[</code>前的字符串拿出来</li><li>然后再遍历数字，遇到栈底或者<code>]</code>停止</li><li>然后进行循环运算后把字符串放进栈中</li><li>最后返回栈中的字符串</li></ol><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">decodeString</span><span class="params">(s: <span class="type">String</span>)</span></span>: String&#123;</span><br><span class="line">    <span class="keyword">return</span> getStrings(s,<span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStrings</span><span class="params">(s:<span class="type">String</span>,i:<span class="type">Int</span>)</span></span>:StringArray&#123;</span><br><span class="line">    <span class="keyword">val</span> stringBuilder = StringBuilder()</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> position = i</span><br><span class="line">    <span class="keyword">while</span> (position&lt;s.length)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s[position] <span class="keyword">in</span> <span class="string">'a'</span>..<span class="string">'z'</span> || s[position] <span class="keyword">in</span> <span class="string">'A'</span>..<span class="string">'Z'</span>)&#123;</span><br><span class="line">            stringBuilder.append(s[position])</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s[position] <span class="keyword">in</span> <span class="string">'0'</span>..<span class="string">'9'</span>)&#123;</span><br><span class="line">            num = num*<span class="number">10</span> + s[position].toInt()-<span class="number">48</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s[position]==<span class="string">'['</span>)&#123;</span><br><span class="line">            <span class="keyword">val</span> stringArray = getStrings(s,position+<span class="number">1</span>)</span><br><span class="line">            position = stringArray[<span class="number">1</span>].toInt()</span><br><span class="line">            <span class="keyword">while</span> (num!=<span class="number">0</span>)&#123;</span><br><span class="line">                stringBuilder.append(stringArray[<span class="number">0</span>])</span><br><span class="line">                num--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s[position]==<span class="string">']'</span>)&#123;</span><br><span class="line">            <span class="keyword">val</span> stringArray = StringArray()</span><br><span class="line">            stringArray.add(stringBuilder.toString())</span><br><span class="line">            stringArray.add(position.toString())</span><br><span class="line">            <span class="keyword">return</span> stringArray</span><br><span class="line">        &#125;</span><br><span class="line">        position++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> stringArray = StringArray()</span><br><span class="line">    stringArray.add(stringBuilder.toString())</span><br><span class="line">    stringArray.add(position.toString())</span><br><span class="line">    <span class="keyword">return</span> stringArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">decodeString</span><span class="params">(s: <span class="type">String</span>)</span></span>: String&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.isEmpty()) <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    <span class="keyword">val</span> stack = Stack&lt;<span class="built_in">Char</span>&gt;()</span><br><span class="line">    <span class="keyword">for</span> (c <span class="keyword">in</span> s)&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">']'</span>)&#123;</span><br><span class="line">            <span class="keyword">val</span> stringBuilder = StringBuilder()</span><br><span class="line">            <span class="keyword">while</span> (stack.peek()!=<span class="string">'['</span>)&#123;</span><br><span class="line">                stringBuilder.append(stack.pop())</span><br><span class="line">            &#125;</span><br><span class="line">            stack.pop()</span><br><span class="line">            <span class="keyword">val</span> string = stringBuilder.reverse().toString()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (stack.isNotEmpty() &amp;&amp; stack.peek()&gt;=<span class="string">'0'</span> &amp;&amp; stack.peek()&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                <span class="keyword">val</span> topNum = stack.pop().toInt()-<span class="number">48</span></span><br><span class="line">                <span class="keyword">val</span> p = <span class="number">10</span>.toDouble().pow(i)</span><br><span class="line">                num += topNum*p.toInt()</span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span>..num)&#123;</span><br><span class="line">                stack.addAll(string.toList())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> stack.add(c)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line">    <span class="keyword">while</span> (stack.isNotEmpty())&#123;</span><br><span class="line">        sb.append(stack.pop())</span><br><span class="line">    &#125;</span><br><span class="line">    sb.reverse()</span><br><span class="line">    <span class="keyword">return</span> sb.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>假如最终的字符串长度为n，原字符串的长度为k</p><h4 id="方法一-2"><a href="#方法一-2" class="headerlink" title="方法一"></a>方法一</h4><ol><li>时间复杂度：遍历原字符串，还需要把新字符一个个拼进来。</li></ol><blockquote><p>时间复杂度：O(n+k)</p></blockquote><ol start="2"><li>空间复杂度：这里所需要的空间是递归栈的深度，最坏情况下为k</li></ol><blockquote><p>空间复杂度：O(k)</p></blockquote><h4 id="方法二-2"><a href="#方法二-2" class="headerlink" title="方法二"></a>方法二</h4><ol><li>时间复杂度：除了遍历一次原字符串，还要把每个字符都放进栈中所以是</li></ol><blockquote><p>时间复杂度：O(n+k)</p></blockquote><ol start="2"><li>空间复杂度：需要一个栈来保存数据，栈的长度为字符串的长度</li></ol><blockquote><p>空间复杂度：O(n)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：和可被k整除的子数组数目</title>
      <link href="/2020/05/27/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%92%8C%E4%B8%BAK%E7%9A%84%E6%A8%A1%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/"/>
      <url>/2020/05/27/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%92%8C%E4%B8%BAK%E7%9A%84%E6%A8%A1%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="题目：和可被k整除的子数组数目"><a href="#题目：和可被k整除的子数组数目" class="headerlink" title="题目：和可被k整除的子数组数目"></a>题目：和可被k整除的子数组数目</h3><p>给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; [4,5,0,-2,-3,1], K &#x3D; 5</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">有 7 个子数组满足其元素之和可被 K &#x3D; 5 整除：</span><br><span class="line">[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; A.length &lt;&#x3D; 30000</span><br><span class="line">-10000 &lt;&#x3D; A[i] &lt;&#x3D; 10000</span><br><span class="line">2 &lt;&#x3D; K &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/subarray-sums-divisible-by-k" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subarray-sums-divisible-by-k</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这道题的思路重点在前缀和+同余定理。</p><p>拿到这道题的时候我一直在想着一个子数组如果符合条件的话，怎样推出他周边的子数组是否符合条件？想了半天还是只有O（N^2）的思路。这里就要用到这个同余定理。</p><p>同余定理：当一个数组，当从0到x-1位置所有数加起来取K的模，和0到Y位置所有数加起来取K的模相等，那么X到Y所有数加起来满足被K整除。这个定理很好证明，这里就不证明了。</p><p>所以我们就顺然想到了前缀和。我们可以统计该数组中所有的前缀和，那么就可以得到满足的子数组数目了。</p><p>这里的实现思路是在遍历的时候维护一个hashMap，记录每种余数的前缀和有多少个。然后当遍历到i位置的时候，假如当前位置的前缀和取K的模是 M，那么查询hashMap，M对应的数目有多少个，那么就有多少个符合条件的数组了。</p><p>注意：这里因为和可能为负数，取模后可能出现负数，所以要进行矫正。不是简单的取绝对值，因为假如模是6,-2实际上等于4而不是2。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">subarraysDivByK</span><span class="params">(A: <span class="type">IntArray</span>?, K: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> hashMap = HashMap&lt;<span class="built_in">Int</span>,<span class="built_in">Int</span>&gt;()</span><br><span class="line">    hashMap[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (elem <span class="keyword">in</span> A!!)&#123;</span><br><span class="line">        sum += elem</span><br><span class="line">        <span class="keyword">val</span> remainder = (sum % K+K)%K</span><br><span class="line">        println(remainder)</span><br><span class="line">        <span class="keyword">val</span> indexNum = hashMap.getOrDefault(remainder,<span class="number">0</span>)</span><br><span class="line">        num += indexNum</span><br><span class="line">        hashMap[remainder] = indexNum+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>遍历一次数组</p><ul><li>时间复杂度：O(n)</li></ul><h5 id="空件复杂度"><a href="#空件复杂度" class="headerlink" title="空件复杂度"></a>空件复杂度</h5><p>维护一个哈希表。长度是Max（K，A.size）</p><ul><li>O(Max（K，A.size）)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：删除链表节点</title>
      <link href="/2020/05/24/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9/"/>
      <url>/2020/05/24/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="题目：删除链表节点"><a href="#题目：删除链表节点" class="headerlink" title="题目：删除链表节点"></a>题目：删除链表节点</h3><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 来源：力扣（LeetCode）</span><br><span class="line">&gt; 链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;shan-chu-lian-biao-de-jie-dian-lcof</span><br><span class="line"></span><br><span class="line">### 分析</span><br><span class="line"></span><br><span class="line">思路非常简单，找到那个节点，然后把前面的节点指向该节点的next就可以。注意c&#x2F;c++要释放内存。</span><br><span class="line"></span><br><span class="line">### 解答</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;kotlin</span><br><span class="line">fun deleteNode(head: ListNode?, &#96;val&#96;: Int): ListNode? &#123;</span><br><span class="line">    if (head?.next &#x3D;&#x3D; null) return head</span><br><span class="line">    if (head.&#96;val&#96;&#x3D;&#x3D;&#96;val&#96;) return head.next</span><br><span class="line">    var current &#x3D; head.next</span><br><span class="line">    var previous &#x3D; head</span><br><span class="line">    while (current!&#x3D;null)&#123;</span><br><span class="line">        if (current.&#96;val&#96;&#x3D;&#x3D; &#96;val&#96;) previous?.next &#x3D; current.next</span><br><span class="line">        previous &#x3D; current</span><br><span class="line">        current &#x3D; current.next</span><br><span class="line">    &#125;</span><br><span class="line">    return head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>遍历一次链表</p><ul><li>时间复杂度：O(n)</li></ul><h5 id="空件复杂度"><a href="#空件复杂度" class="headerlink" title="空件复杂度"></a>空件复杂度</h5><p>常量空间</p><ul><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：旋转链表</title>
      <link href="/2020/05/24/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/05/24/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="题目：旋转链表"><a href="#题目：旋转链表" class="headerlink" title="题目：旋转链表"></a>题目：旋转链表</h3><p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k &#x3D; 2</span><br><span class="line">输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br><span class="line">向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 来源：力扣（LeetCode）</span><br><span class="line">&gt; 链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;rotate-list</span><br><span class="line"></span><br><span class="line">### 分析</span><br><span class="line"></span><br><span class="line">这道题很简单。首先让链表变成环，然后看哪个是头节点，把上个节点的next指针变成null，返回该头节点即可。怎么找到头节点呢？用链表的长度-用k取链表长度模，就是头节点了。</span><br><span class="line"></span><br><span class="line">### 解答</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;kotlin</span><br><span class="line">fun rotateRight(head: ListNode?, k: Int): ListNode? &#123;</span><br><span class="line">    if (head?.next &#x3D;&#x3D; null) return head</span><br><span class="line"></span><br><span class="line">    var num &#x3D; 0</span><br><span class="line">    var current &#x3D; head</span><br><span class="line">    var previous : ListNode? &#x3D; head</span><br><span class="line">    while (previous?.next!&#x3D;null)&#123;</span><br><span class="line">        num++</span><br><span class="line">        previous &#x3D; previous.next</span><br><span class="line">    &#125;</span><br><span class="line">    num++</span><br><span class="line">    previous?.next &#x3D; current</span><br><span class="line">    val step &#x3D; num-k%num</span><br><span class="line">    for (i in 1..step)&#123;</span><br><span class="line">        previous &#x3D; current</span><br><span class="line">        current &#x3D; current?.next</span><br><span class="line">    &#125;</span><br><span class="line">    previous?.next &#x3D; null</span><br><span class="line">    return current</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>遍历一次链表</p><ul><li>时间复杂度：O(n)</li></ul><h5 id="空件复杂度"><a href="#空件复杂度" class="headerlink" title="空件复杂度"></a>空件复杂度</h5><p>常量空间</p><ul><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：合并k个有序链表</title>
      <link href="/2020/05/24/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/05/24/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="题目：合并k个有序链表"><a href="#题目：合并k个有序链表" class="headerlink" title="题目：合并k个有序链表"></a>题目：合并k个有序链表</h3><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>要解决这个问题，首先要解决合并2个有序链表的方法，并以此作为拓展来实现合并K个有序链表。关于合并两个有序链表这里不再描述，可以去看我的相关文章。</p><p>这里提供两个思路，一是不断通过两两合并的方式把全部链表合并起来；二是每次从所有链表中选出最小的那个加到链表尾部。</p><p>思路一：这个思路很清晰，但是要注意一点，不能够一条一条合进来，要进行分治法，先两两合并后，再把剩下的两两合并。例如1234，先2+1，再3+4，最后再3+7（这里的1234指的是4个链表）。</p><p>思路二：每次从所有节点中抽取一个节点出来。这里可以使用一个优先队列来维护k个数据。每次从队列中拿走一个节点后就把该节点的下一节点放进去。这样的好处就是，优先队列可以通过效率比较高的算法排序（堆算法），比我们一个个找的效率要高，坏处就是要占用额外的空间。下面的解答我没有使用队列，直接一个个去查找，读者可以自行尝试。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>(<span class="keyword">var</span> `<span class="keyword">val</span>`: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> next: ListNode? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解答一"><a href="#解答一" class="headerlink" title="解答一"></a>解答一</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mergeKLists</span><span class="params">(lists: <span class="type">Array</span>&lt;<span class="type">ListNode</span>?&gt;)</span></span>: ListNode? &#123;</span><br><span class="line">    <span class="keyword">val</span> listArray = ArrayList&lt;ListNode&gt;()</span><br><span class="line">    <span class="keyword">for</span> (node <span class="keyword">in</span> lists)&#123;</span><br><span class="line">        <span class="keyword">if</span> (node!=<span class="literal">null</span>) listArray.add(node)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listArray.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> listHead = ListNode(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> listCurrent = listHead</span><br><span class="line">    <span class="keyword">while</span> (listArray.isNotEmpty())&#123;</span><br><span class="line">        <span class="keyword">var</span> num = listArray[<span class="number">0</span>].`<span class="keyword">val</span>`</span><br><span class="line">        <span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until listArray.size)&#123;</span><br><span class="line">            <span class="keyword">if</span> (listArray[i].`<span class="keyword">val</span>`&lt;=num)&#123;</span><br><span class="line">                num = listArray[i].`<span class="keyword">val</span>`</span><br><span class="line">                index = i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        listCurrent.next = listArray[index]</span><br><span class="line">        listCurrent = listCurrent.next!!</span><br><span class="line">        <span class="keyword">if</span> (listArray[index].next!=<span class="literal">null</span>) listArray[index] = listArray[index].next!!</span><br><span class="line">        <span class="keyword">else</span> listArray.removeAt(index)</span><br><span class="line">    &#125;</span><br><span class="line">    listCurrent.next = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> listHead.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mergeKLists</span><span class="params">(lists: <span class="type">Array</span>&lt;<span class="type">ListNode</span>?&gt;)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> merge(lists,<span class="number">0</span>,lists.size-<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">merge</span><span class="params">(lists: <span class="type">Array</span>&lt;<span class="type">ListNode</span>?&gt;,s:<span class="type">Int</span>, e:<span class="type">Int</span>)</span></span>:ListNode?&#123;</span><br><span class="line">    <span class="keyword">if</span> (e&lt;=s) <span class="keyword">return</span> lists[s]</span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(merge(lists, s, s+(e-s)/<span class="number">2</span>),merge(lists,s+(e-s)/<span class="number">2</span>+<span class="number">1</span>,e))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mergeTwoLists</span><span class="params">(l1: <span class="type">ListNode</span>?, l2: <span class="type">ListNode</span>?)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="keyword">when</span>&#123;</span><br><span class="line">            l1==<span class="literal">null</span>&amp;&amp;l2==<span class="literal">null</span> -&gt; <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">            l1==<span class="literal">null</span> -&gt; <span class="keyword">return</span> l2</span><br><span class="line">            l2==<span class="literal">null</span> -&gt; <span class="keyword">return</span> l1</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> listNode :ListNode? = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">var</span> current = listNode</span><br><span class="line">        <span class="keyword">var</span> point1 = l1</span><br><span class="line">        <span class="keyword">var</span> point2 = l2</span><br><span class="line">        <span class="keyword">while</span> (point1!=<span class="literal">null</span>&amp;&amp;point2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (point1.`<span class="keyword">val</span>`&lt;point2.`<span class="keyword">val</span>`)&#123;</span><br><span class="line">                current?.next = point1</span><br><span class="line">                point1 = point1.next</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current?.next = point2</span><br><span class="line">                point2 = point2.next</span><br><span class="line">            &#125;</span><br><span class="line">            current = current?.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (point1==<span class="literal">null</span>)&#123;</span><br><span class="line">            current?.next = point2</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current?.next = point1</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> listNode?.next</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>假设一共有k个链表，每个链表的最长长度是n</p><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>第一种方法每次要从k个链表中查找最小值，一共需要找kn次</p><ul><li>时间复杂度：O(kn*k)</li></ul><p>第二种方法递归的层数是logk，（自底向上）第一层一共分为k/2组，每组需要的时间是O(2n)。第二层一共分为k/4组，每组需要的时间是O(4n),以此类推。</p><ul><li>时间复杂度：O(logk*kn)</li></ul><p>可以看到第二种的速度会更快点，但是如果使用先序队列，那么时间复杂度就一样了。</p><h5 id="空件复杂度"><a href="#空件复杂度" class="headerlink" title="空件复杂度"></a>空件复杂度</h5><p>第一种方法不需要任何数组空间，只需要少量变量</p><ul><li>空间复杂度：O(1)</li></ul><p>第二种方法需要用到递归，栈的深度是logk，所以是</p><ul><li>空间复杂度：O(logk)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：最小覆盖子字符串</title>
      <link href="/2020/05/23/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/05/23/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目：最小覆盖子字符串"><a href="#题目：最小覆盖子字符串" class="headerlink" title="题目：最小覆盖子字符串"></a>题目：最小覆盖子字符串</h3><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: S &#x3D; &quot;ADOBECODEBANC&quot;, T &#x3D; &quot;ABC&quot;</span><br><span class="line">输出: &quot;BANC&quot;</span><br></pre></td></tr></table></figure><p>说明：</p><p>如果 S 中不存这样的子串，则返回空字符串 “”。<br>如果 S 中存在这样的子串，我们保证它是唯一的答案。</p><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-window-substring" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-window-substring</a></p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这道题我到手的第一想法是用动态规划，但是后来发现，根本没有办法使用动态规划。首先，动态规划的难点在状态转换，而这道题没办法把以遍历的字符串进行状态记录，所以每次只能记录一下已遍历的字符串中是否有符合的字符串和最小长度，然后每次添加字符的时候都要把已遍历的字符串再遍历一次，因为你不确定是否可以变得更短，或者后面的可以组成更短的符合条件的字符串，所以显然可以发现动态规划很难进行下去。那怎么做呢，这里要提到另外一个概念：动态窗口。</p><p>顾名思义，我们要用一个窗口来标记字符串，然后通过窗口的平移和伸缩等进行遍历，直到遇到符合条件的字符串并记录。最终得到符合条件的最小字符串。</p><p>我们可以使用两个指针来表示窗口的左边界和右边界。每一轮的循环是：</p><ol><li>左指针不动，右指针一直往右，直到他们之间包含了字符串T，也就是所求的字符串。</li><li>左指针开始右移，去除掉左边无用的元素字符。</li><li>最终得到一个符合条件的字符串，并记录下来。</li></ol><p>上面三点是一个循环，然后不断重复，直到末尾。然后选择符合条件最短的字符串。</p><p>然后还有两个问题：</p><p>如何判断该字符是否在所求的字符串t中？如何判断左右指针之间是否已经包含了所求的字符串？这个问题可以通过维护一个hashMap来解决。先遍历一次所求的字符串t并把字符和对应的数目放进hashMap中，之后每遍历一次就-1，如果所有值都&lt;=0则说明已符合要求。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">fun</span> <span class="title">minWindow</span><span class="params">(s: <span class="type">String</span>, t: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty()||t.isEmpty()) <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> hashMap  = HashMap&lt;<span class="built_in">Char</span>,<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> (char <span class="keyword">in</span> t)&#123;</span><br><span class="line">            <span class="keyword">if</span> (hashMap.containsKey(char)) hashMap[char] = hashMap[char]!!+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span> hashMap[char] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> num = t.length</span><br><span class="line">        <span class="keyword">var</span> string = <span class="string">""</span></span><br><span class="line">        <span class="keyword">var</span> pointLeft = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> pointRight = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pointRight!=s.length)&#123;</span><br><span class="line">            <span class="keyword">while</span> (num!=<span class="number">0</span> &amp;&amp; pointRight&lt;s.length)&#123;</span><br><span class="line">                <span class="keyword">val</span> char = s[pointRight]</span><br><span class="line">                <span class="keyword">if</span> (hashMap.containsKey(char))&#123;</span><br><span class="line">                    hashMap[char] = hashMap[char]!!-<span class="number">1</span></span><br><span class="line">                    hashMap[char]?.let &#123;</span><br><span class="line">                        <span class="keyword">if</span> (it&gt;=<span class="number">0</span>) num--</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                pointRight++</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (num==<span class="number">0</span> &amp;&amp; pointLeft&lt;pointRight)&#123;</span><br><span class="line">                <span class="keyword">val</span> char = s[pointLeft]</span><br><span class="line">                <span class="keyword">if</span> (hashMap.containsKey(char))&#123;</span><br><span class="line">                    hashMap[char] = hashMap[char]!!+<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> (hashMap[char]!!&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        num++</span><br><span class="line">                        <span class="keyword">if</span> (string.isEmpty() || string.length&gt;pointRight-pointLeft)</span><br><span class="line">                            string = s.substring(pointLeft,pointRight)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                pointLeft++</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> string</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>首要要遍历一次字符串t，需要的时间是t的长度m。然后最坏情况下，左指针和右指针都需要遍历一次字符串s，需要的时间是s的长度n。</p><ul><li>时间复杂度：O(m+n)</li></ul><h5 id="控件复杂度"><a href="#控件复杂度" class="headerlink" title="控件复杂度"></a>控件复杂度</h5><p>需要维护一个哈希表，复杂度是t的长度m，以及一些中间变量。</p><ul><li>空间复杂度：O(m)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：两数相加</title>
      <link href="/2020/05/23/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
      <url>/2020/05/23/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目：两数相加"><a href="#题目：两数相加" class="headerlink" title="题目：两数相加"></a>题目：两数相加</h3><p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 &#x3D; 807</span><br></pre></td></tr></table></figure><p>拓展：如果是按照逆序呢？例如834=（8-&gt;3-&gt;4)</p><p>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers/solution/liang-shu-xiang-jia-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers/solution/liang-shu-xiang-jia-by-leetcode/</a><br>来源：力扣（LeetCode）</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这道题目思路很简单，再创建一个链表，然后记住进位，最后把剩下的接到后面即可。</p><p>关于拓展题目，使用递归或者栈来把顺序颠倒即可。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> * var li = ListNode(5)</span></span><br><span class="line"><span class="comment"> * var v = li.`val`</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode(var `val`: Int) &#123;</span></span><br><span class="line"><span class="comment"> *     var next: ListNode? = null</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addTwoNumbers</span><span class="params">(l1: <span class="type">ListNode</span>?, l2: <span class="type">ListNode</span>?)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="keyword">if</span>  (l1==<span class="literal">null</span>||l2==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> numString = StringBuilder()</span><br><span class="line">        <span class="keyword">var</span> carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> link1:ListNode? = l1</span><br><span class="line">        <span class="keyword">var</span> link2:ListNode? = l2</span><br><span class="line">        <span class="keyword">while</span> (link1!=<span class="literal">null</span>||link2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">val</span> one = link1?.`<span class="keyword">val</span>` ?: <span class="number">0</span></span><br><span class="line">            <span class="keyword">val</span> two = link2?.`<span class="keyword">val</span>` ?: <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> add = one+two+carry</span><br><span class="line">            <span class="keyword">if</span> (add&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">                add %= <span class="number">10</span></span><br><span class="line">            &#125;<span class="keyword">else</span> carry = <span class="number">0</span></span><br><span class="line">            numString.append(add)</span><br><span class="line"></span><br><span class="line">            link1?.let &#123; link1 = it.next &#125;</span><br><span class="line">            link2?.let &#123; link2 = it.next &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry==<span class="number">1</span>) numString.append(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">val</span> linkNode : ListNode = ListNode(numString[<span class="number">0</span>].toInt()-<span class="number">48</span>)</span><br><span class="line">        <span class="keyword">var</span> point = linkNode</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until numString.length)&#123;</span><br><span class="line">            <span class="keyword">val</span> node = ListNode(numString[i].toInt()-<span class="number">48</span>)</span><br><span class="line">            point.next = node</span><br><span class="line">            point = node</span><br><span class="line">        &#125;</span><br><span class="line">        point.next = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> linkNode</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：合并两个有序链表</title>
      <link href="/2020/05/23/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%90%88%E5%B9%B6%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/05/23/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%90%88%E5%B9%B6%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="题目：合并两个有序链表"><a href="#题目：合并两个有序链表" class="headerlink" title="题目：合并两个有序链表"></a>题目：合并两个有序链表</h3><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists</a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这道题目有两个做法，首先第一个是迭代这是做容易想到的。不断遍历，每次取出节点数字较小的拼接起来即可。</p><p>第二种方法是递归。每次分离出节点数字小的，然后把剩下继续递归，直到一方为空。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><ol><li>方法一：迭代</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> * var li = ListNode(5)</span></span><br><span class="line"><span class="comment"> * var v = li.`val`</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode(var `val`: Int) &#123;</span></span><br><span class="line"><span class="comment"> *     var next: ListNode? = null</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mergeTwoLists</span><span class="params">(l1: <span class="type">ListNode</span>?, l2: <span class="type">ListNode</span>?)</span></span>: ListNode? &#123;</span><br><span class="line">    <span class="keyword">when</span>&#123;</span><br><span class="line">        l1==<span class="literal">null</span>&amp;&amp;l2==<span class="literal">null</span> -&gt; <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        l1==<span class="literal">null</span> -&gt; <span class="keyword">return</span> l2</span><br><span class="line">        l2==<span class="literal">null</span> -&gt; <span class="keyword">return</span> l1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> listNode :ListNode? = ListNode(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> current = listNode</span><br><span class="line">    <span class="keyword">var</span> point1 = l1</span><br><span class="line">    <span class="keyword">var</span> point2 = l2</span><br><span class="line">    <span class="keyword">while</span> (point1!=<span class="literal">null</span>&amp;&amp;point2!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (point1.`<span class="keyword">val</span>`&lt;point2.`<span class="keyword">val</span>`)&#123;</span><br><span class="line">            current?.next = point1</span><br><span class="line">            point1 = point1.next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current?.next = point2</span><br><span class="line">            point2 = point2.next</span><br><span class="line">        &#125;</span><br><span class="line">        current = current?.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (point1==<span class="literal">null</span>)&#123;</span><br><span class="line">        current?.next = point2</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        current?.next = point1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listNode?.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>方法二：递归</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mergeTwoLists</span><span class="params">(l1: <span class="type">ListNode</span>?, l2: <span class="type">ListNode</span>?)</span></span>: ListNode?&#123;</span><br><span class="line">    <span class="keyword">when</span>&#123;</span><br><span class="line">        l1==<span class="literal">null</span>&amp;&amp;l2==<span class="literal">null</span> -&gt; <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        l1==<span class="literal">null</span> -&gt; <span class="keyword">return</span> l2</span><br><span class="line">        l2==<span class="literal">null</span> -&gt; <span class="keyword">return</span> l1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> list1 = l1</span><br><span class="line">    <span class="keyword">val</span> list2 = l2</span><br><span class="line">    <span class="keyword">if</span> (list1!!.`<span class="keyword">val</span>`&lt;list2!!.`<span class="keyword">val</span>`)&#123;</span><br><span class="line">        list1.next = mergeTwoLists(list1.next,list2)</span><br><span class="line">        <span class="keyword">return</span> list1</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        list2.next = mergeTwoLists(list2.next,list1)</span><br><span class="line">        <span class="keyword">return</span> list2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：每个元音包含偶数次的最长字符串</title>
      <link href="/2020/05/20/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%AF%8F%E4%B8%AA%E5%85%83%E9%9F%B3%E5%8C%85%E5%90%AB%E5%81%B6%E6%95%B0%E6%AC%A1%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/05/20/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%AF%8F%E4%B8%AA%E5%85%83%E9%9F%B3%E5%8C%85%E5%90%AB%E5%81%B6%E6%95%B0%E6%AC%A1%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ ，在子字符串中都恰好出现了偶数次。</p><p>示例 1：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;eleetminicoworoep&quot;</span><br><span class="line">输出：13</span><br><span class="line">解释：最长子字符串是 &quot;leetminicowor&quot; ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出：5</span><br><span class="line">解释：最长子字符串是 &quot;leetc&quot; ，其中包含 2 个 e 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;输入：s &#x3D; &quot;bcbcbc&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：这个示例中，字符串 &quot;bcbcbc&quot; 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 5 x 10^5</code></li><li><code>s</code> 只包含小写英文字母。</li></ul><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts</a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这道题目我拿到手上第一个想法就是动态规划。如果你也跟我一样的想法，那就说明你的思路到目前是对的。来，让我们重温一下动态规划的做题思路：</p><ul><li>建立数组</li><li>创建状态转化方程</li><li>遍历得出最终答案</li></ul><p>第一步很容易想到，因为是一个字符串，所以我们可以建立一个一维数组来记录字符串的长度。然后接下来是最难的地方：如何记录最长的字符串？如何进行状态转换？哪一个是最终答案？这几个问题解决了，也就解决这道题了。接下来我一步步说。</p><ol><li>首先我们的重点放在，如何进行动态转换。这就涉及两个问题：记录已遍历的字符串的信息；增加一个字符后转换的信息。这是动态规划题目的重点，我们要从题目的特殊性入手。</li><li>从这道题我们可以看到是求元音是偶数，每个元音都必须是偶数。我们假设字符串从 i 到 j 位之间是偶数，那么 0 到 i-1 ，和 0 到 j 的各个元音的奇偶性是一样的。为什么？偶数+偶数=偶数，奇数+偶数=奇数，而 i 到 j 是偶数，那么0到i-1和0到j奇偶性肯定一致。能够想到这个点后面就比较顺畅了。</li><li>现在我们知道最长字符串的特征了，那我们要做的就是，当遍历到第i位时，如何找到奇偶性和他相同且最靠前的字符串？假如元音只有a，那我们只需要记录两个位置：a是偶数的位置最小值和a是奇数的位置最小值。当我们不断遍历字符串时，根据遍历的字符得到已经遍历的字符串的a的奇偶性，再减去对应的a‘的奇偶性位置最小值就可以得到最长的字符串了。同样的道理，我们只需要把情况扩展到5个元音，也就是有2的5次方个最小值位置要记录，所以我们只需要建立一个数组来记录这些最小值，然后不断更新字符串的奇偶性即可。</li><li>最后在遍历过程中不断更新最大值。把上面的思路用代码表现出来，就可以了。</li></ol><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.max</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findTheLongestSubstring</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> num = <span class="number">0</span> <span class="comment">//记录最长符合条件字符串的最大值</span></span><br><span class="line">        <span class="keyword">var</span> status = <span class="number">0</span> <span class="comment">// 记录当前状态</span></span><br><span class="line">        <span class="comment">// 记录每一种状态的位置最小值</span></span><br><span class="line">        <span class="keyword">val</span> array = Array(<span class="number">1</span> shl <span class="number">5</span>) &#123;-<span class="number">1</span>&#125; </span><br><span class="line">        <span class="comment">// 0肯定符合偶数的条件，所以定为0，-1表示还没找到位置最小值</span></span><br><span class="line">        array[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="comment">//遍历字符串并更新状态</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> s.indices)&#123;</span><br><span class="line">            <span class="keyword">when</span>(s[i])&#123;</span><br><span class="line">                <span class="string">'a'</span> -&gt; status = status xor <span class="number">1</span></span><br><span class="line">                <span class="string">'e'</span> -&gt; status = status xor (<span class="number">1</span> shl <span class="number">1</span>)</span><br><span class="line">                <span class="string">'i'</span> -&gt; status = status xor (<span class="number">1</span> shl <span class="number">2</span>)</span><br><span class="line">                <span class="string">'o'</span> -&gt; status = status xor (<span class="number">1</span> shl <span class="number">3</span>)</span><br><span class="line">                <span class="string">'u'</span> -&gt; status = status xor (<span class="number">1</span> shl <span class="number">4</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果前面已经有对应的状态出现，那么就减去得到长度，如果没有就把当前位置放上去。记得加1，因为位置是从0开始</span></span><br><span class="line">            <span class="keyword">if</span> (array[status]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                num = max(num,i+<span class="number">1</span>-array[status])</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                array[status] = i+<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后返回最大长度</span></span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>我做这道题的时候有点太局限于动态规划的思路，一开始就把数组建立好了，然后就一直在如何记录已遍历字符串的信息上面死磕，其实这样是不好的。数组怎么创建要放在分析题目后去具体建立，不能一开始就限制了思维。然后根据题目的特殊性去做好<strong>状态转换</strong>这个点。知道怎么转换状态了，后面的就非常流畅了。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：逆转链表</title>
      <link href="/2020/05/19/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E9%80%86%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/05/19/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E9%80%86%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>反转一个单链表。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><p>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list</a></p></blockquote><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>这道题是经典链表题目，可以用迭代和递归两种不同的思路来进行解决</p><h4 id="解答一：使用迭代"><a href="#解答一：使用迭代" class="headerlink" title="解答一：使用迭代"></a>解答一：使用迭代</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>这个方法要使用到三个指针，第一个指向前一个节点，第二个指向当前节点，第三个指向下一个节点。每次把当前节点的next指针指向前一个节点，然后把三个指针往后移动，重复直到完成逆转。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> * var li = ListNode(5)</span></span><br><span class="line"><span class="comment"> * var v = li.`val`</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode(var `val`: Int) &#123;</span></span><br><span class="line"><span class="comment"> *     var next: ListNode? = null</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">reverseList</span><span class="params">(head: <span class="type">ListNode</span>?)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        <span class="keyword">if</span> (head.next==<span class="literal">null</span>) <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">var</span> pre : ListNode? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> current : ListNode? = head</span><br><span class="line">        <span class="keyword">var</span> next : ListNode? = head.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">val</span> temp : ListNode? = next.next</span><br><span class="line">            current?.next = pre</span><br><span class="line">            pre = current</span><br><span class="line">            current = next</span><br><span class="line">            next = temp</span><br><span class="line">        &#125;</span><br><span class="line">        current?.next = pre</span><br><span class="line">        <span class="keyword">return</span> current</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解答二：使用递归"><a href="#解答二：使用递归" class="headerlink" title="解答二：使用递归"></a>解答二：使用递归</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>递归相比迭代思维比较容易想一点，代码也比较简单。但是会占用更多的空间。我们可以假设链表分为两段，前一段已经逆转完成，后一段递归进行逆转，然后把后一段的指针指向前一段即可</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> * var li = ListNode(5)</span></span><br><span class="line"><span class="comment"> * var v = li.`val`</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode(var `val`: Int) &#123;</span></span><br><span class="line"><span class="comment"> *     var next: ListNode? = null</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">reverseList</span><span class="params">(head: <span class="type">ListNode</span>?)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="keyword">return</span> point(<span class="literal">null</span>,head)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">point</span><span class="params">(pre:<span class="type">ListNode</span>?,current:<span class="type">ListNode</span>?)</span></span>:ListNode?&#123;</span><br><span class="line">        <span class="keyword">if</span> (current==<span class="literal">null</span>) <span class="keyword">return</span> pre</span><br><span class="line">        <span class="keyword">val</span> next = current.next</span><br><span class="line">        current.next = pre </span><br><span class="line">        <span class="keyword">return</span> point(current,next)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>刚开始做的时候在指针这一块出现了一点小问题，在考虑是用几个指针，如何进行迭代等。这道题难度不高，但是要熟练掌握两种不同做法</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>json数据与String的互相转换</title>
      <link href="/2020/04/21/other/json%E6%95%B0%E6%8D%AE%E4%B8%8EString%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/"/>
      <url>/2020/04/21/other/json%E6%95%B0%E6%8D%AE%E4%B8%8EString%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>﻿json数据本质上也是字符串，所以他们之间的转换也是比较容易的，记住方法和需要注意的事项就行了。</p><h4 id="字符串转json"><a href="#字符串转json" class="headerlink" title="字符串转json"></a>字符串转json</h4><p>在构造json的对象时候把string对象传进去即可。看例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String data = <span class="string">"&#123;</span></span><br><span class="line"><span class="string">    "</span>result<span class="string">":"</span>success<span class="string">",</span></span><br><span class="line"><span class="string">    "</span>message<span class="string">":null</span></span><br><span class="line"><span class="string">    &#125;"</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">JSONObject jsonObect = <span class="keyword">new</span> JSONObject(data);</span><br><span class="line">&#125; <span class="keyword">catch</span> (JSONException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span>(NullPointerException e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里建立jsonObject对象的时候因为不确定该字符串是否符合json规范，如果不符合规范就会抛出JSONException异常，而如果该字符串是null的时候就会抛出空指针异常。这里也可以判断一下字符串是否为空防止空指针异常。</p><h4 id="json数据转字符串"><a href="#json数据转字符串" class="headerlink" title="json数据转字符串"></a>json数据转字符串</h4><p>这个就比较容易了，直接调用jsonObject对象的toString方法即可。看代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的jsonObject是上文的JSONObject对象</span></span><br><span class="line">String s = jsonObect.toString();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Activity启动模式简析</title>
      <link href="/2020/04/21/Android/Android%E4%B8%ADActivity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/04/21/Android/Android%E4%B8%ADActivity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平常我们启动活动的时候就是直接startActivity或许并没有注意活动的启动模式，默认情况下都是以默认的启动模式启动。但启动模式有时候是比较重要的。例如一个活动你想他只启动一次不要有多个实例，那么你可能需要把他设置为singleTask模式。所以有必要了解一下这一些启动模式。同时要注意一下，启动模式≠启动方式，启动方式是指显示启动和隐式启动，不要混淆，显示启动和隐式启动后续我会有专门的文章讲解。</p><h1 id="关于任务栈简介"><a href="#关于任务栈简介" class="headerlink" title="关于任务栈简介"></a>关于任务栈简介</h1><p>要了解启动模式，首先要了解一下关于任务栈的概念。关于任务栈的实现原理等我在这里就先不说了，这里主要简单介绍一下什么是任务栈。我们启动的活动实例都会放在一个叫做任务栈的东西里面。我们都知道栈是“后进先出”的特点。打个比方，任务栈就是一个羽毛球筒，活动实例就是一个个羽毛球，后放进去的只能先拿出来。所以当我们启动一个app的时候，就会自动创建一个任务栈，然后我们就往里面丢活动实例。当我们按返回销毁活动的时候，这些活动就依次从任务栈里面出来。当然，一个app可以拥有多个任务栈，例如使用singleInstence启动的活动就是在一个独立的任务栈中。了解完任务栈的概念，接下来就可以来看看活动的四种启动模式。</p><h1 id="解析Activity的四种启动模式"><a href="#解析Activity的四种启动模式" class="headerlink" title="解析Activity的四种启动模式"></a>解析Activity的四种启动模式</h1><h3 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h3><p>这种是标准启动模式，默认就是这种启动模式。每次启动这种启动模式的活动的时候都会创建一个新的实例放入栈中，不管栈中是否已经存在相同的实例。这也是最容易理解的。</p><h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h3><p>顾名思义，栈顶是单一实例的。什么意思呢。假设你现在启动一个ActivityA，但是这个时候已经存在一个ActivityA实例在栈顶，那么这个时候，就不会创建新的实例。但是如果，在非栈顶存在相同的实例，还是会创建新的实例的。例如，现在栈中的活动是 ABC，A处于栈顶。然后此时启动A，是不会再创建一个A活动出来，而是执行A的onNewIntent方法；但是如果此时启动C活动，由于栈顶是A不是C，那么还是会创建一个新的C实例出来，此时的栈情况就是CABC。</p><h3 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h3><p>单一任务模式。这个模式的意思是，在该活动的启动栈中，只能存在单一实例，不管是否位于栈顶。与其他启动模式不同的是，这个启动模式可以指定栈去启动。例如现在有一个栈Main，但是你可以给活动A指定一个栈名dev，那么启动A的时候就会创建一个栈叫做dev。所以singleTask的意思就是，当你启动一个启动模式为singleTask的活动的时候，如果栈中没有相同的实例，那么就会创建一个新的实例放入栈中；如果指定栈中存在相同的实例，例如栈中有ABC，然后你启动B，那么这个时候不会去创建新的B实例，而是把B放到栈顶，并把A顶出去，再执行B的onNewIntent方法，此时栈的情况就是BC。<br>细心的读者会发现“顶出去”。是的，我们都知道栈是后进先出的特点，例如你往筒里放了3个羽毛球，那你想要拿到中间那个羽毛球，是不是只能先把上面那个抽出来呢，同样的道理，要想把B提到栈顶，那么必须把A顶出来。可能会有很多读者误以为启动后是BAC，但其实是BC，因为A得先出栈，B才能出来。同理，如果栈中是ADFBC，这个启动B，也是BC，上面的全部被出栈了。</p><h3 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h3><p>单例模式。这个是singleTask的强化版本。他会自己新建一个栈并把这个新的实例放进去，而且这个栈只能放这个活动实例。所以当重复启动这个活动的时候，只要他存在，都是调用这个活动onNewIntent方法并切换到这个栈中，并不会去创建新的实例。</p><h1 id="设置启动模式的两种方法"><a href="#设置启动模式的两种方法" class="headerlink" title="设置启动模式的两种方法"></a>设置启动模式的两种方法</h1><p>了解了活动的四种启动模式，接下来看看如何给他指定启动模式。</p><h3 id="静态设置"><a href="#静态设置" class="headerlink" title="静态设置"></a>静态设置</h3><p>静态设置就是在AndroidManifest中给具体活动设置启动模式。通过给活动指定launchMode参数来设置启动模式。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">".MainActivity"</span></span><br><span class="line">           android:launchMode=<span class="string">"singleInstance"</span>/&gt;</span><br></pre></td></tr></table></figure><h3 id="动态设置"><a href="#动态设置" class="headerlink" title="动态设置"></a>动态设置</h3><p>动态设置是在启动活动的时候再指定启动模式，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setClass(<span class="keyword">this</span>,SecondActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>可以看到我们通过intent.addFlags这个方法来指定启动模式，这个方法传入一个参数来指定启动模式，其他的参数有：</p><ul><li>FLAG_ACTIVITY_NEW_TASK：singleTask模式</li><li>FLAG_ACTIVITY_SINGLE_TOP：singleTop模式</li><li>FLAG_ACTIVITY_CLEAR_TOP:清除该活动上方的所有活动。一般和singleTask一起使用。但是如果你的启动模式是standard，那么这个活动连他之上的所有活动都会被出栈再创建一个新的实例放进去。例如现在栈中是ABCD，以FLAG_ACTIVITY_CLEAR_TOP+standard模式启动C的时候，首先清理掉ABC，是的，C也会被清理，然后再创建一个新的C放进去，执行之后就是CD。<h1 id="特别注意的坑"><a href="#特别注意的坑" class="headerlink" title="特别注意的坑"></a>特别注意的坑</h1><h3 id="singleInstance返回任务栈"><a href="#singleInstance返回任务栈" class="headerlink" title="singleInstance返回任务栈"></a>singleInstance返回任务栈</h3>现在模拟一个场景：现在有三个活动 A,B,C。A和C的启动模式都是standard，B的启动模式是singleInstance。先启动A，再启动B，然后再启动C。这个时候问题来了，如果我这个时候按下返回键，是回到B吗？答案是回到A。再按一下呢，返回桌面吗？答案是回到B，再按一下再回到桌面。其实不难理解。我们都知道singleInstance会创建一个独立的栈，当我们启动A的时候，A位于栈First中，启动B的时候，就会创建一个栈Second并把B实例放进去。这个时候再启动C，就会切换到栈FIrst，因为singleInstance创建的栈只能放一个，所以C会放到栈First中，当按下返回的时候，栈First中的活动就会依次出栈，直到全部出完，才会切换到栈Second中。所以要注意这个点。<h3 id="singleTask多任务栈启动问题"><a href="#singleTask多任务栈启动问题" class="headerlink" title="singleTask多任务栈启动问题"></a>singleTask多任务栈启动问题</h3>这个问题和上面singleTop的本质是一样的。模拟一个场景：现在有两个栈：First：ABC；Second：QWE。栈First位于前台，栈Second位于后台。A位于栈顶。这个时候以singleTask的模式启动W，会发生什么样的情况呢？首先会切换到栈Second，再把Q出栈，W提到栈顶，并执行W的onNewIntent方法。这个时候按返回键就会把Second栈中的活动依次出栈，全部出完后才会切换到栈First。<h3 id="singleTask的TaskAffinity与allowTaskReparenting参数"><a href="#singleTask的TaskAffinity与allowTaskReparenting参数" class="headerlink" title="singleTask的TaskAffinity与allowTaskReparenting参数"></a>singleTask的TaskAffinity与allowTaskReparenting参数</h3>前面我们讲到给singleTask模式指定要启动的任务栈的名字，怎么指定呢？可以在AndroidManifest中指定相关的属性，如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">".Main2Activity"</span></span><br><span class="line">            android:launchMode=<span class="string">"singleTask"</span></span><br><span class="line">            android:taskAffinity=<span class="string">"com.huan"</span></span><br><span class="line">            android:allowTaskReparenting=<span class="string">"true"</span>/&gt;</span><br></pre></td></tr></table></figure>这里解释一下这两个参数</li><li>taskAffinity：指定任务栈的名字。默认的任务栈是包名，所以不能以包名来命名。</li><li>allowTaskReparenting：这个参数表示可不可以切换到新的任务栈，通常设置为true并和上面的参数一起使用。<br>我前面讲到可以给singleTask的活动指定一个栈名，然后启动的时候，就会切换到那个栈，并把新的活动放进去。但是如果设置allowTaskReparenting参数为false的话是不会切换到新的栈的。这个参数的意思是可不可以把新的活动转移到新的任务栈。简单点来说：当我们启动一个singleTask活动的时候，这个活动还是留在启动他的活动的栈中的。但是我们指定了taskAffinity这个参数，或者启动的活动是别的应用中的活动，那么就会创建一个新的任务栈。如果allowTaskReparenting这个参数是true的话，那么这个活动就会放到那个新的任务栈中。这样应该就可以明白了。所以这两个经常是配套一起使用的。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> 活动的启动模式有四种，每种的功能都不一样，可以结合具体需要去使用，但是最重点还是要了解他的实现原理，栈中是怎么变化的，这个是比较重要的。了解这个之后那些特殊情况也就很容易理解了。<br> 上面我讲的只是简单的使用，关于活动启动模式还有很多要了解。后续可能会解析一下，读者也可以自行去深度了解。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《Android开发艺术探索》 –任玉刚</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Intent-Filer匹配规则解析</title>
      <link href="/2020/04/21/Android/Android%E4%B8%AD%E7%9A%84Intent-Filer%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/04/21/Android/Android%E4%B8%AD%E7%9A%84Intent-Filer%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们都知道，活动的启动方式有两种：一种是显示启动，或者很简单，指定一个活动的class就可以了；另外一种就是隐式启动，这种要指定action，category，data信息，例如我们在启动系统相机的时候。看一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"android.media.action.IMAGE_CAPTURE"</span>);</span><br><span class="line">                intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri);</span><br><span class="line">                startActivityForResult(intent,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>其中的”android.media.action.IMAGE_CAPTURE”就是相机的action，这样就可以启动相机了。<br>隐式启动我们在平时也用的比较少，对于自己应用中的Activity都是直接显示启动了。那什么时候用到隐式启动呢？一般是在启动别的应用的activity的时候，例如上面讲到的相机。<br>上面讲到的action，category，data就是intent-filer，也就是过滤器，筛选要启动的activity。<br>intentFiler有什么用？就像给自己上个标签。例如，你给自己上个标签是大学生，那么，当说学生出来，欸那么就匹配到你了。这个就是intentfiler的作用。用于筛选匹配。<br>那么这三个action，category，data究竟是什么？他们的具体匹配规则又是什么样的？上面讲到intentFiler是用于启动别的应用，有哪些常用的intentfiler可以使用？接下来我们就来看看。</p><h1 id="intentFiler的结构"><a href="#intentFiler的结构" class="headerlink" title="intentFiler的结构"></a>intentFiler的结构</h1><p>前面讲到intentFiler包含三个：action，category，data，让我看一下代码熟悉一下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=<span class="string">"huan"</span>/&gt;</span><br><span class="line">                &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure><p>另外包括我们最熟悉的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line"></span><br><span class="line">                &lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure><p>这三个分别表示不同的意义。你想要启动什么样的activity就通过设置这些属性来启动到对应的activity。当我们自己设置intentFiler的时候也要注意他的意义性，虽然很多可以随便设置，但是就像变量名称一样，不要随便起。</p><h1 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h1><p>action是最简单也是最常用的。</p><ul><li>意义：这个参数表示启动这个活动要干嘛。例如上面相机的是android.media.action.IMAGE_CAPTURE，很明显就是拍照功能。action的本质也是一个字符串，匹配就必须每个字符都一样，包括大小写。上面说过，虽然可以随便写这个字符串，但是要有意义。</li><li>匹配规则：action的匹配规则也很简单，Intent中的action和intentFilter中的任意一个action匹配，那么匹配成功。但是如果Intent中的action是空的，那么匹配失败。<h1 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h1>这个参数平时用得比较少，一般在一些比较特殊的情况才会用到</li><li>意义：这个参数平常使用的意义是表示实现这个action动作的类别，也就是可以响应这个Intent的组件类别。例如上面的category android:name=”android.intent.category.LAUNCHER”，表示这个action将会在顶级执行，什么意思呢？就是我们每次打开应用都会打开的第一个activity。</li><li>匹配规则：可以设置多个category。但是intent中的每一个category都必须和intentFilter中的其中一条category匹配才能匹配成功。</li><li>注意：给activity设置intentFilter的时候，如果没有其他的category，必须设置category android:name=”android.intent.category.DEFAULT”这个category。原因是startActivity或者starActivityForResult这两个方法执行的时候，如果intent中没有category的话，那么就会自动加上”android.intent.category.DEFAULT”这个category。<h1 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h1>data是三个中最复杂的一个，顾名思义，这个参数就是用来传递数据的。data不同于前面两个，他由两部分组成：Uri+mimeType.<br>很多读者可能还不怎么了解Uri这个东西，可以通过这个<a href="https://www.jianshu.com/p/7690d93bb1a1" target="_blank" rel="noopener">Android URI总结</a>简单了解一下Uri。这里就不展开了。我们先来看看data的组成：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;data android:scheme=<span class="string">""</span></span><br><span class="line">                    android:host=<span class="string">""</span></span><br><span class="line">                    android:port=<span class="string">""</span></span><br><span class="line">                    android:path=<span class="string">""</span></span><br><span class="line">                    android:pathPattern=<span class="string">""</span></span><br><span class="line">                    android:pathPrefix=<span class="string">""</span></span><br><span class="line">                    android:mimeType=<span class="string">""</span>/&gt;</span><br></pre></td></tr></table></figure>data一共由7个参数组成，一起来看看分别是什么意思：</li><li>scheme：这个表示uri的模式，有最熟悉的http：//这就是一种模式，另外安卓中还有比较常见的两种是：content：//和file：//。有学过ContentProvider的读者应该对content模式就很熟悉了。</li><li>host，port：host是主机，port是端口号，这两个合称authority。例如<a href="http://www.baidu.com这个应该就很熟悉了吧。在ContentProvider中表示哪一个contentProvider。" target="_blank" rel="noopener">www.baidu.com这个应该就很熟悉了吧。在ContentProvider中表示哪一个contentProvider。</a></li><li>path，pathPattern，pathPrefix：这三个表示路径信息。一是完整的路径，二是可以用通配符来表示例如image/*，三是路径的前缀。</li><li>mimeType：这个表示媒体类型。例如image/jpeg</li></ul><p>讲完他的结构后，有的读者可能会发现，这个data不就是一个地址+文件类型吗？是的，uri本身就是地址的意思。我们平时什么时候用到data呢？举个例子，我们调用相机拍照并存储到指定的文件夹，那么怎么让相机知道地址呢？就是data了，我们通过intent启动相机，并把地址放在data传输过去。这里的uri还涉及到安卓版本的影响有所不用，有兴趣的读者可以去了解一下。</p><p>那么，data的匹配规则是怎么样的呢？<br>和action是一样的，要求intent中必须要有data，而且和intentFilter中的一个相匹配就可以匹配成功。</p><ul><li>注意：如果在intentFilter中的data没有设置uri，那么默认的schme就是content和file。<h1 id="设置intentFilter"><a href="#设置intentFilter" class="headerlink" title="设置intentFilter"></a>设置intentFilter</h1>看完了上面知道intentFilter中的三个参数怎么去匹配了，那怎么给活动设置intentFilter，怎么给intent传输参数知道吗？这个比较简单也简单讲一下：</li></ul><p>给活动设置intentFilter比较简单，只要在AndroidManifest中设置就可以了，看示例代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">".MainActivity"</span>&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line"></span><br><span class="line">                &lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">        &lt;/activity&gt;</span><br></pre></td></tr></table></figure><p>给intent设置参数也不难，一个一个来看：</p><ul><li>action：可以在新建Intent对象的时候顺便写进去，例如：<code>Intent intent = new Intent(&quot;android.intent.action.GET_CONTENT&quot;);</code>或者调用Intent的setAction方法：<code>intent.setAction(&quot;android.intent.action.GET_CONTENT&quot;);</code><ul><li>caterogy：通过intent的方法<code>intent.addCategory();</code></li><li>data：这个比较特殊一点因为他有两个部分：uri和mimeType。有三个方法：其中setType和setData分别是设置mimeType和uri的。但是这两个方法都分别会清空另一个的数据。什么意思呢？例如我通过setData设置了一个uri，然后再通过setType设置一个mimeType，那么第一个的uri就会不见了，被删除了。所以就有第三个方法：<code>intent.setDataAndType</code>。这个方法接受两个参数，uri和mimeType，同时设置两个参数，就不会被清除了。<h1 id="常用的intentFiler"><a href="#常用的intentFiler" class="headerlink" title="常用的intentFiler"></a>常用的intentFiler</h1>上面讲到intentFilter主要是用来启动别的应用的，例如相机，电话，那么有什么是比较常用的呢？具体可以查看这篇博客<a href="https://blog.csdn.net/lo5sea/article/details/38308513" target="_blank" rel="noopener">android 常用URI 值得记住</a>。不懂得也可以百度或者评论区留言。<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1>我们上面讲到intentFilter可以用来筛选要启动的activity，同样对于service和broadcast也是一样，也同样可以给他们设置intentFilter来隐式启动对应的组件。而平时用的最多还是隐式启动活动，特别是在调用别的应用的活动的时候。要掌握一些常见的调用，这也是很重要的。<br>同时intentFilter的匹配规则也是很重要，熟记才不会在自己设置intentFilter的时候出错。<br>其中还有很多细节没有讲清楚，有疑问的读者可以评论区留言。<br>·<br>·<br>·</li></ul></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.jianshu.com/p/7690d93bb1a1" target="_blank" rel="noopener">Android URI总结</a><br><a href="https://www.cnblogs.com/linjiqin/archive/2011/05/28/2061396.html" target="_blank" rel="noopener">ContentProvider和Uri详解</a><br><a href="https://www.jianshu.com/p/67d99a82509b" target="_blank" rel="noopener">详解Intent</a><br>《Android开发艺术探索》任玉刚</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>启动页白屏解决方案</title>
      <link href="/2020/04/21/Android/Android%E5%AE%89%E5%8D%93%E5%90%AF%E5%8A%A8%E9%A1%B5%20%20%E8%A7%A3%E5%86%B3%E6%89%93%E5%BC%80%E5%BA%94%E7%94%A8%E6%98%BE%E7%A4%BA%E7%99%BD%E5%B1%8F%E6%83%85%E5%86%B5/"/>
      <url>/2020/04/21/Android/Android%E5%AE%89%E5%8D%93%E5%90%AF%E5%8A%A8%E9%A1%B5%20%20%E8%A7%A3%E5%86%B3%E6%89%93%E5%BC%80%E5%BA%94%E7%94%A8%E6%98%BE%E7%A4%BA%E7%99%BD%E5%B1%8F%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<p>﻿当我们打开app的时候是不是会有一瞬间的白屏然后再进入主活动，虽然这并不会造成什么不好的后果，但是感觉用户体验就不是很好。像网易云音乐等等，打开一瞬间就显示了他们的loge，无缝衔接，没有白屏，怎么做到的呢？</p><p>一开始我的思路是这样的。可能是因为我们的主活动逻辑太多，所以加载会变慢，导致显示白屏。如果使用一个只显示一张本地图片的活动，那会不会就不会显示白屏了呢。话不多说我们尝试一下：</p><p>Activity中的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动页，显示倾旅的logo，停顿2秒后跳转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LunchActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_lunch);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启子线程进行停顿。如果在主线程停顿的话，会造成主页面卡死，所以在子线程sleep两秒后跳转</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                start();</span><br><span class="line">                LunchActivity.<span class="keyword">this</span>.finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跳转到主页面</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(LunchActivity.<span class="keyword">this</span>,MainActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>layout中的代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;android.support.constraint.ConstraintLayout</span><br><span class="line">    xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    xmlns:app=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span><br><span class="line">    xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    android:background=<span class="string">"#e74b37"</span></span><br><span class="line">    tools:context=<span class="string">".LunchActivity"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:id=<span class="string">"@+id/imageView5"</span></span><br><span class="line">        android:layout_width=<span class="string">"80dp"</span></span><br><span class="line">        android:layout_height=<span class="string">"80dp"</span></span><br><span class="line">        app:layout_constraintBottom_toBottomOf=<span class="string">"parent"</span></span><br><span class="line">        app:layout_constraintEnd_toEndOf=<span class="string">"parent"</span></span><br><span class="line">        app:layout_constraintStart_toStartOf=<span class="string">"parent"</span></span><br><span class="line">        app:layout_constraintTop_toTopOf=<span class="string">"parent"</span></span><br><span class="line">        app:layout_constraintVertical_bias=<span class="string">"0.31"</span></span><br><span class="line">        app:srcCompat=<span class="string">"@drawable/icon"</span> /&gt;</span><br><span class="line">&lt;/android.support.constraint.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure><p>这里简单指定一个imageView来显示一张图片。并把背景设置为橘色</p><p>最后再把启动页活动设置为主活动：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">"com.example.qinglv.LunchActivity"</span>&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line">                &lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">        &lt;/activity&gt;</span><br></pre></td></tr></table></figure><p>一切想的很好，完成后打开一看，还是会白屏，怎么回事？</p><p>活动的加载都是需要时间的，比较简单的活动时间会少点，但是以然会有一瞬间的白屏。那这个白屏到底是什么？就是每个活动的背景。当打开一个活动的时候，因为还没加载出内容，所以显示的就只是背景，所以我们只需要，改变这个背景，设置为我们需要的一个logo照片即可。怎么设置呢？</p><ul><li><p>背景是在主题中指定的，首先设置一个主题，把背景改成我们要的。一般和我们的启动页保持一致，这样的话就不会看起来像两个启动页一样。也可以像网易云音乐那样，背景设置成logo，但是启动页是放广告，但是这会影响用户体验（为了收入打点广告也是可以理解的）。看代码：<br>在res-value-styles：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=<span class="string">"NewAppTheme"</span> parent=<span class="string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;</span><br><span class="line">        &lt;!-- Customize your theme here. --&gt;</span><br><span class="line">        &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt;</span><br><span class="line">        &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt;</span><br><span class="line">        &lt;item name="android:windowBackground"&gt;@color/colorPrimary&lt;/item&gt;</span><br><span class="line">        &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure><p>重点是这句<code>&lt;item name=&quot;android:windowBackground&quot;&gt;@color/colorPrimary&lt;/item&gt;</code><br>这里我指定的是一种颜色你们也可以指定一张图片</p></li><li><p>再给启动页活动指定主题：<br>在：AndroidManifest：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">"com.example.qinglv.LunchActivity"</span></span><br><span class="line">           android:theme=<span class="string">"@style/NewAppTheme"</span>&gt;</span><br><span class="line">           &lt;intent-filter&gt;</span><br><span class="line">               &lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line">               &lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span><br><span class="line">           &lt;/intent-filter&gt;</span><br><span class="line">       &lt;/activity&gt;</span><br></pre></td></tr></table></figure><p>重点是这句<code>android:theme=&quot;@style/NewAppTheme&quot;</code></p></li></ul><p>然后再打开的时候，就会发现不会了。原本显示的白屏变成了我们设置好的图片。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android使用系统相机进行拍照</title>
      <link href="/2020/04/21/Android/Android%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9B%B8%E6%9C%BA%E8%BF%9B%E8%A1%8C%E6%8B%8D%E7%85%A7/"/>
      <url>/2020/04/21/Android/Android%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9B%B8%E6%9C%BA%E8%BF%9B%E8%A1%8C%E6%8B%8D%E7%85%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在日常的开发中有时候会遇到需要用到相机的需求，而相机也是很常用的东西，例如扫二维码啊拍照上传啊等等。这里我不讲像qq那样自定义很强的拍照功能（事实上我也不会），讲个最简单的调用系统相机拍照并储存</p><h1 id="调用系统相机步骤"><a href="#调用系统相机步骤" class="headerlink" title="调用系统相机步骤"></a>调用系统相机步骤</h1><p>这里我通过一个简单的例子来讲这个内容。<br>我自己写了一个demo，布局很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button"</span></span><br><span class="line">        android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_marginTop=<span class="string">"4dp"</span></span><br><span class="line">        android:text=<span class="string">"take phone"</span></span><br><span class="line">        app:layout_constraintEnd_toEndOf=<span class="string">"parent"</span></span><br><span class="line">        app:layout_constraintHorizontal_bias=<span class="string">"0.281"</span></span><br><span class="line">        app:layout_constraintStart_toStartOf=<span class="string">"parent"</span></span><br><span class="line">        app:layout_constraintTop_toTopOf=<span class="string">"parent"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:id=<span class="string">"@+id/imageView"</span></span><br><span class="line">        android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_marginTop=<span class="string">"29dp"</span></span><br><span class="line">        app:layout_constraintEnd_toEndOf=<span class="string">"parent"</span></span><br><span class="line">        app:layout_constraintStart_toStartOf=<span class="string">"parent"</span></span><br><span class="line">        app:layout_constraintTop_toBottomOf=<span class="string">"@+id/button"</span></span><br><span class="line">        app:srcCompat=<span class="string">"@mipmap/ic_launcher_round"</span> /&gt;</span><br></pre></td></tr></table></figure><p>就是一个按钮点击弹起相机，然后一个imageView显示拍到的照片。</p><p>·</p><p>接下来我想一下调用的整个过程我们需要做什么：<br>首先弹起相机肯定要跳到相机这个应用，那么就必须通过隐性启动相机的活动。<br>然后当我们返回应用的时候，还要将照片显示，所以这里就要用到startActivityForResult这个方法。<br>其次，我们拍照之后肯定要进行储存的，那么就涉及到文件的操作。<br>涉及到内存的操作就肯定要和权限打交道，所有还有权限相关的内容。<br>最后还有一个问题就是，相机拍完照是要储存照片的，所以我们要给他一个地址uri，但是可不可以直接把地址当成参数发过去呢？这里就要用到特殊的内容提供器FileProvider。<br>上面就是调用相机要用到的内容，虽然用的都很浅，但是都会涉及到。接下来看看具体怎么实现。看看Activity中的onCreate的代码：<br>·</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> Uri imageUri;</span><br><span class="line"><span class="keyword">private</span> ImageView imageView;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">       setContentView(R.layout.activity_main);</span><br><span class="line">       imageView = findViewById(R.id.imageView);</span><br><span class="line"></span><br><span class="line">       Button button = findViewById(R.id.button);</span><br><span class="line">       button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//创建一个File对象。getExternalCacheDir()获取应用的缓存目录，outputImage.jpg是照片名称</span></span><br><span class="line">               File outputImage = <span class="keyword">new</span> File(getExternalCacheDir(),<span class="string">"outputImage.jpg"</span>);</span><br><span class="line">               <span class="keyword">try</span>&#123;                </span><br><span class="line">               <span class="comment">//创建一个空文件            </span></span><br><span class="line">                   outputImage.createNewFile();</span><br><span class="line">               &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">               <span class="comment">//不同的安卓版本对用不同的获取Uri的方法</span></span><br><span class="line">               <span class="keyword">if</span> (Build.VERSION.SDK_INT&gt;=<span class="number">24</span>)&#123;</span><br><span class="line">                   imageUri =FileProvider.getUriForFile(MainActivity.<span class="keyword">this</span>,<span class="string">"huan"</span>,outputImage);</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   imageUri = Uri.fromFile(outputImage);</span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line"><span class="comment">//启动相机的对应Activity</span></span><br><span class="line">               Intent intent = <span class="keyword">new</span> Intent(<span class="string">"android.media.action.IMAGE_CAPTURE"</span>);</span><br><span class="line">               intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri);</span><br><span class="line">               startActivityForResult(intent,<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><p>我们来看看这里的代码：前面的代码很简单就是控件的初始化。<br>我们知道照片是要放文件夹得，所以这里要创建一个File对象，指定文件的路径以及名字。这里路径为什么要用getExternalCacheDir()呢？因为每个应用都有对应得缓存目录，访问这些目录得时候不用访问内存权限，这样得话就可以省去需求权限得步骤啦。这个目录在/scare/Android/data/<package name>/cache。</p><p>然后我们再创建一个空的文件夹。这里如果已经有照片了的话例如我们第二次拍照的时候，那么就不会创建新的空文件夹了。直到储存的时候才会被替换掉。</p><p>然后我们刚才讲到，拍到的图片要在我们的应用中展示，那么就必须用到内容提供器。这里用到FileProvider来获取uri，关于provider我在下文有讲到可以<a href="#jump">点击跳转</a><br>如果是低于4.4版本的安卓就用Uri.fromFile(outputImage);方法可以获取到uri</p><p>再通过隐式启动相机activity可以打开相机了。这里系统相机的action是android.media.action.IMAGE_CAPTURE，相机储存路径的参数名字是MediaStore.EXTRA_OUTPUT，并把uri传输进去。</p><p>好了这样就完成了拍照并把照片储存的步骤了。接下来还差什么？对了，把照片显示出来。现在在内存中已经有这个照片了，而且uri也知道，所以就很容易了，看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, @Nullable Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (requestCode == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (resultCode == RESULT_OK)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(imageUri));</span><br><span class="line">                imageView.setImageBitmap(bitmap);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们刚才使用startActivityForResult来启动活动的，所以就要重写这个方法来显示图片了。这里首先判断是哪个启动命令，然后再判断是否成功启动，再BitmapFactory.decodeStream这个方法来获取bitmap，再把bitmap显示出来就行了。BitmapFactory.decodeStream这个方法需要一个流，可以通过getContentResolver().openInputStream这个方法来开启一个流。</p><p>到此整个流程就解决了。</p><h1 id="FileProvider"><a href="#FileProvider" class="headerlink" title="FileProvider"></a><span id = "jump">FileProvider</span></h1><p>FileProvider是一个特殊的内容提供器，可以把一个file开头的uri改成content开头的，例如：file://uri -&gt; content://uri。那为什么要这么做呢？这里简单讲一下：<br>这个是因为在Android 7.0之后，官方禁止直接把一个真实路径的uri传输到别的应用，而我们要把地址送给相机，所以就会出现问题了。详细可以查阅这篇博客：<a href="https://blog.csdn.net/lmj623565791/article/details/72859156" target="_blank" rel="noopener">Android 7.0 行为变更 通过FileProvider在应用间共享文件吧</a></p><p>既然是内容提供器那么肯定是要进行注册的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;provider</span><br><span class="line">            android:name=<span class="string">"android.support.v4.content.FileProvider"</span></span><br><span class="line">            android:authorities=<span class="string">"huan"</span></span><br><span class="line">            android:exported=<span class="string">"false"</span></span><br><span class="line">            android:grantUriPermissions=<span class="string">"true"</span>&gt;</span><br><span class="line">            &lt;meta-data</span><br><span class="line">                android:name=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span><br><span class="line">                android:resource=<span class="string">"@xml/file_paths"</span> /&gt;</span><br><span class="line">        &lt;/provider&gt;</span><br></pre></td></tr></table></figure><p>这里的authorities参数必须和前面的getUriForFile方法的第二个参数保持一致，同个内容提供器的authorities肯定要一样啦。grantUriPermissions参数一定要是true，这个的大概意思就是给他的所有元素授权可以被访问，在FileProvider中这个参数必须是true（这也是为什么在4.4一下版本的安卓无法使用的原因之一，有兴趣可以去了解一下）export这个参数表示可不可以给其他的应用共享，这里要设置为false。&lt;meta-data这个是配置我们可以访问的文件路径，@xml/file_paths这个就是表示什么文件可以被访问，当然要建一个这个文件。看代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;paths xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br><span class="line">    &lt;external-path</span><br><span class="line">        name=<span class="string">"my_image"</span></span><br><span class="line">        path=<span class="string">"/"</span>/&gt;</span><br><span class="line">&lt;/paths&gt;</span><br></pre></td></tr></table></figure><p>&lt;external-path这个就是表示可以被访问的路径，name是后面映射用到的，可以自己随便起，我这里用一横杆表示整个目录可以被访问。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>调用系统相机的功能虽然不难，代码也不多，但是其中的零碎知识很多，零零散散，还是要注意的。特别是关于低高配的安卓版本问题还是要特别注意一下。</p><p>·<br>·<br>·<br>·</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《第一行代码》郭霖<br><a href="https://blog.csdn.net/lmj623565791/article/details/72859156" target="_blank" rel="noopener">Android 7.0 行为变更 通过FileProvider在应用间共享文件吧</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的Serializable与Android的Parcelable序列化简析</title>
      <link href="/2020/04/21/Android/%E7%AE%80%E6%9E%90Java%E4%B8%AD%E7%9A%84Serializable%E4%B8%8EAndroid%E4%B8%AD%E7%9A%84Parcelable%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2020/04/21/Android/%E7%AE%80%E6%9E%90Java%E4%B8%AD%E7%9A%84Serializable%E4%B8%8EAndroid%E4%B8%AD%E7%9A%84Parcelable%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="关于序列化"><a href="#关于序列化" class="headerlink" title="关于序列化"></a>关于序列化</h1><p>这篇文章主要来讲一下在安卓中关于序列化的问题。首先了解一个问题：什么是序列化？为什么要用到序列化？</p><ul><li><p>什么是序列化：序列化就是就是把一个对象变成可传输的二进制流，可以进行传输。</p></li><li><p>什么是反序列化：与序列化对应，反序列化就是把一个二进制流转化成对象。</p></li><li><p>哪里用到序列化：上面说到序列化就是把对象变得可传输；例如在内存，或者网络中传输数据的时候，就得把一个对象变成二进制流可以进行传输。除此之外，在各种通信中，例如进程间通信，文件读取写入等等都要用到序列化。涉及到数据传输，就得使用序列化。因为只有二进制流才可以进行传输。</p></li><li><p>我们在那些地方会遇到序列化：我们会发现，仅有基本数据类型可以自动进行序列化，但是我的自定义对象并不可以进行序列化。在哪里可以体现呢？当我们从一个Activity向另外一个Activity传递数据的时候，通过Intent，我们会发现只能放基本数据类型。</p></li><li><p>怎么让自定义的对象可序列化：就是我们要讲的Serializable和Parcelable接口。这两个接口就可以让我们的自定义对象可序列化。</p><p>那这两个接口怎么使用？他们有什么区别？这就是接下来我要讲的。</p><h1 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h1><h4 id="简述原理"><a href="#简述原理" class="headerlink" title="简述原理"></a>简述原理</h4><p>Serializable只要使用Java的ObjectOutputStream与ObjectInputStream来开启流。而这个接口主要就是用来标识这个对象可以被转换。关于IO流的相关知识，读者有兴趣可以去深入了解，这里不做深入探究。</p></li></ul><h4 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h4><p>这个序列化接口是Java提供的，实现了这个接口的类，其实例就可以进行传输。那么这个接口怎么使用呢？<br>直接实现这个接口就行了。<br>因为这是一个空接口，所以使用方法极其简单，只需要实现这个接口即可。接下来看个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String string1;</span><br><span class="line">    <span class="keyword">private</span> String string2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> Son son;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Son&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getString1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> string1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setString1</span><span class="params">(String string1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.string1 = string1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getString2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> string2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setString2</span><span class="params">(String string2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.string2 = string2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Son <span class="title">getSon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> son;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSon</span><span class="params">(Son son)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.son = son;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Son&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setList</span><span class="params">(List&lt;Son&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以把这个Test对象序列化了。</p><h1 id="Parcelable"><a href="#Parcelable" class="headerlink" title="Parcelable"></a>Parcelable</h1><p>同样是使对象可序列化，同样是继承接口，但是Parcelable相比Serializable就要复杂得多了。Paecelable需要在要序列化的类中利用Parcel重写序列化和反序列化的方法。</p><h4 id="Parcelable的实现原理"><a href="#Parcelable的实现原理" class="headerlink" title="Parcelable的实现原理"></a>Parcelable的实现原理</h4><p>Parcelable的实现原理主要就是在内存中开辟一个共享内存块，然后进行传输，看图：<br><img src="https://img-blog.csdnimg.cn/20191017234934209.png" alt="在这里插入图片描述"><br>如图在AB两个进程中要进行传输，不能直接把一个对象传输过去，开辟一块内存，通过Parcel，也就是打包的方式，把数据存在了共享内存，再把共享内存中的数据用Parcel取出来，实现数据传输。通俗点来讲，就像送外卖一样，商家找了外卖这个中间人，把食物打包给了外卖小哥，然后你再找外卖小哥拿外卖，再拆包就可以拿到食物了。<br>通过原理可以看到，实现这个接口的重点就在：装包，拆包。如果将对象里面的数据，一个个装起来，是我们要在类中实现的方法。而装拆包公司就是Parcel。所以首先来了解一下这个包装公司：Parcel！</p><h4 id="“包装公司”Parcel"><a href="#“包装公司”Parcel" class="headerlink" title="“包装公司”Parcel"></a>“包装公司”Parcel</h4><p>Parcel的使用和Intent是差不多的，就是write（put）进去，再read（get）出来。简单来看看怎么使用：</p><h6 id="装包"><a href="#装包" class="headerlink" title="装包"></a>装包</h6><p>直接上代码，相关方法说明看注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Parcel parcel;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打包字符串</span></span><br><span class="line">parcel.writeString(String string);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打包整型数</span></span><br><span class="line">      parcel.writeInt(<span class="keyword">int</span> num);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//打包布尔变量，要和bite进行转换</span></span><br><span class="line">      parcel.writeByte((<span class="keyword">byte</span>) (<span class="keyword">boolean</span> bl? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//打包字符串集合</span></span><br><span class="line">      parcel.writeStringList(List&lt;String&gt; list);</span><br><span class="line">      </span><br><span class="line">       <span class="comment">//ElemType表示一个自定义类</span></span><br><span class="line">      <span class="comment">//序列化对象的时候传入要序列化的对象和一个flag,这里的flag的意思是是否要将这个作为返回值返回</span></span><br><span class="line">      <span class="comment">//一般传入0，要作为返回值就写1。另外这个对象也一定要是可序列化的</span></span><br><span class="line">      parcel.writeParcelable(ElemType elem, <span class="number">0</span>);</span><br><span class="line">      </span><br><span class="line"> <span class="comment">//这里写入自定义元素集合有两种方法，区别是是否写入类的信息</span></span><br><span class="line"> <span class="comment">//第一种方法是不写入类信息，相对应的取出来的时候要用Parcel把元素里面的每一个元素拿出来</span></span><br><span class="line">      parcel.writeTypedList(mFriends);</span><br><span class="line">      <span class="comment">//第二种方法是写入类的信息，取出来的时候就要用类加载器去加载</span></span><br><span class="line">      parcel.writeList(mFriends);</span><br><span class="line">      <span class="comment">//同样也要保证集合的元素可序列化</span></span><br></pre></td></tr></table></figure><p>这里可以看到整体和Intent的传入数据是十分像的。重点有三个地方不太一样：</p><ul><li>布尔变量。布尔变量不能直接放进去，要转换成bite</li><li>可序列化对象。这个放进去的时候要保证这个对象是可序列化的，也就是必须实现序列化接口</li><li>集合。集合分为两种。一种是把元素类的信息也放进去，一种是不把元素的类的信息放进去。下面将拆包会详细讲一下。</li></ul><h6 id="拆包"><a href="#拆包" class="headerlink" title="拆包"></a>拆包</h6><p>直接上代码：（变量使用装包中的变量）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Parcel source;<span class="comment">//这个对象在反序列化的时候会作为参数传入供给使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取字符串</span></span><br><span class="line">String string= source.readString();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取整型</span></span><br><span class="line">        <span class="keyword">int</span> i = source.readInt();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取布尔数</span></span><br><span class="line">        <span class="keyword">boolean</span> b = source.readByte() != <span class="number">0</span>;<span class="comment">//这里注意转化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取自定义对象</span></span><br><span class="line"><span class="comment">// 读取对象需要提供一个类加载器去读取,因为写入的时候写入了类的相关信息</span></span><br><span class="line">ElemType e = source.readParcelable(ElemType<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//获取字符串集合</span></span><br><span class="line">        List&lt;String&gt; list = source.createStringArrayList();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这一类需要用相应的类加载器去获取</span></span><br><span class="line">        <span class="comment">//ElemType表示一个自定义类</span></span><br><span class="line">        source.readList(List&lt;Elemtype&gt; list, ElemType<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">        <span class="comment">//这一类需要使用自定义类的CREATOR,也就是使用Pacel的反序列方法去获取</span></span><br><span class="line">        <span class="comment">//source.readTypedList(ElemType e, ElemType.CREATOR); //对应writeTypeList</span></span><br><span class="line">        <span class="comment">//books = in.createTypedArrayList(ElemType.CREATOR); //对应writeTypeList</span></span><br></pre></td></tr></table></figure><p>主要就是对于布尔变量以及集合的转换会比较不一样。<br>代码中的Friend.CREATOR是Parcelable接口中反序列的方法，实现原理也是用Parcel把对象里面的数据一个个转换出来。</p><ul><li>布尔变量要进行转换</li><li>对象要用类加载器去加载。因为写入的时候写入了类信息</li><li>集合看情况；写入了类信息就要用类加载器；否则用反序列的方法。</li></ul><h6 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h6><p>Parcel的使用方法和Intent很像，但是有几个点要注意一下：</p><ul><li><p>Parcel中没有布尔变量，所以必须将布尔变量和bite进行转换</p></li><li><p>Parcel包装自定义对象时，这个对象对应的类必须也得是实现了序列化接口的才可以进行打包。装包的这个方法因为写入了类的信息，所以拆包的时候需要用到对应类的加载器来进行加载。</p></li><li><p>Parcel在包装集合的时候有两种方法：一种是写入类的信息，一种是不写入类的信息。但都有一个前提：集合中的元素必须是可序列化的。第一种方法需要用到类加载器去加载，第二种就需要用到自定义类中的Parcel的反序列化方法。</p></li><li><p>对于类中有多个相同类型的数据，例如3个字符串，3个int等等，存入的顺序和取出来的顺序一定要一致。例如存int a，int b；那么取出来的时候也得是int a，int b。不能颠倒。</p><h4 id="Parcelable的使用"><a href="#Parcelable的使用" class="headerlink" title="Parcelable的使用"></a>Parcelable的使用</h4><p>看完了上面的Pacel可能还是有一点懵，那这个怎么Parcelable怎么用Pacel实现呢？Parcelable的主要实现思路就是把一个对象中的数据进行分解，分解出来的数据都是可以用Parcel打包的。Parcelable具体怎么使用呢？接下来就来看一下。先看看谷歌给出的示例（代码很重要，记得看注释）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先要实现Parcelable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyParcelable</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line"><span class="comment">//类中的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mData;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来这两个方法是关于序列化的。一定要重写的两个方法</span></span><br><span class="line"><span class="comment">//第一个方法是内容描述。一般没什么要求都是返回0就行了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二个是序列化数据的方法。当我们序列化这个类的对象的时候就会调用到这个方法</span></span><br><span class="line">    <span class="comment">//两个参数：一个是Pacel“包装公司”上面我们讲的，一个是flags。第二个参数表示是否把数据返回。一般为0.</span></span><br><span class="line">    <span class="comment">//利用这个Parcel把类中所有的数据“打包”序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel out, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个就是上面我们介绍的Parcel的使用</span></span><br><span class="line">         out.writeInt(mData);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来的这两个就是关于反序列化的了</span></span><br><span class="line"><span class="comment">//CREATOR是Parcelable中的一个静态变量，这个名字不能改，因为他内部调用的时候就是用CREATOR来调用的改了名字就找不到了</span></span><br><span class="line"><span class="comment">//观察我们上面的Pacel使用方法也可以发现，是传入ElemType.CREATOR。如果改了名字就找不到了。</span></span><br><span class="line"><span class="comment">//Creator对象中有两个方法要重写：</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;MyParceable&gt; CREATOR</span><br><span class="line">             = <span class="keyword">new</span> Creator&lt;MyParceable&gt;() &#123;</span><br><span class="line">             </span><br><span class="line">          <span class="comment">//这个就是反序列方法了。在Pacel中把数据取出来构建成一个MyParcelable对象</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> MyParcelable <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//这里我们用到构造器来获取这个对象。具体构造器实现方法在下面</span></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> MyParcelable(in);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个是开辟数组供给使用。一般按照下面的格式写就好了。</span></span><br><span class="line">         <span class="keyword">public</span> MyParcelable[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> MyParcelable[size];</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">   <span class="comment">//这个是构造器。从Parcel中把数据取出来  </span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">MyParcelable</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//这里就用到了上面我们讲的Parcel的获取数据的方法了</span></span><br><span class="line">         mData = in.readInt();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码相信也可以很清晰的了解怎么实现了。主要就是分为两个部分：序列化和反序列化。</p></li><li><p>序列化主要就是用一个Parcel把数据封装起来。怎么使用按照上面的Parcel使用方法。</p></li><li><p>反序列化要用到一个静态变量，这也可以说是一个构造器，Creator本身就是创造的意思嘛。通过这个Creator吧Parcel中的数据取出来再构造成一个对象，对应拆包。具体我们使用构造器来实现。构造器里面用Parcel的获取数据方法来把数据取出来。需要注意的是这里的CREATOR名字不能改。</p><h1 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h1><p>好了。到这里相信都了解怎么使用这两个接口了。主要是Parcelable比较复杂。现在有个问题了，为什么要造一个如此复杂的接口呢？来看看他们各自的优缺点。</p><h5 id="Serializable-1"><a href="#Serializable-1" class="headerlink" title="Serializable"></a>Serializable</h5><p>这个是java内部定义的序列化接口。</p></li><li><p>优点：使用范围广，在网络，内存文件等均可以使用；使用方式简单，仅仅只需要继承一个接口就可以使用。</p></li><li><p>缺点：性能差；序列化的时候需要创建很多的临时对象。</p></li></ul><h5 id="Parcelable-1"><a href="#Parcelable-1" class="headerlink" title="Parcelable"></a>Parcelable</h5><p>这个安卓中可以使用的接口，仅用于安卓。</p><ul><li>优点：性能强大。开发者号称比Serialization强大10倍的性能。</li><li>缺点：实现过程复杂，需要把对象中的数据一个个拆开进行序列化；<pre><code>从实现原理可以看出来，这个只能用于内存中的序列化，不能用于网络和本地硬盘文件。</code></pre></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>序列化在安卓开发中还是很常用的，例如活动之间传递信息，跨进程传递数据等等都要用到。这两个接口一个简单粗暴，一个复杂强大，平常开发的话，尽量还是使用第二个接口，毕竟多一点代码可以加强这么多的性能何乐不为呢。Parcelable可能比较难理解，多看几遍就可以了。不理解或者笔者写错的可以评论区留言。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LitePal的使用</title>
      <link href="/2020/04/21/Android/LitePal%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/04/21/Android/LitePal%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据库操作一直都是比较繁琐而且单一的东西，平时开发中数据库也很常见。有学过mysql的读者可能会觉得sql语句确实让人很难受。同样android中，虽然有内置数据库SQLite，但是操作起来还是非常的不方便。跟网络请求类似，当我们用原生的HttpURLConnection请求数据再用json解析，过程很繁琐，所以我们一般是封装成一个工具类，但是retrofit出现了，他帮我们解决了网络请求和解析数据的封装，同时还支持RxJava的异步，十分强大。不了解retrofit的读者也建议你们去学习一下retrofit确实非常好用。LitePal也是同样的道理，把创建数据库和增删查改等等操作都封装起来，所以我们用起来会非常的方便。同时还支持异步操作，不需要我们自己去开启子线程，代码非常的整洁，简单。那接下来就来看看这个神奇的框架LitePal。</p><h1 id="简述映射"><a href="#简述映射" class="headerlink" title="简述映射"></a>简述映射</h1><p>LitePal是采用映射的方式来把数据存储在数据库中的，和GSON的道理是一样的。例如我们现在有一个类，这个类必须是javaBean类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">LitePalSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么他在数据库中就会有一个表，这个表有三列：id，name和age，id是自动生成的，这样就可以理解映射了吧。所以我们使用LitePal的时候不用去指定每一列是什么，只需要给他一个Bean类，自动就会生成了。</p><h1 id="配置LitePal"><a href="#配置LitePal" class="headerlink" title="配置LitePal"></a>配置LitePal</h1><p>LitePal使用之前需要先配置一下，一共分为两步：</p><ol><li>添加依赖库：在app/build.gradle中添加如下内容：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">'org.litepal.android:java:3.0.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>其中3.0.0是版本号，写这个文章的时候是3.0，他更新也是很快的，读者可以自行到文末进入官网查询最新的版本号。添加完之后sync一下就行了。</li><li>修改AndroidManifest中的代码：添加一句android:name=”org.litepal.LitePalApplication”：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">        android:name=<span class="string">"org.litepal.LitePalApplication"</span></span><br><span class="line">        ...</span><br><span class="line">&lt;application</span><br></pre></td></tr></table></figure></li></ol><p>添加这句的意思是让启动app的时候会自动实例化LitePalApplication这个类供给LitePal这个框架使用。如果有自己写了一个android：name的，那么只需要添加这一句LitePal.initialize(context);就可以了。其中的context参数为全局app的context。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Context context;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        context = getApplicationContext();</span><br><span class="line">        LitePal.initialize(context);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在main目录下创建一个Directory：assets。然后再assets目录下再创建一个litepal.xml，如下图：<br><img src="https://img-blog.csdnimg.cn/20190921221538303.png" alt="在这里插入图片描述"></li><li>编辑litepal.xml中的内容：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;litepal&gt;</span><br><span class="line">    &lt;dbname value=<span class="string">"bookStore"</span>/&gt;</span><br><span class="line">    &lt;version value=<span class="string">"1"</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;list&gt;     </span><br><span class="line">    &lt;/list&gt;</span><br><span class="line"></span><br><span class="line">&lt;/litepal&gt;</span><br></pre></td></tr></table></figure>dbname就是数据库的名字，version是数据库的版本，list中是数据库中的表，可以在这里添加，怎么添加后面会讲到。</li></ol><h1 id="CRUD操作"><a href="#CRUD操作" class="headerlink" title="CRUD操作"></a>CRUD操作</h1><p>常规增删查改操作，但是在这个框架下都显得特别的简单。</p><h2 id="增加表和数据"><a href="#增加表和数据" class="headerlink" title="增加表和数据"></a>增加表和数据</h2><ol><li>例如我们现在要在数据库中创建一个学生的表，首先要创建一个学生的类,再让他继承LitePalSupport类，至于为什么下面会讲到：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">LitePalSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>然后在刚才的litepal.xml中添加表：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;list&gt;</span><br><span class="line">       &lt;mapping <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.example.myapplication.Student"</span>/&gt;</span><br><span class="line">&lt;/list&gt;</span><br></pre></td></tr></table></figure>这里的class要是你的类的真实目录，视具体情况而定。<br>添加其他的表也是同样的道理。</li><li>调用student对象的save()方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">                student.setAge(<span class="number">12</span>);</span><br><span class="line">                student.setName(<span class="string">"hha"</span>);</span><br><span class="line">                student.save();</span><br></pre></td></tr></table></figure>这里的save方法就是继承前面的LitePalSuppport类的，调用这个方法后就会自动添加到库中对应的表中的一行。<br>添加其他行数据也是同样的道理<h2 id="更改表结构"><a href="#更改表结构" class="headerlink" title="更改表结构"></a>更改表结构</h2>更新表的列。例如前面的学生类是name和age，但是如果你想要增加一个studentId，可以很简单地实现。具体操作如下：</li><li>首先更改你的bean类，想怎么改就怎么改</li><li>在litepal.xml中更改版本号增加1.例如：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;litepal&gt;</span><br><span class="line">    &lt;dbname value=<span class="string">"bookStore"</span>/&gt;</span><br><span class="line">    &lt;version value=<span class="string">"2"</span>/&gt;</span><br><span class="line">    &lt;list&gt;</span><br><span class="line">            &lt;mapping <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.example.myapplication.Student"</span>/&gt;</span><br><span class="line">    &lt;/list&gt;</span><br><span class="line"></span><br><span class="line">&lt;/litepal&gt;</span><br></pre></td></tr></table></figure>把他改成2就行了。<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2>删除数据也很简单，有两种删除方法，一种是指定行删除，一种给个约束条件删除。</li><li>删除单行：<br>LitePal.delete(Student.class , id);</li><li>约束条件：<br>LitePal.deleteAll(Student.class, “age &gt; ?” , “12”);<br>指定约束条件删除，？是占位符会把后面的12放进去。<br>如果只传入一个Student.class，那么就会把整个表的数据都删除了</li></ol><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p>查询数据的接口都会返回一个List，每一行对应一个对象。所以是LitePal把数据解析都给我们做好了，我们直接拿对象使用就ok了。这里有几种方法接口都看一下：</p><ol><li>LitePal.findAll(Student.class,id);查询对应表的对应行，如果没有传入id参数，就返回这个表的所有内容。同样findFirst是返回第一行，findLast是返回最后一行。</li><li>查询的内容还可以进行筛选，这里就用到几个方法：<ul><li>select（）对应查哪几列的内容</li><li>where（）查询的约束条件</li><li>order（）排序方式</li><li>limit（）指定查询的数量</li><li>offset（）指定结果的偏移量。这个可能比较难理解，举个例子：假设你查的id是1，但是你设置了偏移量是1，那么返回的就是第二行的数据。<br>最后举一个综合例子演示一下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Song&gt; songs = LitePal.where(<span class="string">"name like ? and duration &lt; ?"</span>, <span class="string">"song%"</span>, <span class="string">"200"</span>)</span><br><span class="line">.order(<span class="string">"duration"</span>)</span><br><span class="line">.select(<span class="string">"name"</span>)</span><br><span class="line">.limit(<span class="number">3</span>)</span><br><span class="line">.offset(<span class="number">3</span>)</span><br><span class="line">.find(Song<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>这样就可以查询到对应的数据了。<h1 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h1>有时候如果我们的数据库中的内容很多，涉及到重量级的数据库操作往往是比较费时的，那么这个时候肯定时不能放在主线程去进行操作的，这样会造成系统卡死。那么我们就需要去把这个操作放在子线程中。LitePal早就为我们考虑到这个问题了，所以也增加了异步操作，轻松实现，来看看怎么用吧。<br>先看个例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LitePal.findAllAsync(Song<span class="class">.<span class="keyword">class</span>).<span class="title">listen</span>(<span class="title">new</span> <span class="title">FindMultiCallback</span>&lt;<span class="title">Song</span>&gt;() </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFinish</span><span class="params">(List&lt;Song&gt; allSongs)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>这是在官网中的例子，要注意的两个点</li><li>用findAllAsync代替findAll方法</li><li>添加listen方法，并新建匿名类FindMultiCallback&lt;&gt;()作为参数，重写里面的onFinish方法即可<br>这样获取完数据后就会执行onFinish方法了<br>轻松实现异步操作。同样这个可以结合上面的数据筛选。<h1 id="创建多个数据库"><a href="#创建多个数据库" class="headerlink" title="创建多个数据库"></a>创建多个数据库</h1>如果你一个数据库不够用，想要创建多个数据库，当然也是可以的，看代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LitePalDB litePalDB = <span class="keyword">new</span> LitePalDB(<span class="string">"demo2"</span>, <span class="number">1</span>);</span><br><span class="line">litePalDB.addClassName(Singer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">LitePal.use(litePalDB);</span><br></pre></td></tr></table></figure>这里就创建了一个库叫做demo2，并增加了一个表：Singer。最后执行LitePal.use方法来启用这个库。这样的话就默认使用这个库了。对象的save方法都会执行到这个库中<br>如果想切回到litepal.xml中的那个库，可以用下面的方法：<br>LitePal.useDefault();</li></ul></li></ol><p>如果想删除一个库（删库跑路可能会被乱棒打死）<br>LitePal.deleteDatabase(“demo2”);<br>是不是很简单？</p><h1 id="监听数据库创建或者升级"><a href="#监听数据库创建或者升级" class="headerlink" title="监听数据库创建或者升级"></a>监听数据库创建或者升级</h1><p>当数据库创建或者升级的时候都会调用下面的两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LitePal.registerDatabaseListener(<span class="keyword">new</span> DatabaseListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// fill some initial data</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(<span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// upgrade data in db</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以在里面写要执行的逻辑。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>LitePal这个库确实是非常的强大，把很复杂的数据库操作都简化成了一个个的方法。但是更新很快，需要时刻看着他更新的内容，有可能会换API，所以建议大家多去官网学习。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>·<br>·<br>·<br>《第一行代码》 郭霖<br>LitePal官网：<a href="https://github.com/LitePalFramework/LitePal" target="_blank" rel="noopener">LitePal项目地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调用系统相册选择照片</title>
      <link href="/2020/04/21/Android/Android%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%86%8C%E9%80%89%E6%8B%A9%E5%9B%BE%E7%89%87/"/>
      <url>/2020/04/21/Android/Android%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%86%8C%E9%80%89%E6%8B%A9%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在相册里选择图片上传也是很常见的功能了例如微信朋友圈等等。但是他们是自定义的选择器，可以选择多张图片并修改。这里我们讲一个最简单的：调用系统的相册选择一张图片并展示。另外有的读者还想到要通过相机拍照来选择图片的功能，也可以参考一下我的另一篇文章<a href="https://blog.csdn.net/weixin_43766753/article/details/101224631" target="_blank" rel="noopener">Android使用系统相机进行拍照</a></p><h1 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h1><p>这里我是通过一个简单的demo来讲解怎么去实现这个功能。首先看布局：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">    android:id=<span class="string">"@+id/button2"</span></span><br><span class="line">    android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">    android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">    android:layout_marginTop=<span class="string">"5dp"</span></span><br><span class="line">    android:layout_marginEnd=<span class="string">"52dp"</span></span><br><span class="line">    android:layout_marginRight=<span class="string">"52dp"</span></span><br><span class="line">    android:text=<span class="string">"choose"</span></span><br><span class="line">    app:layout_constraintEnd_toEndOf=<span class="string">"parent"</span></span><br><span class="line">    app:layout_constraintTop_toTopOf=<span class="string">"parent"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;ImageView</span><br><span class="line">    android:id=<span class="string">"@+id/imageView"</span></span><br><span class="line">    android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">    android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">    android:layout_marginTop=<span class="string">"29dp"</span></span><br><span class="line">    app:layout_constraintEnd_toEndOf=<span class="string">"parent"</span></span><br><span class="line">    app:layout_constraintStart_toStartOf=<span class="string">"parent"</span></span><br><span class="line">    app:layout_constraintTop_toBottomOf=<span class="string">"@+id/button"</span></span><br><span class="line">    app:srcCompat=<span class="string">"@mipmap/ic_launcher_round"</span> /&gt;</span><br></pre></td></tr></table></figure><p>很简单，就是一个按钮和一个imageView。然后接下来让我们想想这个功能怎么去实现：</p><p>首先打开相册，那么肯定要通过隐式启动相册activity；然后相册返回一个路径，我们就拿这个路径把路径上对应的照片展示出来。思路挺简单的，让我们写写看：<br>首先看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Uri imageUri;</span><br><span class="line">    <span class="keyword">private</span> ImageView imageView;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        imageView = findViewById(R.id.imageView);</span><br><span class="line">        Button button1 = findViewById(R.id.button2);</span><br><span class="line">        button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//动态申请权限</span></span><br><span class="line">                <span class="keyword">if</span> (ContextCompat.checkSelfPermission(MainActivity.<span class="keyword">this</span>,Manifest.permission</span><br><span class="line">                        .WRITE_EXTERNAL_STORAGE)!= PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">                    ActivityCompat.requestPermissions(MainActivity.<span class="keyword">this</span>,<span class="keyword">new</span> String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//执行启动相册的方法</span></span><br><span class="line">                    openAlbum();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">//获取权限的结果</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, @NonNull String[] permissions, @NonNull <span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (requestCode == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (grantResults.length&gt;<span class="number">0</span>&amp;&amp;grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED) openAlbum();</span><br><span class="line">            <span class="keyword">else</span> Toast.makeText(MainActivity.<span class="keyword">this</span>,<span class="string">"你拒绝了"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动相册的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openAlbum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="string">"android.intent.action.GET_CONTENT"</span>);</span><br><span class="line">        intent.setType(<span class="string">"image/*"</span>);</span><br><span class="line">        startActivityForResult(intent,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里先初始化控件，然后动态申请权限，因为我们要读取照片肯定是要读取内存的权限，记得在AndroidManifest中要写明权限：</p><figure class="highlight plain"><figcaption><span>android:name</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">获取权限后就打开相册选择。相册对应的action是android.intent.action.GET_CONTENT，setType(&quot;image&#x2F;*&quot;)这个方法表示把所有照片显示出来，然后开启活动。启动活动选择完照片后就会返回一个intent到onActivityResult方法中，所以接下来的主要工作就是如果获取到返回的路径。</span><br><span class="line"></span><br><span class="line">我们知道在安卓4.4以后是不能把文件的真实路径直接给别的应用的，所以返回的uri是经过封装的，所以我们要进行解析取出里面的路径。所以这里我们要进行判断安卓版本来进行不同的逻辑，先看代码：</span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">@Override</span><br><span class="line">    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123;</span><br><span class="line">    if (requestCode &#x3D;&#x3D; 2)&#123;</span><br><span class="line">    &#x2F;&#x2F;判断安卓版本</span><br><span class="line"> if (resultCode &#x3D;&#x3D; RESULT_OK&amp;&amp;data!&#x3D;null)&#123;</span><br><span class="line">                if (Build.VERSION.SDK_INT&gt;&#x3D;19)</span><br><span class="line">                handImage(data);</span><br><span class="line">                else handImageLow(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;安卓版本大于4.4的处理方法</span><br><span class="line">@RequiresApi(api &#x3D; Build.VERSION_CODES.KITKAT)</span><br><span class="line">    private void handImage(Intent data)&#123;</span><br><span class="line">        String path &#x3D;null;</span><br><span class="line">        Uri uri &#x3D; data.getData();</span><br><span class="line">        &#x2F;&#x2F;根据不同的uri进行不同的解析</span><br><span class="line">        if (DocumentsContract.isDocumentUri(this,uri))&#123;</span><br><span class="line">            String docId &#x3D; DocumentsContract.getDocumentId(uri);</span><br><span class="line">            if (&quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority()))&#123;</span><br><span class="line">                String id &#x3D; docId.split(&quot;:&quot;)[1];</span><br><span class="line">                String selection &#x3D; MediaStore.Images.Media._ID+&quot;&#x3D;&quot;+id;</span><br><span class="line">                path &#x3D; getImagePath(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,selection);</span><br><span class="line">            &#125;else if(&quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority()))&#123;</span><br><span class="line">                Uri contentUri &#x3D; ContentUris.withAppendedId(Uri.parse(&quot;content:&#x2F;&#x2F;downloads&#x2F;public_downloads&quot;),Long.valueOf(docId));</span><br><span class="line">                path &#x3D; getImagePath(contentUri,null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if (&quot;content&quot;.equalsIgnoreCase(uri.getScheme()))&#123;</span><br><span class="line">            path &#x3D; getImagePath(uri,null);</span><br><span class="line">        &#125;else if (&quot;file&quot;.equalsIgnoreCase(uri.getScheme()))&#123;</span><br><span class="line">            path &#x3D; uri.getPath();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;展示图片</span><br><span class="line">        displayImage(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;安卓小于4.4的处理方法</span><br><span class="line">private void handImageLow(Intent data)&#123;</span><br><span class="line">        Uri uri &#x3D; data.getData();</span><br><span class="line">        String path &#x3D; getImagePath(uri,null);</span><br><span class="line">        displayImage(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;content类型的uri获取图片路径的方法</span><br><span class="line">private String getImagePath(Uri uri,String selection) &#123;</span><br><span class="line">        String path &#x3D; null;</span><br><span class="line">        Cursor cursor &#x3D; getContentResolver().query(uri,null,selection,null,null);</span><br><span class="line">        if (cursor!&#x3D;null)&#123;</span><br><span class="line">            if (cursor.moveToFirst())&#123;</span><br><span class="line">                path &#x3D; cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA));</span><br><span class="line">            &#125;</span><br><span class="line">            cursor.close();</span><br><span class="line">        &#125;</span><br><span class="line">        return path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;根据路径展示图片的方法</span><br><span class="line">private void displayImage(String imagePath)&#123;</span><br><span class="line">        if (imagePath !&#x3D; null)&#123;</span><br><span class="line">            Bitmap bitmap &#x3D; BitmapFactory.decodeFile(imagePath);</span><br><span class="line">            imageView.setImageBitmap(bitmap);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            Toast.makeText(this,&quot;fail to set image&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面的代码很多但是不要慌，咱们一个一个来，不难理解的。首先我们知道不同的版本有两个不同的方法来展示图片，就是：handImage和handImageLow。content类型的uri通过getImagePath这个方法来获取真实路径，真实路径通过displayImage这个方法就可以展示出来了。所以主要的工作就是怎么拿到真实路径。现在思路清晰了，让我们一个个来看：</p><p>首先来看一下两个工具方法：getImagePath和displayImage。</p><ul><li>getImagePath学过内容提供器会知道这个就是通过内容提供器来获取数据。通过这个uri以及selection获取到一个Cursor对象。Cursor是什么呢？不了解的读者可以查看这篇博客<a href="https://www.jianshu.com/p/2fc0d39bd2f6" target="_blank" rel="noopener">Android中的Cursor</a>。然后通过这个Cursor对象的MediaStore.Images.Media.DATA这个参数就可以获取到真实路径了。</li><li>displayImage这个方法收一个真实路径字符串，直接通过BitmapFactory.decodeFile这个方法获取到Bitmap再显示出来就行了</li></ul><p>了解了工具方法后，我们的目的就很明确啦：content类型的uri或者真实路径的String。<br>首先是版本低于4.4的，因为返回的是真实的uri，也就是content开头的那个，所以直接通过getImagePath获取真实路径再通过displayImage展示即可。</p><p>接下来这个可能看起来有点头疼，因为要解析不同类型的Uri。我们一个个来看：</p><ul><li><p>第一种是document类型的uri。至于什么是document类型的uri这里就不深入了，只要知道有这种类型的uri，要怎么处理就好了。首先我们要获取一个DocumentId，然后再分两种情况处理：<br>第一种的是media格式的，然后我们要取出后半截字符串我们才能获取到真正的id，这里就真正的id指的是对应数据库表中的id，用于selection的。MediaStore.Images.Media.EXTERNAL_CONTENT_URI就是这个照片的content类型uri，再把selection放进去即可。<br>第二种通过ContentUris.withAppendedId这个方法即可获取到content类型的uri，这个方法负责把id和contentUri连接成一个新的Uri。这个方法在这里也不详细讲解。</p></li><li><p>第二种的是content类型的，那不用说直接用就行了</p></li><li><p>第三种的是file类型的，这个就是真实路径了，直接getPath就可以获取到了。</p></li></ul><p>好了，到此我们的所有疑问也就解决了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>看完之后是不是发现思路很简单但是实现起来很多的知识盲区呢？确实是这样。但是当我们把这些细节都解决了之后我们就会学到很多的东西，相当于以点带面。文中还有好多没有详解的：<br> ContentUris，BitmapFactory，Cursor，DocumentsContract等等。因为这是另外一块比较大的内容，如果要讲的话将会涉及到很多内容就很容易偏离我们的主题了，所以只要知道大概是什么就可以了。<br>·<br>·<br>·</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《第一行代码》郭霖</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Activity生命周期简析</title>
      <link href="/2020/04/21/Android/Android%E5%AE%89%E5%8D%93%E4%B8%ADActivity%E6%B4%BB%E5%8A%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2020/04/21/Android/Android%E5%AE%89%E5%8D%93%E4%B8%ADActivity%E6%B4%BB%E5%8A%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Activity作为安卓四大组件之一，平常我们接触得最多得也是activity，所以很有必要详细了解一下他的详细生命周期。这篇文章定位是有一点安卓基础的，所以还完全不了解的可以先去学习一下activity。这篇文章主要是讲活动的生命周期。<br>活动的生命周期，人有胎儿期，青春期，老年期一样，活动同样有他的各种生命状态。我们出生会哭，进入成年期会有成人礼。活动也一样，每进入一个状态都会回调相应的方法。对于我们来说，活动周期就是活动会在活动具体哪个时候会回调哪一些方法，然后我们可以重写这一些方法，来实现我们的功能。所以我们得具体了解究竟什么时候调用什么方法。例如在onCreate方法中初始化，在destroy中释放内存等等。<br>那接下来就看看他的具体生命周期。</p><h1 id="活动的状态"><a href="#活动的状态" class="headerlink" title="活动的状态"></a>活动的状态</h1><p>首先得了解一下活动的状态。我个人的理解把活动分为四个状态：后台状态，暂停状态，运行状态和销毁状态。</p><ol><li><p>停止状态：这个状态表示活动未进入前台，我们看不到也无法交汇。切换界面活动都会在后台。如果内存紧张的话有可能被回收。就像我们有时候打游戏切换到微信回了一下信息，回来的时候卧槽怎么把我游戏退了，就是这样。</p></li><li><p>运行状态：这个不用多讲，当你在交汇的这个活动就是运行状态。</p></li><li><p>暂停状态：当弹出一个提示框，我们回发现无法与原来的界面交汇了，就是只能点那个提示框。当一个活动位于栈顶，也就是你看的见他，但是你没办法操作他，这个时候就是属于暂停状态。</p></li><li><p>销毁状态：就是被移出栈顶的活动，马上就会被回收了。例如你退出一个应用他马上就会被杀了。</p><h1 id="常规情况下的生命周期"><a href="#常规情况下的生命周期" class="headerlink" title="常规情况下的生命周期"></a>常规情况下的生命周期</h1><h2 id="典型情况下的生命周期"><a href="#典型情况下的生命周期" class="headerlink" title="典型情况下的生命周期"></a>典型情况下的生命周期</h2><p>每个活动正常启动的话都会经历的生命周期如下图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">z[活动启动]--&gt;a</span><br><span class="line">a[onCreate] --&gt; b[onStart]</span><br><span class="line">b --&gt; c[onResume]</span><br><span class="line">c --&gt; d[Activity运行]</span><br><span class="line">d--&gt;e[onPause]</span><br><span class="line">e--&gt;f[onStop]</span><br><span class="line">f--&gt;g[onDestroy]</span><br><span class="line">g--&gt;h[活动销毁]</span><br><span class="line">f--&gt;i[onRestart]</span><br><span class="line">i--&gt;b</span><br><span class="line">e--&gt;c</span><br></pre></td></tr></table></figure><p>每到一个时间点都会调用相关的方法，接下来一个一个来分析一下这些方法。</p></li><li><p>onCreate：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这是我们每个活动都会用到的一个方法。他在活动被创建的时候被调用，且只会调用一次。除非被destroy重新创    建。我们一般在这个方法中做一下初始化的事情。例如加载布局资源等等。细心的读者可能会注意到他有一个Bundle参数，这个参数主要是用于保存被异常销毁事的数据的，这个在后面会讲到</p></li><li><p>onStart:顾名思义这个方法表示活动正在启动，这个时候活动界面已经看的见了，但是还不能与用户交汇，简单点说就是你看得到点不了。但是一般速度很快不会让你感受到这个现象，不然就会好像卡死一样了。所以不能在这个方法中做重量级的操作，初始化什么的都放在onCreate。</p></li><li><p>onResume：这个方法表示活动显示在前台了而且也可以用了。onStart和onResume主要配合onPause和onStop方法来使用，下面会讲到。</p></li><li><p>onPause：活动被暂停的时候会调用到。例如一些弹出提示框，看得到界面但是无法进行交汇。一般执行完这个方法后紧接着就会执行onStop方法了。这个方法可以做一些动画的暂停工作等等轻量级的工作，不然弹个提示框都要卡一下用户体验也很差对吧。<br>如果没有进入onStop这个环节的话，回到原Activity的话，那么就会调用onResume这个方法了</p></li><li><p>onStop：这个方法在活动即将停止的时候调用，同样不能做重量级的工作。一般切换界面，如果内存足够没有被杀死的话，这个活动就会进入停止状态。</p></li><li><p>onRestart：当活动从停止状态回来的时候就会调用这个方法。状态和onStart其实是差不多的，只是为了区分是正常打开的还是从停止状态回来的，可以分别写不同的方法。</p></li><li><p>onDestroy：活动被销毁的时候会调用这个方法。可以做一些资源的释放什么的。但这里要特别强调的一点就是并不是所有情况下活动被销毁都会调用这个方法。例如当你按下返回键回到上个界面，这个当然是会执行这个方法。但是如果你切换到了别的应用或者回到了桌面，这个应用被后台杀死了，那么只有处于栈顶也就是这个应用最后打开的活动会执行destroy方法，其他都不会，需要特别注意一下。<br><img src="https://img-blog.csdnimg.cn/20190916205438446.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc2Njc1Mw==,size_8,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ol><h2 id="一些例外情况的生命周期"><a href="#一些例外情况的生命周期" class="headerlink" title="一些例外情况的生命周期"></a>一些例外情况的生命周期</h2><p>有一句话叫做用户永远不会按照你的设想去使用软件，活动也一样，总是会出现一些比较不一样的情况。这些情况活动是怎么跑的也来看看：</p><ol><li>返回桌面的时候：返回桌面其实就像切换到别的活动是一样的道理，这个时候执行的方法是：onPause –&gt; onStop。</li><li>当活动被系统回收再被打开，流程和打开一个新的活动是一样的。</li><li>打开新的活动时先执行onPause方法再启动新的活动，onStop会慢一点点执行。</li></ol><h1 id="异常情况下的生命周期"><a href="#异常情况下的生命周期" class="headerlink" title="异常情况下的生命周期"></a>异常情况下的生命周期</h1><p>这里的异常情况主要有两种：一种是放在后台被杀死了，不是我们主动去终结他的生命的，第二种是设备的配置发生了改变，例如屏幕翻转。对于这两种情况我们具体来看一下</p><h2 id="情况1-：资源相关的系统配置发生改变"><a href="#情况1-：资源相关的系统配置发生改变" class="headerlink" title="情况1 ：资源相关的系统配置发生改变"></a>情况1 ：资源相关的系统配置发生改变</h2><p>这个资源相关的系统配置怎么说呢。我们的项目目录下不是有drawable-hdpi ，drawable-mdpi，这一类的文件夹，在不同的屏幕尺寸下会获取不同的图片，就像我们手机和平板也是一样有两个不同的配置。平常中我们翻转屏幕时，屏幕尺寸就发生了变化，准确来说时屏幕的长宽比例发生了变化，那么这个时候Activity就会被重建（当然你也可以设置他不重建）。<br>细心的读者会发现，即使我的屏幕翻转了，活动重建了，可是还是保留着刚刚我操作的内容啊！例如我在输入框输入了Hello World翻转后还是Hello World，不是说活动被重建了吗，为什么这些还存在？<br>不知道还记不记得onCreate方法中有一个Bundle参数吗？没错，这个参数就是记录之前的数据的。重建的过程和平常的杀死启动活动有一些不一样，看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">a[Activity运行] --屏幕翻转--&gt;b[onPause,onSaveInstanceState] </span><br><span class="line">b--&gt; c[onStop]</span><br><span class="line">c--&gt;d[onDestroy]</span><br><span class="line">d --重新创建--&gt; e[onCreate]</span><br><span class="line">e--&gt;f[onRestoreInstanceState]</span><br><span class="line">f--&gt;g[onStart,onResume]</span><br><span class="line">g--&gt;h[Activity重新启动]</span><br></pre></td></tr></table></figure><p>可以看到最主要的不同就是多了onSaveInstanceState和onRestoreInstanceState这两个方法。<br>活动在这种异常的情况下被终结生命后，就会调用onSaveInstanceState方法来保存目前的数据，这个方法在onStop方法前调用，但是和onPause方法的前后关系没有必然的关系。然后作为一个Bundle参数传递给重新创建的活动。这个Bundle对象会在onCreate方法中和onRestoreInstanceState中被使用。onRestoreInstanceState这个方法主要就是把刚才的数据还原，执行的次序是在onStart之后。<br>要注意的一点是，onSaveInstanceState方法只有在活动还会被重建的时候才会被调用。例如你手动把他后台杀了，是不会调用这个方法的。</p><h2 id="资源内存不足导致活动被杀死"><a href="#资源内存不足导致活动被杀死" class="headerlink" title="资源内存不足导致活动被杀死"></a>资源内存不足导致活动被杀死</h2><p>当系统内存不足的时候，系统就会按照优先级的大小去杀死一些活动，并在后续通过上面onSaveInstanceState和onRestoreInstanceState方法来恢复数据。优先级按照状态依次是：运行状态，暂停状态，停止状态。一般最有可能是停止状态的活动被杀了。所以一些后台工作就尽量放在service中防止被杀死</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>讲了这么多的生命周期，其实我也是简单讲了我们在使用中一般会遇到的生命周期。有一些读者可能会有这个疑问：为什么我主动调用了onDestroy方法但是活动却没有被杀死？举个例子，你给一个婴儿举办成人礼，他会马上成人吗？要注意的一点就是，我们所说的这些生命周期的回调方法，本质上他们都是一样的，只是被调用的时间不用。他们只是在活动的不同时间被调用，并不是调用这个方法去推进活动的生命进行。主动销毁活动我们用到的是finish（），而不是onDestroy，要特别注意。</p><p>生命周期是活动很重要的一部分，只要了解了他的生命周期我们才可以在准确的时间给他做一些正确的事情。例如你的孩子进入了青春期，你就得跟他说好好学习不要老是想着谈恋爱对吧。我之前自己出过一个低级错误就是在onCreate方法之前使用findViewById，活动都还没创建，怎么找得到布局呢。充分了解这些生命周期后就不会犯这些低级错误了。</p><p>我也是一个安卓新手，有哪些地方写的不好还请大佬们指教</p><p>·<br>·<br>·</p><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p>《Android开发艺术探索》–任玉刚<br>《第一行代码》–郭霖</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
